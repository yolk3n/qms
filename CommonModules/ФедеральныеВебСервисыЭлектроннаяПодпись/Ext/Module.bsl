#Область ЭлектроннаяПодпись
// Добавляет в soap конверт электронную подпись тела сообщения.
Функция ПодписатьSoapСообщение(СообщениеSOAP, Знач Сертификат = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(Сертификат) Тогда
		Сертификат = ПолучитьСертификатПодписанияСообщенийSOAP();
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Сертификат) Тогда
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Информация",
			УровеньЖурналаРегистрации.Информация,
			,
			,
			"Ошибка подписания ответа веб-сервиса: не указан сертификат для подписи сообщений."
		);
		Возврат СообщениеSOAP;
	КонецЕсли;
	
	Попытка
		
		ДокументСТэгамиДляПодписи_ = ДобавитьВПодписываемыйXmlТэгиДляХраненияПодписи(СообщениеSOAP);
		ПодписываемыйXml_ = ДокументСТэгамиДляПодписи_.ПодписываемыйXml;
		
		ПараметрыXMLDSig_ = ЭлектроннаяПодпись.ПараметрыXMLDSig();
		ПараметрыXMLDSig_.XPathSignedInfo = "(//. | //@* | //namespace::*)[ancestor-or-self::*[local-name()='SignedInfo']]";
		ПараметрыXMLDSig_.XPathПодписываемыйТег = СтрШаблон(
			"(//. | //@* | //namespace::*)[
			|	ancestor-or-self::*[
			|		attribute::*[
			|			local-name()='Id'
			|			and string()='%1'
			|			and namespace-uri()='%2'
			|		]
			|	]
			|]",
			ДокументСТэгамиДляПодписи_.wsuId,
			xmlns.wsu()
		);
		
		РеквизитыСертификата_ = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Сертификат, "Программа,ДанныеСертификата");
		
		МенеджерКриптографии_ = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии("Подписание",
			Новый Структура("ПоказатьОшибку, ОписаниеОшибки, Программа, АлгоритмПодписи", Истина, "", РеквизитыСертификата_.Программа)
		);
		
		// Получим пароль
		Пароль_ = ПарольКСертификату(Сертификат);
		
		Если ЗначениеЗаполнено(Пароль_) Тогда
			МенеджерКриптографии_.ПарольДоступаКЗакрытомуКлючу = Пароль_;
		КонецЕсли;
		
		ДанныеСертификата_ = РеквизитыСертификата_.ДанныеСертификата.Получить();
		СертификатДД_ = Новый СертификатКриптографии(ДанныеСертификата_);
		
		ПодписываемыйXml_ = ЭлектроннаяПодписьСлужебный.Подписать(
				ПодписываемыйXml_,
				ПараметрыXMLDSig_,
				СертификатДД_,
				МенеджерКриптографии_
		);
		
	Исключение
		
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			"Ошибка подписания сообщения SOAP",
			СтрШаблон(
				"%1
				|
				|%2
				|",
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
				?(ТипЗнч(ДанныеСертификата_) = Тип("ДвоичныеДанные"), Base64Строка(ДанныеСертификата_), "")
			)
		);
		Возврат СообщениеSOAP;
		
	КонецПопытки;
	
	Возврат 
		"<?xml version=""1.0"" encoding=""UTF-8""?>
		|" + ПодписываемыйXml_
	;
	
КонецФункции

// Подписывает произвольные двоичные данные.
Функция ПодписатьДанные(ДД, СертификатСсылка) Экспорт
	РеквизитыСертификата_ = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СертификатСсылка, "Программа,ДанныеСертификата");
	
	СертификатДД_ = Новый СертификатКриптографии(РеквизитыСертификата_.ДанныеСертификата.Получить());
	
	МенеджерКриптографии_ = ЭлектроннаяПодписьСлужебный.МенеджерКриптографии("Подписание",
		Новый Структура("ПоказатьОшибку, ОписаниеОшибки, Программа, АлгоритмПодписи", Истина, "", РеквизитыСертификата_.Программа)
	);

	// Получим пароль
	Пароль_ = ПарольКСертификату(СертификатСсылка);
	
	Если ЗначениеЗаполнено(Пароль_) Тогда
		МенеджерКриптографии_.ПарольДоступаКЗакрытомуКлючу = Пароль_;
	КонецЕсли;
	
	Подпись_ = МенеджерКриптографии_.Подписать(ДД, СертификатДД_);
	
	Возврат Подпись_;
КонецФункции

// Добавляет в soap конверт тэги необходимые для хранения ЭП.
Функция ДобавитьВПодписываемыйXmlТэгиДляХраненияПодписи(ПодписываемыйXml)
	
	ДокументDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(ПодписываемыйXml);
	КорневойЭлемент_ = ДокументDOM_.ЭлементДокумента;
	
	// Добавим в конверт тег soap:Header, если его не было.
	Если Не "Header" = КорневойЭлемент_.ПервыйДочерний.ЛокальноеИмя Тогда
		Header_ = ДокументDOM_.СоздатьЭлемент(КорневойЭлемент_.URIПространстваИмен, "Header");
		КорневойЭлемент_.ВставитьПеред(Header_, КорневойЭлемент_.ПервыйДочерний);
	КонецЕсли;
	
	// Извлечем или добавим в тело сообщения атрибут wsu:Id.
	ПИ_ = ФедеральныеВебСервисыПовтИсп.РазыменовательПИSOAP(КорневойЭлемент_.URIПространстваИмен);
	XPath_ = "/soap:Envelope/soap:Body/@wsu:Id";
	wsuId_ = ФедеральныеВебСервисыСервер.ПолучитьСтрокуПоXPath(ДокументDOM_, ПИ_, XPath_);
	Если Не ЗначениеЗаполнено(wsuId_) Тогда
		// Добавляем атрибут wsu:Id.
		wsuId_ = "uuid:" + Строка(Новый УникальныйИдентификатор);
		Атрибут_wsuId_ = ДокументDOM_.СоздатьАтрибут(xmlns.wsu(), "wsu:Id");
		Атрибут_wsuId_.Значение = wsuId_;
		КорневойЭлемент_.ПоследнийДочерний.Атрибуты.УстановитьИменованныйЭлемент(Атрибут_wsuId_);
	КонецЕсли;
	
	// Добавим в заголовок сообщения тэг Security.
	Security_ = ШаблонТэгаSecurity(wsuId_);
	SecurityDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(Security_);
	wsseSecurity_ = ДокументDOM_.ИмпортироватьУзел(SecurityDOM_.ПервыйДочерний, Истина);
	КорневойЭлемент_.ПервыйДочерний.ДобавитьДочерний(wsseSecurity_);
	ПодписываемыйXml_ = ФедеральныеВебСервисыСервер.ЗаписатьDOM(ДокументDOM_);
	
	ДокументСТэгамиДляПодписи_ = Новый Структура;
	ДокументСТэгамиДляПодписи_.Вставить("ПодписываемыйXml", ПодписываемыйXml_);
	ДокументСТэгамиДляПодписи_.Вставить("wsuId", wsuId_);
	
	Возврат ДокументСТэгамиДляПодписи_;
	
КонецФункции

Функция ШаблонТэгаSecurity(wsuId)
	
	Шаблон_ =
		"<wsse:Security xmlns:wsse=""%1"" xmlns:wsu=""%2"">
		|	<wsse:BinarySecurityToken
		|			EncodingType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary""
		|			ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""
		|			wsu:Id=""%4"">%6</wsse:BinarySecurityToken>
		|	<ds:Signature xmlns:ds=""%3"">
		|		<ds:SignedInfo>
		|			<ds:CanonicalizationMethod Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
		|			<ds:SignatureMethod Algorithm=""%9""/>
		|			<ds:Reference URI=""#%5"">
		|				<ds:Transforms>
		|					<ds:Transform Algorithm=""http://www.w3.org/2001/10/xml-exc-c14n#""/>
		|				</ds:Transforms>
		|				<ds:DigestMethod Algorithm=""%10""/>
		|				<ds:DigestValue>%7</ds:DigestValue>
		|			</ds:Reference>
		|		</ds:SignedInfo>
		|		<ds:SignatureValue>%8</ds:SignatureValue>
		|		<ds:KeyInfo>
		|			<wsse:SecurityTokenReference>
		|				<wsse:Reference URI=""#%4"" ValueType=""http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0#X509v3""/>
		|			</wsse:SecurityTokenReference>
		|		</ds:KeyInfo>
		|	</ds:Signature>
		|</wsse:Security>";
	
	Результат_ = СтрШаблон(
		Шаблон_,
		xmlns.wsse(),
		xmlns.wsu(),
		xmlns.ds(),
		"uuid:" + Строка(Новый УникальныйИдентификатор), // [SOAP_ACTOR]
		wsuId, // [WSU_ID]
		"%BinarySecurityToken%",
		"%DigestValue%",
		"%SignatureValue%",
		"%SignatureMethod%",
		"%DigestMethod%"
		
	);
	
	Возврат Результат_;
	
КонецФункции

// Сертификат для подписи сообщений SOAP
Функция ПолучитьСертификатПодписанияСообщенийSOAP() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ФедеральныеВебСервисыПереопределяемый.ИспользоватьПодписаниеСообщенийSoap() Тогда
		
		Сертификат_ = Константы.ФедеральныеВебСервисыСертификатПодписиСообщенийSOAP.Получить();
		
		Возврат Сертификат_;
	Иначе
		Возврат Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка();
	КонецЕсли;

КонецФункции

Функция УдалитьПодписьXMLDSigИзЗаголовка(Заголовок) Экспорт
	
	ЗаголовокDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(Заголовок);
	
	КорневойЭлемент_ = ЗаголовокDOM_.ЭлементДокумента;
	
	// Удалим из заголовка подписи.
	ПИ_ = ФедеральныеВебСервисыПовтИсп.РазыменовательПИSOAP(КорневойЭлемент_.URIПространстваИмен);
	XPath_ = "/*/wsse:Security";
	Тип_ = ТипРезультатаDOMXPath.ЛюбойНеупорядоченныйУзел;
	
	Пока Истина Цикл
		РезультатXPath_ = ЗаголовокDOM_.ВычислитьВыражениеXPath(XPath_, ЗаголовокDOM_, ПИ_, Тип_);
		ЭлементDOM_ = РезультатXPath_.ОдиночныйУзелЗначение;
		Если Неопределено = ЭлементDOM_ Тогда
			Прервать;
		КонецЕсли;
		ЭлементDOM_.РодительскийУзел.УдалитьДочерний(ЭлементDOM_);
	КонецЦикла;
	
	Возврат ФедеральныеВебСервисыСервер.ЗаписатьDOM(ЗаголовокDOM_);
	
КонецФункции

Функция ПолучитьСертификатДляПодписиКонвертаSOAP(Адрес) Экспорт
	Возврат ПолучитьСоответствиеСертификатовАдресам()[Адрес];
КонецФункции

Функция ПолучитьСоответствиеСертификатовАдресам()
	
	УстановитьПривилегированныйРежим(Истина);
	
	КешируемыеЗначения_ = ФедеральныеВебСервисыПовтИсп.ПолучитьСтруктуруКешируемыхЗначений();
	
	Значение_ = Неопределено;
	
	Если Не КешируемыеЗначения_.Свойство("СоответствиеСертификатовАдресам", Значение_) Тогда
		// Заведем соответствие.
		СоответствиеСертификатов_ = Новый Соответствие;
		
		// Пока считаем, что все сообщения подписываются одним и тем же сертификатом.
		Сертификат_ = ПолучитьСертификатПодписанияСообщенийSOAP();
		
		// Пробежимся по всем константам, имя которых имеет вид
		// ФедеральныеВебСервисы<ВнутреннееИмя>Адрес<УточнениеАдреса>,
		// причем <УточнениеАдреса> может быть пустым, и проверим,
		// совпадает ли адрес для отправки со значением константы.
		Для Каждого Константа_ Из Метаданные.Константы Цикл
			
			// Пропустим константы, не удовлетворяющие шаблону.
			Успех_ = Истина
				И СтрНачинаетсяС(Константа_.Имя, "ФедеральныеВебСервисы")
				И Не 0 = СтрНайти(Константа_.Имя, "Адрес")
			;
			Если Не Истина = Успех_ Тогда
				Продолжить;
			КонецЕсли;
			
			// Определим внутреннее имя.
			ПозНачала_ = СтрДлина("ФедеральныеВебСервисы");
			ПозКонца_ = СтрНайти(Константа_.Имя, "Адрес");
			ВнутреннееИмя_ = Сред(Константа_.Имя, ПозНачала_ + 1, ПозКонца_ - ПозНачала_ - 1);
			
			Если Ложь
				Или ВнутреннееИмя_ = "РЭМД"
				Или ВнутреннееИмя_ = "ИЭМК"
				Или ВнутреннееИмя_ = "ПрикреплениеОнлайн"
				Или ВнутреннееИмя_ = "ВИМИС"
			Тогда
				// Надо подписывать
				Адрес_ = Константы[Константа_.Имя].Получить();
				СоответствиеСертификатов_.Вставить(Адрес_, Сертификат_);
			КонецЕсли;
			
		КонецЦикла;
		Значение_ = СоответствиеСертификатов_;
		КешируемыеЗначения_.Вставить("СоответствиеСертификатовАдресам", Значение_);
	КонецЕсли;
	
	Возврат Значение_;
	
КонецФункции

// Возвращает пароль к сертификату, если доступен текущему пользователю.
// При вызове в привилегированном режиме текущий пользователь не учитывается.
//
// Параметры:
//  Сертификат - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - вернуть пароль
//                 к указанному сертификату.
//  МассивОтпечатков - Массив - массив отпечатков сертификатов для которых требуется получить сохраненные пароли.
//              
// Возвращаемое значение:
//  Неопределено - пароль для указанного сертификата не указан.
//  Строка       - пароль для указанного сертификата.
//  Соответствие - все заданные пароли по массиву отпечатков,
//                 в виде ключ - сертификат и значение - пароль.
//
Функция ПарольКСертификату(Сертификат = Неопределено, МассивОтпечатков = Неопределено) Экспорт
	
	Если Сертификат <> Неопределено Тогда
		
		УстановитьПривилегированныйРежим(Истина);
		Данные = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Сертификат,"ПаролиСертификатов");
		УстановитьПривилегированныйРежим(Ложь);
		
		Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Пользователь = Пользователи.ТекущийПользователь();
		Пароль = Данные.Получить(Пользователь);
		
		Если ЗначениеЗаполнено(Пароль) Тогда
			Возврат Пароль;
		КонецЕсли;
		
		Пользователь = Справочники.Пользователи.ПустаяСсылка();
		Пароль = Данные.Получить(Пользователь);
		
		Если ЗначениеЗаполнено(Пароль) Тогда
			Возврат Пароль;
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
		
	Если МассивОтпечатков <> Неопределено Тогда
		
		ПаролиСертификатов = Новый Соответствие;
		
		УстановитьПривилегированныйРежим(Истина);
		
		Для Каждого Отпечаток Из МассивОтпечатков Цикл
			
			СертификатПоОтпечатку = ЭлектроннаяПодписьСлужебныйВызовСервера.СсылкаНаСертификат(Отпечаток,Неопределено);
			
			Если ЗначениеЗаполнено(СертификатПоОтпечатку) Тогда
				
				Данные = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(СертификатПоОтпечатку,"ПаролиСертификатов");
				
				Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
					Продолжить;
				КонецЕсли;
				
				Пользователь = Пользователи.ТекущийПользователь();
				Пароль = Данные.Получить(Пользователь);
				
				Если ЗначениеЗаполнено(Пароль) Тогда
					ПаролиСертификатов.Вставить(СертификатПоОтпечатку, Пароль);
				Иначе
					
					Пользователь = Справочники.Пользователи.ПустаяСсылка();
					Пароль = Данные.Получить(Пользователь);
					
					Если ЗначениеЗаполнено(Пароль) Тогда
						ПаролиСертификатов.Вставить(СертификатПоОтпечатку, Пароль);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		УстановитьПривилегированныйРежим(Ложь);
		
		Возврат ПаролиСертификатов;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти
