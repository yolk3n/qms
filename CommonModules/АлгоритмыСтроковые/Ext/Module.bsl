
#Область ПрограммныйИнтерфейс

// Преобразование из 10 в любую систему счисления.
Функция ПреобразоватьИз10ВЛюбую(Знач Значение = 0, Нотация = 36) Экспорт
	
	Если Нотация <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Значение = Число(Значение);
	Если Значение <= 0 Тогда
		Возврат "0";
	КонецЕсли;
	
	Значение = Цел(Значение);
	Результат = "";
	Пока Значение > 0 Цикл
		Результат = Сред("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", Значение%Нотация + 1, 1) + Результат;
		Значение = Цел(Значение/Нотация);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

/// Преобразование из цепочки кодов
//
// Выполняет преобразование, обратное функции ПреобразоватьВЦепочкуКодов.
//  
// Параметры:
//   ИсхСтр - Строка -
//     Строка для преобразования.
//
//  Возвращаемое значение:
//    Строка - Строка, полученная путем преобразования.
///
Функция ПреобразоватьИзЦепочкиКодов(ИсхСтр) Экспорт
	
	
	
	РезСтр = "";
	ВхСтр = ИсхСтр;
	НайденнаяПозиция = Найти(ВхСтр, ";");
	Пока НайденнаяПозиция <> 0 Цикл
		ЛевСтр = Лев(ВхСтр, НайденнаяПозиция - 1);
		ПравСтр = Прав(ВхСтр, СтрДлина(ВхСтр) - НайденнаяПозиция);
		Симв = Символ(Число(ЛевСтр));
		РезСтр = РезСтр + Симв;
		ВхСтр = ПравСтр;
		НайденнаяПозиция = Найти(ВхСтр, ";");
	КонецЦикла;
	
	Возврат РезСтр;
	
КонецФункции

// Функция преобразовывает строку в тип Дата
//
// Параметры
//	ПредставлениеДаты - строка, представляющая дату
//
// Возвращаемое значение
//	Дата - дата из строки или '00010101'
//
Функция ПреобразоватьСтрокуВДату(Знач ПредставлениеДаты) Экспорт
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "-", "."); 
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "/", "."); 
	ПредставлениеДаты = СтрЗаменить(ПредставлениеДаты, "\", "."); 
	
	Возврат СтроковыеФункцииКлиентСервер.СтрокаВДату(ПредставлениеДаты);
КонецФункции

/// Преобразование в цепочку кодов
//
// Преобразует переданную строку в цепочку 
// кодов символов, из которых она состоит, разделенных ";".
//  
// Параметры:
//   ИсхСтр - Строка -
//      Строка для преобразования.
//
// Возвращаемое значение:
//   Строка - Строка, которая состоит из кодов символов.
///
Функция ПреобразоватьСтрокуВЦепочкуКодов(ИсхСтр) Экспорт
	
	
	
	РезСтр = "";
	Для Ном = 1 По СтрДлина(ИсхСтр) Цикл
		СимволСтр = Сред(ИсхСтр,Ном,1);
		КодСимволаСтр = Строка(КодСимвола(ИсхСтр,Ном));
		РезСтр = РезСтр + КодСимволаСтр + ";";
	КонецЦикла;
	
	Возврат РезСтр;
	
КонецФункции

/// Разбиение строки в массив подстрок заданной длины
//
// Разбивает строку на отрезки.
//  
//  Параметры:
//    СтрокаПреобразования - Строка -
//      Строка для преобразования.
//    РазделительСтрок - Строка -
//      Символ, которым будем разделять строки на отрезки.
//    Разделитель - Строка -
//      Символ, после которого можно переносить строку.
//    ДлинаСтроки - Число -
//      Длина отрезка строки.
//
//  Возвращаемое значение:
//    Строка - Строка с разбиением на отрезки.
///
Функция РазбитьСтрокуНаДлины(
				Знач СтрокаПреобразования,
				Знач РазделительСтрок = "",
				Знач Разделитель = ";",
				Знач ДлинаСтроки = 100
			) Экспорт
	
	ИтоговаяСтрока = СтрокаПреобразования;
	Итератор = ДлинаСтроки;
	Пока Итератор < СтрДлина(ИтоговаяСтрока) Цикл
		ПраваяЧасть = Сред(ИтоговаяСтрока, Итератор);
		ПозицияРазделителя = Найти(ПраваяЧасть, Разделитель);
		Если ПозицияРазделителя = 0 Тогда
			Прервать;
		Иначе
			ИтоговаяСтрока = Лев(ИтоговаяСтрока, Итератор - 1 + ПозицияРазделителя) +
							РазделительСтрок +
							Сред(ИтоговаяСтрока, Итератор + ПозицияРазделителя);
			
			Итератор = Итератор + ПозицияРазделителя + 6;
		КонецЕсли;
		
		Итератор = Итератор + ПозицияРазделителя + 100;
	КонецЦикла;
	
	Возврат ИтоговаяСтрока;
	
КонецФункции

/// Разбиение многоязычной строки в массив подстрок
//
// Разбивает строку в формате НСТР на подстроки по языкам.
//  
// Параметры:
//   СтрокаНСТР - Строка -
//     Строка для преобразования.
//
// Возвращаемое значение:
//   Массив - Массив структур с полями КодЯзыка, СтрокаЯзыкаВНСтр.
///
Функция РазбитьСтрокуНСтрВМассивПодстрок(СтрокаНСТР) Экспорт
	
	
	
	МассивВозврата = Новый Массив();
	СтокаПолностью = СтрокаНСТР;  
	ФорматнаяСтрока = СтокаПолностью;
	СтрокаЧастично = СтокаПолностью;
	ПоследнийКол = 0;
	Итератор = 0;
	Пока Истина Цикл
		// Удаляем экранированные кавычки и заменяем их пробелами, чтобы число символов в строке не поменялось.
		ФорматнаяСтрока = СтрЗаменить(ФорматнаяСтрока,"""""","  ");
		ФорматнаяСтрока = СтрЗаменить(ФорматнаяСтрока,"''","  ");
		СтруктураЯзыка = Новый Структура("КодЯзыка,СтрокаЯзыкаВНСтр");
		Если Итератор = 0 Тогда
			// для первого языка просто ищем по равно
			Равно=Найти(ФорматнаяСтрока,"=");
			КодЯзыка = СокрЛП(Лев(ФорматнаяСтрока,Равно-1));
		Иначе
			// Для всех кроме первого языка смотрим какая кавычка появилась раньше
			// и получаем код языка.
			ПозицияДвойныеКавычки = Найти(ФорматнаяСтрока, "=""");
			ПозицияОдинарныеКавычки = Найти(ФорматнаяСтрока, "='");
			Если ПозицияДвойныеКавычки = ПозицияОдинарныеКавычки Тогда 
				Прервать;
			ИначеЕсли ПозицияДвойныеКавычки > ПозицияОдинарныеКавычки ИЛИ ПозицияДвойныеКавычки = 0 Тогда
				Равно = ПозицияОдинарныеКавычки;
				КодЯзыка = СтрЗаменить(Лев(ФорматнаяСтрока,Равно-1),";","");
				КодЯзыка = СокрЛП(КодЯзыка);
			ИначеЕсли ПозицияДвойныеКавычки < ПозицияОдинарныеКавычки ИЛИ ПозицияОдинарныеКавычки = 0 Тогда	
				Равно = ПозицияДвойныеКавычки;
				КодЯзыка = СтрЗаменить(Лев(ФорматнаяСтрока,Равно-1),";","");
				КодЯзыка = СокрЛП(КодЯзыка);
			КонецЕсли;
		КонецЕсли;
		СтрокаБезЯзыка = Сред(ФорматнаяСтрока,Равно+1);
		СимволКавычек = ЛЕВ(СтрокаБезЯзыка,1);
		Кол = Равно;
		// считаем сколько символов в строке первого языка в форматной стоке
		Если СимволКавычек = """" или СимволКавычек = "'" Тогда
			Кол = Кол +1;
			СтрокаДляРазбиения =  Сред(ФорматнаяСтрока,Равно+2);
			Пока НЕ ПустаяСтрока(СтрокаДляРазбиения) Цикл
				Символ = ЛЕВ(СтрокаДляРазбиения,1);
				Кол = Кол + 1;
				Если Символ = СимволКавычек Тогда
					Прервать;
				КонецЕсли;
				СтрокаДляРазбиения=Сред(СтрокаДляРазбиения,2);
			КонецЦикла;
		КонецЕсли;
		СтруктураЯзыка.КодЯзыка = КодЯзыка;
		СтруктураЯзыка.СтрокаЯзыкаВНСтр = НСтр(СтокаПолностью,КодЯзыка);
		// восстанавливаем строку из первоначальной строки, чтобы ее удалить
		СтрокаЯзыка = КодЯзыка+"="+Сред(СтокаПолностью,ПоследнийКол+1+Равно,ПоследнийКол+Кол-Равно);
		ПоследнийКол = Кол;
		// формируем строку без уже заполненного в структуру языка
		ФорматнаяСтрока = СтрЗаменить(СтрокаЧастично,СтрокаЯзыка,"");
		СтрокаЧастично = ФорматнаяСтрока; 
		Итератор = Итератор+1;
		МассивВозврата.Добавить(СтруктураЯзыка);
	КонецЦикла;
	Возврат МассивВозврата;
КонецФункции

/// Разбиение строки в ВерблюжьейНотации на слова
//
// Выполняет разбиение строки по верхнему регистру.
//  
// Параметры:
//   СтрокаРазбиения - Строка -
//     Строка для преобразования.
//
// Возвращаемое значение:
//   Строка - Строка, полученная путем преобразования из верблюжьей нотации.
//     Пример: ПримерСтрокиДляРазбиения - Пример строки для разбиения.
///
Функция РазбитьСтрокуПоВерхнемуРегистру(Знач СтрокаРазбиения) Экспорт
	
	Итератор = 1;
	ВозвращаемоеНаименование = "";
	
	Пока Итератор <= СтрДлина(СтрокаРазбиения) Цикл
		ТекущийСимвол = Сред(СтрокаРазбиения, Итератор, 1);
		
		Если ТекущийСимвол = ВРег(ТекущийСимвол) И Итератор > 1 Тогда
			ВозвращаемоеНаименование = ВозвращаемоеНаименование + " " + НРег(ТекущийСимвол);
		Иначе
			ВозвращаемоеНаименование = ВозвращаемоеНаименование + ТекущийСимвол;
		КонецЕсли;
		
		Итератор = Итератор + 1;
	КонецЦикла;
	
	Возврат ВозвращаемоеНаименование;
КонецФункции

// Зеркальное отражение строки.
Функция РазвернутьСтроку(Знач ИсходнаяСтрока) Экспорт
	
	Результат = "";
	
	Итератор = СтрДлина(ИсходнаяСтрока);
	Пока Итератор > 0 Цикл
		Результат = Результат + Сред(ИсходнаяСтрока, Итератор, 1);
		Итератор = Итератор - 1;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

/// Создание строки из повторяющихся подстрок
//
// Параметры:
//   Подстрока - Строка -
//     Повторяющаяся подстрока.
//   N - Число -
//     Число повторений.
//   Разделитель - Строка -
//     Разделитель, вставляемый между повторяющимися подстроками.
//
// Возвращаемое значение:
//   Строка - Строка из N Подстрок, разеделенных Разделителем.
///
Функция СтепеньСтроки(Знач Подстрока, Знач ЧислоПовторений, Разделитель) Экспорт
	
	Если 0 = ЧислоПовторений Тогда
		Возврат "";
	КонецЕсли;
	
	Пока 0 = ЧислоПовторений % 2 Цикл
		Подстрока = СтрШаблон("%1%2%3", Подстрока, Разделитель, Подстрока);
		ЧислоПовторений = ЧислоПовторений / 2;
	КонецЦикла;
	
	Результат_ = Подстрока;
	ЧислоПовторений = (ЧислоПовторений - 1) / 2;
	
	Пока Не 0 = ЧислоПовторений Цикл
		
		Подстрока = СтрШаблон("%1%2%3", Подстрока, Разделитель, Подстрока);
		
		Если 0 = ЧислоПовторений % 2 Тогда
			ЧислоПовторений = ЧислоПовторений / 2;
		Иначе
			ЧислоПовторений = (ЧислоПовторений - 1) / 2;
			Результат_ = СтрШаблон("%1%2%3", Подстрока, Разделитель, Результат_);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат_;
	
КонецФункции

/// Замена подстроки строки на заданную строку
//
// Параметры:
//   Строка - Строка -
//     Изменяемая строка.
//   ПозицияНачала - Число -
//     Начальная позиция заменяемой подстроки, индексируется с 1.
//   ДлинаПодстроки - Число -
//     Количество заменяемых символов.
//   СтрокаЗамены - Строка -
//     Строка, на которую заменяется подстрока исходной строки.
//   НаМесте - Булево -
//     Если Истина, то меняется сама Строка.
//
// Возвращаемое значение:
//   Строка - Строка, полученная в результате замены.
///
Функция СтрЗаменитьПодстроку(Строка, ПозицияНачала, ДлинаПодстроки, СтрокаЗамены, НаМесте = Ложь) Экспорт
	
	Лево_ = ?(ПозицияНачала > 1, Лев(Строка, ПозицияНачала - 1), "");
	Право_ = Сред(Строка, ПозицияНачала + ДлинаПодстроки);
	Результат_ = Лево_ + СтрокаЗамены + Право_;
	
	Если Истина = НаМесте Тогда
		Строка = Результат_;
	КонецЕсли;
	
	Возврат Результат_;
	
КонецФункции

/// Преобразование строки в массив чисел
//
// Параметры:
//   СтрокаЧисел - Строка -
//     Строка десятичных чисел, разделенных Разделителем.
//   Разделитель - Строка -
//     Строка символов, каждый из которых является индивидуальным разделителем.
//
// Возвращаемое значение:
//   Массив - Массив, элементы которого преобразованы в числа.
///
Функция СтрРазделитьВЧисла(СтрокаЧисел, Разделитель) Экспорт
	
	// Пустая строка - означает пустой массив.
	Если СтрокаЧисел = "" Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	Массив_ = СтрРазделить(СтрокаЧисел, Разделитель, Ложь);
	
	Для Индекс_ = 0 По Массив_.Количество() - 1 Цикл
		Массив_[Индекс_] = Число(Массив_[Индекс_]);
	КонецЦикла;
	
	Возврат Массив_;
	
КонецФункции

// Преобразование структуры в строку. Учитывается вложимость массивов и структур.
//
// Параметры:
//  Структура														 - Структура, ФиксированнаяСтруктура, Соответствие - Преобразуемая структура.
//  РазделительМеждуКлючомИЗначением		 - Строка																					 - Разделитель, помещаемый между ключом и значение в результирующей строке.
//  РазделительМеждуЭлементамиКоллекции	 - Строка																					 - Резделитель, помещаемый между элементами коллекции
//  МаксимальнаяГлубинаРазвертывания		 - Число																					 - Максимальная глубина, которая позволяется для преобразования вложенных структур и массивов
// 
// Возвращаемое значение:
//  Строка - Строковое представление структуры.
//
Функция СтрСоединитьСтруктуру(Структура, РазделительМеждуКлючомИЗначением = "", РазделительМеждуЭлементамиКоллекции = "", МаксимальнаяГлубинаРазвертывания = 10) Экспорт
	Возврат ПреобразоватьВСтроку(
		Структура, 
		РазделительМеждуКлючомИЗначением, 
		РазделительМеждуЭлементамиКоллекции, 
		0, 
		МаксимальнаяГлубинаРазвертывания
	);
КонецФункции

/// Удаление из строки символа разделителя групп разрядов текущей локали
//
// Параметры:
//   Строка - Строка -
//     Строка, и которой нужно удалить разделитель групп разрядов текущей локали.
//
// Возвращаемое значение:
//   Строка - Строка, из которой удален символ разделителя групп разрядов в текущей локали.
///
Функция УдалитьРазделительГрупп(Строка) Экспорт
	
	Разделитель_ = МагическиеКонстанты.РазделительГруппРазрядов();
	
	Если Разделитель_ = "" Тогда
		Возврат Строка;
	КонецЕсли;
	
	Возврат СтрЗаменить(Строка, Разделитель_, "");
	
КонецФункции

/// Удаление из строки всех символов, не входящих в множество допустимых
//
// Параметры:
//   Строка - Строка -
//     Строка, из которой нужно удалить все символы, кроме заданных
//   МножествоДопустимыхСимволов - Строка -
//     Строка символов, которые не должны быть удалены из исходной строки.
//
// Возвращаемое значение:
//   Строка, из которой удалены все символы, не являющиеся допустимыи.
///
Функция УдалитьСимволыКроме(Знач Строка, МножествоДопустимыхСимволов) Экспорт
	
	ПодстрокиНедопустимыхСимволов_ = СтрРазделить(Строка, МножествоДопустимыхСимволов, Ложь);
	НедопустимыеСимволы_ = СтрСоединить(ПодстрокиНедопустимыхСимволов_, "");
	
	КолВоПодстрок_ = ПодстрокиНедопустимыхСимволов_.Количество();
	
	Если КолВоПодстрок_ < 13 И КолВоПодстрок_ * 4 < СтрДлина(НедопустимыеСимволы_) Тогда
		// Выбираем алгоритм, в котром будем заменять недопустимые подстроки на пустые строки.
		
		Для Каждого Подстрока_ Из ПодстрокиНедопустимыхСимволов_ Цикл
			Строка = СтрЗаменить(Строка, Подстрока_, "");
		КонецЦикла;
		
	Иначе
		// Выбираем алгоритм, в котором будем удалять недопустимые символы по одному.
		
		Пока СтрДлина(НедопустимыеСимволы_) > 0 Цикл
			Символ_ = Сред(НедопустимыеСимволы_, 1, 1);
			Строка = СтрЗаменить(Строка, Символ_, "");
			НедопустимыеСимволы_ = СтрЗаменить(НедопустимыеСимволы_, Символ_, "");
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

/// Убирает пробельные символы из строки
//
// Параметры:
//  Строка - Строка	 - Входная строка
// 
// Возвращаемое значение:
//  Строка - Строка без пробельных символов
//
Функция УдалитьПробельныеСимволы(Знач Строка) Экспорт
	Возврат СтрСоединить(СтрРазделить(Строка, МагическиеКонстанты.ПробельныеСимволы(), Ложь), "");
КонецФункции

/// Замена в строке XML перевода строки с последующими пробелами на &#xD;.
//
// Функцию полезно вызывать перед чтением XML, чтобы сохранить перевод строк.
//
// Параметры:
//   СтрокаXML - Строка - Строка XML.
//
// Возвращаемое значение:
//   Строка - модифицированная строка XML.
///
Функция СохранитьПереводыСтрокВАтрибутахXML(СтрокаXML) Экспорт
	
	// Алгоритм работает следующм образом.
	// Ищем первый из символов " или '.
	// Ищем следующий такой же символ.
	// В строке между этими символами заменяем
	// выполняем глобальную замену регулярного выражения
	// /\n\s*(&#13;&#10;|&#13;|&#10;|&#xD;&#xA;|&#xD;|&#xA;)?/
	// на "&#xD;".
	
	// Самый эффективный способ сформировать строку из кусочков,
	// воспользоваться функцией СтрСоединить.
	// Для этого все кусочки сначала поместим в массив.
	МассивПодстрокРезультата_ = Новый Массив;
	
	// В следующем массиве порядок элементов должен быть таким, что
	// элемент с меньшим индексом не должен быть подстрокой элемента с большим индексом.
	НеобязательныеЗавершающиеПодстроки_ = АлгоритмыДляКоллекций.СоздатьМассив(
		"&#13;&#10;", "&#10;&#13;", "&#13;", "&#10;", "&#xD;&#xA;", "&#xA;&#xD;", "&#xD;", "&#xA;"
	);
	// Чтобы сравнивать подстроки, сохраним также их длины.
	ДлиныЗавершающихПодстрок_ = Новый Массив;
	Для Каждого Подстрока_ Из НеобязательныеЗавершающиеПодстроки_ Цикл
		ДлиныЗавершающихПодстрок_.Добавить(СтрДлина(Подстрока_));
	КонецЦикла;
	
	// В документ будем помещать
	СущностьПереводаСтроки_ = "&#xD;";
	СущностьПереводаСтроки_ = "&#13;&#10;";
	
	ДлинаСтроки_ = СтрДлина(СтрокаXML);
	
	ОткрКавычки_ = АлгоритмыДляКоллекций.СоздатьМассив("""", "'", "<!--");
	ЗакрКавычки_ = АлгоритмыДляКоллекций.СоздатьМассив("""", "'", "-->");
	ПозКавычки_ = АлгоритмыДляКоллекций.СоздатьМассив(0, 0, 0);
	ИндексКомментария_ = ОткрКавычки_.Найти("<!--");
	МаксимальныйИндексКавычки_ = ОткрКавычки_.Количество() - 1;
	
	ДлиныКавычек_ = Новый Массив;
	Для ИндексКавычки_ = 0 По МаксимальныйИндексКавычки_ Цикл
		ДлиныКавычек_.Добавить(СтрДлина(ОткрКавычки_[ИндексКавычки_]));
	КонецЦикла;
	
	ПозНачалаПодстроки_ = 1;
	ПозТекущая_ = 1;
	Пока ПозТекущая_ <= ДлинаСтроки_ Цикл
		
		// Поищем следующую кавычку каждого типа и найдем ближайшую среди них.
		ПозБлижайшейКавычки_ = ДлинаСтроки_ + 1;
		ИндексБлижайшейКавычки_ = Неопределено;
		Для ИндексКавычки_ = 0 По МаксимальныйИндексКавычки_ Цикл
			ПозТекКавычки_ = ПозКавычки_[ИндексКавычки_];
			Если ПозТекКавычки_ < ПозТекущая_ Тогда
				ПозТекКавычки_ = ВыбратьЗаполненное(
					СтрНайти(СтрокаXML, ОткрКавычки_[ИндексКавычки_], , ПозТекущая_),
					ДлинаСтроки_ + 1
				);
				ПозКавычки_[ИндексКавычки_] = ПозТекКавычки_;
			КонецЕсли;
			Если ПозТекКавычки_ < ПозБлижайшейКавычки_ Тогда
				ПозБлижайшейКавычки_ = ПозТекКавычки_;
				ИндексБлижайшейКавычки_ = ИндексКавычки_;
			КонецЕсли;
		КонецЦикла;
		
		Если Неопределено = ИндексБлижайшейКавычки_ Тогда
			// Нет больше кавычек, завершаем цикл.
			Прервать;
		КонецЕсли;
		
		// Найдем закрывающую кавычку.
		ПозТекущая_ = 1 + СтрНайти(
			СтрокаXML,
			ЗакрКавычки_[ИндексБлижайшейКавычки_],
			, // НаправлениеПоиска
			ПозБлижайшейКавычки_ + ДлиныКавычек_[ИндексБлижайшейКавычки_]
		);
		
		// Если не найдем, пусть будет исключение.
		__ПРОВЕРКА__(ПозТекущая_ > 1, "bf20cd20-a987-11eb-8322-b3c6c8d80acc");
		
		// Если это комментарий, пропустим его.
		Если ИндексБлижайшейКавычки_ = ИндексКомментария_ Тогда
			Продолжить;
		КонецЕсли;
		
		// Найдем первое вхождение перевода строки после открывающей кавычки.
		ПозПереводаСтроки_ = ВыбратьЗаполненное(
			СтрНайти(СтрокаXML, Символы.ПС, , ПозБлижайшейКавычки_),
			ДлинаСтроки_ + 1
		);
		
		// Если нет переводов строки между кавычками, перейдем к следующей итерации.
		Если ПозТекущая_ <= ПозПереводаСтроки_ Тогда
			Продолжить;
		КонецЕсли;
		
		// Теперь, собственно сделаем то, ради чего весь сыр-бор.
		// Выберем подстроку, включая кавычки.
		ПодстрокаВКавычках_ = Сред(СтрокаXML, ПозБлижайшейКавычки_, ПозТекущая_ - ПозБлижайшейКавычки_);
		
		// Сначала добавим подстроку до кавычки.
		Если Не ПозБлижайшейКавычки_ = ПозНачалаПодстроки_ Тогда
			Подстрока_ = Сред(СтрокаXML, ПозНачалаПодстроки_, ПозБлижайшейКавычки_ - ПозНачалаПодстроки_);
			МассивПодстрокРезультата_.Добавить(Подстрока_);
		КонецЕсли;
		
		// Сразу изменим значение переменной ПозНачалаПодстроки_.
		ПозНачалаПодстроки_ = ПозТекущая_;
		
		// Разделим найденную строку на части по символу перевода строки.
		МассивПодстрок_ = СтрРазделить(ПодстрокаВКавычках_, Символы.ПС);
		
		// Первый элемент не обрабатываем, а сразу помещаем в массив подстрок результата.
		МассивПодстрокРезультата_.Добавить(МассивПодстрок_[0]);
		
		// Остальные обрабатывам по-отдельности.
		Для Индекс_ = 1 По МассивПодстрок_.Количество() - 1 Цикл
			
			// Добавляем XML-сущность символа перевода строки.
			МассивПодстрокРезультата_.Добавить(СущностьПереводаСтроки_);
			
			// Удалим пробельные символы из начала подстроки.
			Подстрока_ = СокрЛ(МассивПодстрок_[Индекс_]);
			
			// Если подстрока начинается с необязательной завершающей подстроки,
			// удалим и её.
			Для Каждого ЗавершающаяПодстрока_ Из НеобязательныеЗавершающиеПодстроки_ Цикл
				Если СтрНачинаетсяС(Подстрока_, ЗавершающаяПодстрока_) Тогда
					Подстрока_ = Сред(Подстрока_, СтрДлина(ЗавершающаяПодстрока_) + 1);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			// Остаток закинем в массив подстрок результата.
			Если ЗначениеЗаполнено(Подстрока_) Тогда
				МассивПодстрокРезультата_.Добавить(Подстрока_);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Добавим оставшийся хвост строки.
	Если ПозНачалаПодстроки_ <= ДлинаСтроки_ Тогда
		Подстрока_ = Сред(СтрокаXML, ПозНачалаПодстроки_, ДлинаСтроки_ + 1 - ПозНачалаПодстроки_);
		МассивПодстрокРезультата_.Добавить(Подстрока_);
	КонецЕсли;
	
	// Соединим всё в кучу и возвратим результат.
	Возврат СтрСоединить(МассивПодстрокРезультата_, "");
	
КонецФункции

// Заменяет в строке вхождения &, <, >, а также при необходимости кавычки на экранированные значения XML.
//
// Параметры:
//  Текст					 - Строка	 - Входная строка
//  ВключаяКавычки - Булево	 - Нужно ли заменять кавычки
// 
// Возвращаемое значение:
//  Строка - Экранированное значение
//
Функция Экранировать(Знач Текст, ВключаяКавычки = Ложь) Экспорт
	
	Результат_ = СтрЗаменить(Текст, "&", "&amp;");
	Результат_ = СтрЗаменить(Результат_, "<", "&lt;");
	Результат_ = СтрЗаменить(Результат_, ">", "&gt;");
	Если Истина = ВключаяКавычки Тогда 
		Результат_ = СтрЗаменить(Результат_, """", "&quot;");
		Результат_ = СтрЗаменить(Результат_, "'",  "&apos;");
	КонецЕсли;
	Возврат Результат_;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПреобразоватьВСтроку(Значение, РазделительМеждуКлючомИЗначением, РазделительМеждуЭлементамиКоллекции, Глубина, МаксимальнаяГлубина)
	Результат_ = "";
	Тип_ = ТипЗнч(Значение);
	Если (Глубина <= МаксимальнаяГлубина) 
		И (Тип_ = Тип("Структура") 
				ИЛИ Тип_ = Тип("ФиксированнаяСтруктура") 
				ИЛИ Тип_ = Тип("Соответствие") 
			)
	Тогда 
		МассивСтрок_ = Новый Массив();
		Для Каждого КлючИЗначение_ Из Значение Цикл
			МассивСтрок_.Добавить(
				СтрШаблон(
					"%1%2%3",
					КлючИЗначение_.Ключ,
					РазделительМеждуКлючомИЗначением,
					ПреобразоватьВСтроку(
						КлючИЗначение_.Значение, 
						РазделительМеждуКлючомИЗначением, 
						РазделительМеждуЭлементамиКоллекции, 
						Глубина + 1, 
						МаксимальнаяГлубина
					)
				)
			);
		КонецЦикла;
		Результат_ = СтрСоединить(МассивСтрок_, РазделительМеждуЭлементамиКоллекции);
	ИначеЕсли (Глубина <= МаксимальнаяГлубина) 
		И (Тип_ = Тип("Массив") 
			)
	Тогда 
		МассивСтрок_ = Новый Массив();
		Для Каждого ЭлементКоллекции_ Из Значение Цикл 
			МассивСтрок_.Добавить(
				ПреобразоватьВСтроку(
					ЭлементКоллекции_, 
					РазделительМеждуКлючомИЗначением, 
					РазделительМеждуЭлементамиКоллекции, 
					Глубина + 1, 
					МаксимальнаяГлубина
				)
			)
		КонецЦикла;
		Результат_ = СтрСоединить(МассивСтрок_, РазделительМеждуЭлементамиКоллекции);
	Иначе
		Результат_ = Строка(Значение);
	КонецЕсли;
	
	Возврат Результат_;
КонецФункции

#КонецОбласти