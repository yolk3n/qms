
#Область ПрограммныйИнтерфейс

Функция ПолучитьКодАутентификации(Знач ТранспортныйМодуль) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ПолучитьКодАутентификации");
	#Иначе
		ЗапросКодаАутентификации = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ЗапросКодаАутентификации.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "auth";
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("client_id"    , ТранспортныйМодуль.ИдентификаторКлиента);
		ТелоЗапроса.Вставить("client_secret", ТранспортныйМодуль.СекретКлиента);
		Если ТранспортныйМодуль.ТипАутентификации = ПредопределенноеЗначение("Перечисление.ТипыАутентификацииМДЛП.ЭП") Тогда
			СертификатКриптографии = Новый СертификатКриптографии(ПолучитьИзВременногоХранилища(ТранспортныйМодуль.Сертификат.Данные));
			ТелоЗапроса.Вставить("user_id"  , ПолучитьHexСтрокуИзДвоичныхДанных(СертификатКриптографии.Отпечаток));
			ТелоЗапроса.Вставить("auth_type", "SIGNED_CODE");
		Иначе
			ТелоЗапроса.Вставить("user_id"  , ТранспортныйМодуль.ИдентификаторПользователя);
			ТелоЗапроса.Вставить("auth_type", "PASSWORD");
		КонецЕсли;
		
		ЗапросКодаАутентификации.ТелоЗапроса = ТелоЗапроса;
		
		Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ЗапросКодаАутентификации);
		Если Результат.Статус = "Ошибка" Тогда
			Если Результат.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				ТаймаутМеждуЗапросами = 1000;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ЗапросКодаАутентификации);
				КонецЦикла;
			ИначеЕсли Не Результат.ТребуетсяАвторизация Тогда
				Если ТранспортныйМодуль.ТипАутентификации = ПредопределенноеЗначение("Перечисление.ТипыАутентификацииМДЛП.ЭП") Тогда
					ТелоЗапроса.Вставить("user_id", ПолучитьДесятичнуюСтрокуИзHexСтроки(ПолучитьHexСтрокуИзДвоичныхДанных(СертификатКриптографии.СерийныйНомер)));
					ЗапросКодаАутентификации.ТелоЗапроса = ТелоЗапроса;
					Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ЗапросКодаАутентификации);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Результат.Статус = "Ошибка" Тогда
			Результат.ОписаниеОшибки = НСтр("ru = 'Ошибка при получении кода аутентификации'") + ":" + Символы.ПС + Результат.ОписаниеОшибки;
			Если Результат.КодОшибки = 404 Тогда
				Результат.ОписаниеОшибки = Результат.ОписаниеОшибки
					+ Символы.ПС
					+ НСтр("ru = 'Проверьте корректность заполнения Идентификатора клиента, Секретного кода а так же, что выбран правильный сертификат.'");
			КонецЕсли;
			Возврат Результат;
		КонецЕсли;
		
		КодАутентификации = Результат.Данные["code"];
		Результат.Вставить("КодАутентификации", КодАутентификации);
		Возврат Результат;
	#КонецЕсли
	
КонецФункции

Функция ПолучитьКлючСессии(Знач ТранспортныйМодуль, Знач КодАутентификации, Знач ПодписьИлиПароль) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(КодАутентификации);
		ПараметрыМетода.Добавить(ПодписьИлиПароль);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ПолучитьКлючСессии", ПараметрыМетода);
	#Иначе
		ЗапросТокена = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ЗапросТокена.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "token";
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("code", КодАутентификации);
		Если ТранспортныйМодуль.ТипАутентификации = ПредопределенноеЗначение("Перечисление.ТипыАутентификацииМДЛП.ЭП") Тогда
			Если ТипЗнч(ПодписьИлиПароль) = Тип("ДвоичныеДанные") Тогда
				ПодписьИлиПароль = УдалитьРазделителиСтрок(ПолучитьBase64СтрокуИзДвоичныхДанных(ПодписьИлиПароль));
			КонецЕсли;
			ТелоЗапроса.Вставить("signature", ПодписьИлиПароль);
		Иначе
			ТелоЗапроса.Вставить("password", ПодписьИлиПароль);
		КонецЕсли;
		
		ЗапросТокена.ТелоЗапроса = ТелоЗапроса;
		
		Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ЗапросТокена);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			ТаймаутМеждуЗапросами = 1000;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ЗапросТокена);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Результат.ОписаниеОшибки = НСтр("ru = 'Ошибка при получении ключа сессии'") + ":" + Символы.ПС + Результат.ОписаниеОшибки;
			Возврат Результат;
		КонецЕсли;
		
		Ответ = Результат.Данные;
		Результат.Вставить("КлючСессии", Ответ["token"]);
		
		// Максимальное время жизни ключа сессии.
		// При длительном неиспользовании ключа сессии в МДЛП он становиться недействующим до истечения указанного времени жизни.
		Результат.Вставить("ВремяЖизни", Ответ["life_time"]);
		
		Возврат Результат;
	#КонецЕсли
	
КонецФункции

Функция ПолучитьОграничениеРазмераНебольшихДокументов(Знач ТранспортныйМодуль) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ПолучитьОграничениеРазмераНебольшихДокументов");
	#Иначе
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/doc_size";
		
		Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			ТаймаутМеждуЗапросами = 500;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат.Вставить("ОграничениеРазмераНебольшихДокументов", Результат.Данные["doc_size"]);
		
		Возврат Результат;
	#КонецЕсли
	
КонецФункции

Функция ОтправитьСообщение(ТранспортныйМодуль, Сообщение) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ОтправитьСообщение", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Сообщение));
	#Иначе
		Если Не ЗначениеЗаполнено(Сообщение.ИдентификаторЗапроса) Тогда
			Попытка
				Сообщение.ИдентификаторЗапроса = ТранспортМДЛПКлиентСервер.СгенерироватьИдентификаторЗапроса();
			Исключение
				Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
				Результат.Статус = "Ошибка";
				Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
				Возврат Результат;
			КонецПопытки;
		КонецЕсли;
		РезультатОтправки = ОтправитьТекстСообщения(ТранспортныйМодуль, Сообщение);
		Если РезультатОтправки.Статус <> "Ошибка" Тогда
			ТранспортМДЛПАПИВызовСервера.ДобавитьСообщениеВОчередьПолученияКвитанций(Сообщение.Ссылка, ТранспортныйМодуль.ИдентификаторОрганизации, Сообщение.ОбновитьСостояниеПодтверждения);
		КонецЕсли;
		
		Возврат РезультатОтправки;
	#КонецЕсли
	
КонецФункции

Функция ПолучитьВходящиеСообщения(ТранспортныйМодуль, ПараметрыВыполненияОбмена = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ПолучитьВходящиеСообщения", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыВыполненияОбмена));
	#Иначе
		Результат = ОбработатьОчередьПолученияКвитанций(ТранспортныйМодуль, ПараметрыВыполненияОбмена);
		Если Результат.Статус = "Ошибка" И Результат.ТребуетсяАвторизация Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат = ЗагрузитьВходящиеСообщения(ТранспортныйМодуль, "ВХОДЯЩИЕ", ПараметрыВыполненияОбмена);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат = ЗагрузитьВходящиеСообщения(ТранспортныйМодуль, "ИСХОДЯЩИЕ", ПараметрыВыполненияОбмена);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
	#КонецЕсли
	
КонецФункции

Функция АвторизоватьсяЧерезПароль(ТранспортныйМодуль, Пароль) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "АвторизоватьсяЧерезПароль", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Пароль));
	#Иначе
		
		Результат = ТранспортМДЛПАПИКлиентСервер.ПолучитьКодАутентификации(ТранспортныйМодуль);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат =  ТранспортМДЛПАПИКлиентСервер.ПолучитьКлючСессии(ТранспортныйМодуль, Результат.КодАутентификации, Пароль);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ЗакрытьСессию(ТранспортныйМодуль) Экспорт
	
	Если Не ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ТранспортныйМодуль, "КлючСессии")) Тогда
		Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	КонецЕсли;
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "auth/logout";
	Возврат ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
	
КонецФункции

// Возвращает информацию о субъектах обращения соответствующих фильтру.
//
// Параметры:
//  ПараметрыПодключения - Структура - 
//  Отбор - Структура - 
//    ТипУчастника - Строка - Если не указан, то "1"
//             "1" - резидент,
//             "2" - представительство иностранного держателя регистрационного удостоверения,
//             "3" - иностранный держатель регистрационного удостоверения,
//             "8" - иностранный контрагент;
//    ИНН - Строка - ИНН участника;
//    ОГРН - Строка - ОГРН участника;
//    Идентификатор - Строка - регистрационный номер участника или идентификатор места деятельности.
//
Функция ПолучитьИнформациюОСубъектахОбращения(ПараметрыПодключения, Отбор) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОСубъектахОбращения", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Отбор));
	#Иначе
		
		ТаймаутМеждуЗапросами = 1000;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr_partners/filter";
		
		ТипУчастника = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Отбор, "ТипУчастника", "1");
		
		Фильтр = Новый Структура;
		Фильтр.Вставить("reg_entity_type", ТипУчастника);
		Если Отбор.Свойство("Идентификатор") Тогда
			Фильтр.Вставить("system_subj_id", Отбор.Идентификатор);
		ИначеЕсли Отбор.Свойство("ОГРН") Тогда
			Фильтр.Вставить("ogrn", Отбор.ОГРН);
		ИначеЕсли Отбор.Свойство("ИНН") Тогда
			Фильтр.Вставить("inn", Отбор.ИНН);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса,,, ТаймаутМеждуЗапросами);
		
		Если Результат.Статус <> "Ошибка" Тогда
			СубъектыОбращения = Новый Массив;
			Для Каждого Данные Из Результат.Список Цикл
				Если ТипУчастника = ТипУчастника_ИностранныйКонтрагент() Тогда
					
					ДанныеСубъекта = Новый Структура;
					ДанныеСубъекта.Вставить("РегистрационныйНомерУчастника", Данные["id"]);
					ДанныеСубъекта.Вставить("Наименование", ТранспортМДЛПКлиентСервер.ЗначениеПараметраОбъекта(Данные, "counterparty_name"));
					ДанныеСубъекта.Вставить("ИТИН", Данные["counterparty_itin"]);
					ДанныеСубъекта.Вставить("МестаДеятельности", Новый Массив);
					
					СубъектыОбращения.Добавить(ДанныеСубъекта);
					
				Иначе
					
					ДанныеСубъекта = Новый Структура;
					ДанныеСубъекта.Вставить("РегистрационныйНомерУчастника", Данные["system_subj_id"]);
					ДанныеСубъекта.Вставить("Наименование", ТранспортМДЛПКлиентСервер.ЗначениеПараметраОбъекта(Данные, "org_name"));
					ДанныеСубъекта.Вставить("ОГРН", Данные["ogrn"]);
					ДанныеСубъекта.Вставить("ИНН", Данные["inn"]);
					ДанныеСубъекта.Вставить("КПП", Данные["kpp"]);
					ДанныеСубъекта.Вставить("МестаДеятельности", Новый Массив);
					
					Если Данные["branches"] <> Неопределено Тогда
						Для Каждого МестоДеятельности Из Данные["branches"] Цикл
							Описание = АдресОбъекта(МестоДеятельности);
							Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.МестоОсуществленияДеятельности"));
							ДанныеСубъекта.МестаДеятельности.Добавить(Описание);
						КонецЦикла;
					Иначе
						РезультатПоМД = ПолучитьИнформациюОМестахДеятельности(ПараметрыПодключения, Новый Структура("РегистрационныйНомерУчастника", ДанныеСубъекта.РегистрационныйНомерУчастника));
						Если РезультатПоМД.Статус = "Ошибка" Тогда
							Возврат Результат;
						КонецЕсли;
						Для Каждого МестоДеятельности Из РезультатПоМД.Список Цикл
							Описание = Новый Структура("Идентификатор, Адрес");
							Описание = АдресОбъекта(МестоДеятельности);
							Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.МестоОсуществленияДеятельности"));
							ДанныеСубъекта.МестаДеятельности.Добавить(Описание);
						КонецЦикла;
					КонецЕсли;
					
					Если Данные["safe_warehouses"] <> Неопределено Тогда
						Для Каждого МестоДеятельности Из Данные["safe_warehouses"] Цикл
							Описание = АдресОбъекта(МестоДеятельности);
							Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.СкладОтветственногоХранения"));
							ДанныеСубъекта.МестаДеятельности.Добавить(Описание);
						КонецЦикла;
					Иначе
						РезультатПоМОХ = ПолучитьИнформациюОМестахОтветственногоХранения(ПараметрыПодключения, Новый Структура("РегистрационныйНомерУчастника", ДанныеСубъекта.РегистрационныйНомерУчастника));
						Если РезультатПоМОХ.Статус = "Ошибка" Тогда
							Возврат Результат;
						КонецЕсли;
						Для Каждого МестоДеятельности Из РезультатПоМОХ.Список Цикл
							Описание = Новый Структура("Идентификатор, Адрес");
							Описание = АдресОбъекта(МестоДеятельности);
							Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.СкладОтветственногоХранения"));
							ДанныеСубъекта.МестаДеятельности.Добавить(Описание);
						КонецЦикла;
					КонецЕсли;
					
					СубъектыОбращения.Добавить(ДанныеСубъекта);
					
				КонецЕсли;
			КонецЦикла;
			Результат.Вставить("СубъектыОбращения", СубъектыОбращения);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Возвращает информацию о местах деятельности.
//
// Параметры:
//  ПараметрыПодключения - Структура - 
//  Отбор - Структура - 
//    РегистрационныйНомерУчастника - Строка - регистрационный номер участника.
//    ИНН - Строка - ИНН участника;
//    Идентификатор - Строка - идентификатор места деятельности.
//    Статус - Строка - статус места действия
//       "0" - не действует,
//       "1" - действует,
//       "2" - в процессе приостановления.
//
Функция ПолучитьИнформациюОМестахДеятельности(ПараметрыПодключения, Отбор) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОМестахДеятельности", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Отбор));
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/branches/public/filter";
		
		Фильтр = Новый Структура;
		Если Отбор.Свойство("РегистрационныйНомерУчастника") Тогда
			Фильтр.Вставить("system_subj_id", Отбор.РегистрационныйНомерУчастника);
		ИначеЕсли Отбор.Свойство("ИНН") Тогда
			Фильтр.Вставить("inn", Отбор.ИНН);
		КонецЕсли;
		Если Отбор.Свойство("Идентификатор") Тогда
			Фильтр.Вставить("branch_id", Отбор.Идентификатор);
		КонецЕсли;
		Если Отбор.Свойство("Статус") Тогда
			Фильтр.Вставить("status", Отбор.Статус);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Возвращает информацию о местах ответственного хранения.
//
// Параметры:
//  ПараметрыПодключения - Структура - 
//  Отбор - Структура - 
//    РегистрационныйНомерУчастника - Строка - регистрационный номер участника.
//    ИНН - Строка - ИНН участника;
//    Идентификатор - Строка - идентификатор места ответственного хранения.
//    Статус - Строка - статус места действия
//       "0" - не действует,
//       "1" - действует,
//       "2" - в процессе приостановления.
//
Функция ПолучитьИнформациюОМестахОтветственногоХранения(ПараметрыПодключения, Отбор) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОМестахОтветственногоХранения", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Отбор));
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/warehouses/public/filter";
		
		Фильтр = Новый Структура;
		Если Отбор.Свойство("РегистрационныйНомерУчастника") Тогда
			Фильтр.Вставить("system_subj_id", Отбор.РегистрационныйНомерУчастника);
		ИначеЕсли Отбор.Свойство("ИНН") Тогда
			Фильтр.Вставить("inn", Отбор.ИНН);
		КонецЕсли;
		Если Отбор.Свойство("Идентификатор") Тогда
			Фильтр.Вставить("branch_id", Отбор.Идентификатор);
		КонецЕсли;
		Если Отбор.Свойство("Статус") Тогда
			Фильтр.Вставить("status", Отбор.Статус);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьДанныеРеестраМестТаможенногоКонтроля(ПараметрыПодключения, Отбор) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьДанныеРеестраМестТаможенногоКонтроля", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Отбор));
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/customs_points/filter";
		
		Фильтр = Новый Структура;
		Если Отбор.Свойство("Идентификатор") Тогда
			Фильтр.Вставить("id", Отбор.Идентификатор);
		ИначеЕсли Отбор.Свойство("ИНН") Тогда
			Фильтр.Вставить("inn", Отбор.ИНН);
		ИначеЕсли Отбор.Свойство("КодТаможенногоОргана") Тогда
			Фильтр.Вставить("customCode", Отбор.КодТаможенногоОргана);
		ИначеЕсли Отбор.Свойство("НомерСвидетельства") Тогда
			Фильтр.Вставить("regNum", Отбор.НомерСвидетельства);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса);
		
		Если Результат.Статус <> "Ошибка" Тогда
			СписокЗТК = Новый Массив;
			Для Каждого Данные Из Результат.Список Цикл
				ДанныеСубъекта = Новый Структура;
				ДанныеСубъекта.Вставить("РегистрационныйНомерУчастника"                , Данные["id"]);
				ДанныеСубъекта.Вставить("ИНН"                                          , Данные["inn"]);
				ДанныеСубъекта.Вставить("Наименование"                                 , Данные["orgName"]);
				ДанныеСубъекта.Вставить("НомерСвидетельства"                           , Данные["regNum"]);
				ДанныеСубъекта.Вставить("НаименованиеТаможенногоОргана"                , Данные["customName"]);
				ДанныеСубъекта.Вставить("КодТаможенногоОргана"                         , Данные["customCode"]);
				ДанныеСубъекта.Вставить("Адрес"                                        , Данные["warehouseAddress"]);
				ДанныеСубъекта.Вставить("НаличиеЛицензииНаФармацевтическуюДеятельность", Данные["hasPharmLicense"]);
				
				ТипСклада = СтрШаблон("Перечисление.ТипыСкладовЗонТаможенногоКонтроляМДЛП.%1", Данные["warehouseType"]);
				ДанныеСубъекта.Вставить("ТипСклада"                         , ПредопределенноеЗначение(ТипСклада));
				
				СписокЗТК.Добавить(ДанныеСубъекта);
			КонецЦикла;
			Результат.Вставить("СписокЗТК", СписокЗТК);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьИнформациюОбУчастнике(ПараметрыПодключения) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОбУчастнике");
	#Иначе
		
		ДанныеОрганизации = Новый Структура;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "members/current";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			ТаймаутМеждуЗапросами = 500;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Данные = Результат.Данные["member"];
		ДанныеОрганизации.Вставить("РегистрационныйНомерУчастника", Данные["sys_id"]);
		ДанныеОрганизации.Вставить("СобственнаяОрганизация", Истина);
		ДанныеОрганизации.Вставить("Наименование", ТранспортМДЛПКлиентСервер.ЗначениеПараметраОбъекта(Данные, "org_name"));
		ДанныеОрганизации.Вставить("ОГРН", Данные["ogrn"]);
		ДанныеОрганизации.Вставить("ИНН", Данные["inn"]);
		ДанныеОрганизации.Вставить("КПП", Данные["kpp"]);
		ДанныеОрганизации.Вставить("Резидент", Данные["is_resident"]);
		ДанныеОрганизации.Вставить("МестаДеятельности", Новый Массив);
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/address/all";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			ТаймаутМеждуЗапросами = 500;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Если Не Результат.НедостаточноПрав Тогда
				Возврат Результат;
			КонецЕсли;
		Иначе
			
			МестаДеятельности = Результат.Данные["entries"];
			Для Каждого МестоДеятельности Из МестаДеятельности Цикл
				Описание = АдресОбъекта(МестоДеятельности);
				Если МестоДеятельности["entity_type"] = 0 Тогда
					Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.МестоОсуществленияДеятельности"));
				Иначе
					Описание.Вставить("ТипМестаДеятельности", ПредопределенноеЗначение("Перечисление.ТипыМестДеятельностиМДЛП.СкладОтветственногоХранения"));
				КонецЕсли;
				ДанныеОрганизации.МестаДеятельности.Добавить(Описание);
			КонецЦикла;
			
			Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			Результат.Вставить("ДанныеОрганизации", ДанныеОрганизации);
			Возврат Результат;
			
		КонецЕсли;
		
		Результат = ПолучитьИнформациюОСубъектахОбращения(ПараметрыПодключения, Новый Структура("Идентификатор", ДанныеОрганизации.РегистрационныйНомерУчастника));
		Если Результат.Статус = "Ошибка" Тогда
			Если Не Результат.НедостаточноПрав Тогда
				Возврат Результат;
			КонецЕсли;
		ИначеЕсли Результат.СубъектыОбращения.Количество() > 0 Тогда
			
			ДанныеОрганизации.МестаДеятельности = Результат.СубъектыОбращения[0].МестаДеятельности;
			
			Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			Результат.Вставить("ДанныеОрганизации", ДанныеОрганизации);
			Возврат Результат;
			
		КонецЕсли;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("ДанныеОрганизации", ДанныеОрганизации);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьДанныеРеестраЕСКЛП(ПараметрыПодключения, Отбор = Неопределено, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(НачальныйИндекс);
		ПараметрыМетода.Добавить(МаксимальноеКоличествоДокументов);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьДанныеРеестраЕСКЛП", ПараметрыМетода);
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/esklp/filter";
		
		Фильтр = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, МаксимальноеКоличествоДокументов);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьСписокРегистраторовВыбытия(ПараметрыПодключения, ИдентификаторМестаДеятельности = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторМестаДеятельности);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокРегистраторовВыбытия", ПараметрыМетода);
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/registration-devices/withdrawal/filter";
		
		Фильтр = Новый Структура;
		Если ИдентификаторМестаДеятельности <> Неопределено Тогда
			Фильтр.Вставить("branch_id", ИдентификаторМестаДеятельности);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьСписокКИЗОжидающихВыводаИзОборотаПоЧекуККТ(ПараметрыПодключения, ИдентификаторМестаДеятельности = Неопределено, Отбор = Неопределено, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторМестаДеятельности);
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(НачальныйИндекс);
		ПараметрыМетода.Добавить(МаксимальноеКоличествоДокументов);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокКИЗОжидающихВыводаИзОборотаПоЧекуККТ", ПараметрыМетода);
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/kkt/awaiting-withdrawal/filter";
		
		ВремяОжидания = 1000;
		
		Фильтр = Новый Структура;
		Если ИдентификаторМестаДеятельности <> Неопределено Тогда
			Фильтр.Вставить("branch_id", ИдентификаторМестаДеятельности);
		КонецЕсли;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, МаксимальноеКоличествоДокументов, ВремяОжидания);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьРешенияОПриостановкеКИЗ(ПараметрыПодключения, Отбор = Неопределено, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(НачальныйИндекс);
		ПараметрыМетода.Добавить(МаксимальноеКоличествоДокументов);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьРешенияОПриостановкеКИЗ", ПараметрыМетода);
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/paused-circulation-decisions/filter";
		
		ВремяОжидания = 1000;
		
		Фильтр = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, МаксимальноеКоличествоДокументов, ВремяОжидания);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса) Экспорт
	
	Если Не ТранспортныйМодуль.Свойство("КлючСессии") Или Не ЗначениеЗаполнено(ТранспортныйМодуль.КлючСессии) Тогда
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = НСтр("ru = 'Ошибка при выполнении операции: требуется авторизация'");
		Результат.ТребуетсяАвторизация = Истина;
		Возврат Результат;
	КонецЕсли;
	
	ДанныеЗапроса.Заголовки.Вставить("Authorization", СтрШаблон("token %1", ТранспортныйМодуль.КлючСессии));
	
	Возврат ВыполнитьЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
	
КонецФункции

Функция ВыполнитьЗапрос(ТранспортныйМодуль, ДанныеЗапроса) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ТранспортныйМодуль, "ВыполнитьЗапрос", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ДанныеЗапроса));
	#Иначе
		
		Таймаут(500); // таймаут на все запросы к МДЛП
		
		ТипДанныхЗапроса = ТипЗнч(ДанныеЗапроса.ТелоЗапроса);
		Если ТипДанныхЗапроса <> Тип("Строка") И ТипДанныхЗапроса <> Тип("ДвоичныеДанные") Тогда
			ДанныеЗапроса.ТелоЗапроса = ТранспортМДЛПКлиентСервер.ПреобразоватьЗначениеВJSON(ДанныеЗапроса.ТелоЗапроса);
		КонецЕсли;
		
		Результат = ТранспортМДЛПКлиентСервер.ВыполнитьHTTPЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
		
		Если Результат.Статус <> "Ошибка" Тогда
			Если ДанныеЗапроса.ПолучитьОтветКакДвоичныеДанные И Результат.Свойство("ОтветТранспортногоМодуляДвоичныеДанные") Тогда
				Результат.Вставить("Данные", Результат.ОтветТранспортногоМодуляДвоичныеДанные);
			ИначеЕсли Не СтрНачинаетсяС(СокрЛП(Результат.ОтветТранспортногоМодуля), "<") Тогда
				Попытка
					Результат.Вставить("Данные", ТранспортМДЛПКлиентСервер.ПреобразоватьJSONВЗначение(Результат.ОтветТранспортногоМодуля));
				Исключение
					// вернем как есть, если должен был быть корректный JSON то ошибка возникнет там.
				КонецПопытки;
			КонецЕсли;
		ИначеЕсли Результат.Свойство("ОтветТранспортногоМодуля") И Не СтрНачинаетсяС(СокрЛП(Результат.ОтветТранспортногоМодуля), "<") Тогда
			// В ответе могут быть записаны детальные данные об ошибке.
			Попытка
				Результат.Вставить("Данные", ТранспортМДЛПКлиентСервер.ПреобразоватьJSONВЗначение(Результат.ОтветТранспортногоМодуля));
			Исключение
				// вернем как есть, если должен был быть корректный JSON то ошибка возникнет там.
			КонецПопытки;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Получает список объектов
//
Функция ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено, ТаймаутМеждуЗапросами = 500) Экспорт
	
	#Если ВебКлиент Тогда
		Параметры = Новый Массив;
		Параметры.Добавить(ДанныеЗапроса);
		Параметры.Добавить(ТелоЗапроса);
		Параметры.Добавить(НачальныйИндекс);
		Параметры.Добавить(МаксимальноеКоличествоДокументов);
		Параметры.Добавить(ТаймаутМеждуЗапросами);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокОбъектов", Параметры);
	#Иначе
	
		СписокДокументов = Новый Массив;
		ОбщееКоличество = 0;
		ИзвестныеПоляОбщееКоличество = Новый Массив;
		ИзвестныеПоляОбщееКоличество.Добавить("total");
		ИзвестныеПоляОбщееКоличество.Добавить("filtered_records_count");
		
		УстановленоОграничениеКоличестваПолучаемыхОбъектов = ЗначениеЗаполнено(МаксимальноеКоличествоДокументов);
		
		РазмерПорции = 100;
		Если УстановленоОграничениеКоличестваПолучаемыхОбъектов Тогда
			РазмерПорции = Мин(РазмерПорции, МаксимальноеКоличествоДокументов);
		КонецЕсли;
		
		ДополнительныеПоля = Новый Соответствие;
		
		Пока Истина Цикл
			
			ТелоЗапроса.Вставить("start_from", НачальныйИндекс);
			ТелоЗапроса.Вставить("count"     , РазмерПорции);
			ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
			
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если Результат.Статус = "Ошибка" Тогда
				Прервать;
			КонецЕсли;
			
			Данные = Результат.Данные;
			
			Объекты = Новый Массив;
			НайденоПолеОбщееКоличество = Ложь;
			Для Каждого КлючЗначение Из Данные Цикл
				Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив") Тогда
					Объекты = КлючЗначение.Значение;
				Иначе
					ДополнительныеПоля.Вставить(КлючЗначение.Ключ, КлючЗначение.Значение);
					Если ТипЗнч(КлючЗначение.Значение) = Тип("Число") Тогда
						Если Не НайденоПолеОбщееКоличество Тогда
							НайденоПолеОбщееКоличество = ИзвестныеПоляОбщееКоличество.Найти(КлючЗначение.Ключ) <> Неопределено;
							ОбщееКоличество = КлючЗначение.Значение;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			
			ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СписокДокументов, Объекты);
			
			ПолученоДокументов = Объекты.Количество();
			НачальныйИндекс = НачальныйИндекс + ПолученоДокументов;
			Если НачальныйИндекс >= ОбщееКоличество
			 Или УстановленоОграничениеКоличестваПолучаемыхОбъектов И СписокДокументов.Количество() >= МаксимальноеКоличествоДокументов Тогда
				Прервать;
			КонецЕсли;
			
			Если УстановленоОграничениеКоличестваПолучаемыхОбъектов Тогда
				РазмерПорции = Мин(РазмерПорции, МаксимальноеКоличествоДокументов - СписокДокументов.Количество());
			КонецЕсли;
			Таймаут(ТаймаутМеждуЗапросами);
		КонецЦикла;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		Результат.Вставить("Список", СписокДокументов);
		Результат.Вставить("Всего" , ОбщееКоличество);
		Результат.Вставить("ДополнительныеПоля", ДополнительныеПоля);
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#Область ПолучениеИнформацииОбУпаковках

// Параметры, для передачи в функцию ПолучитьИнформациюОПотребительскихИТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ПараметрыПолученияИнформацииОПотребительскихУпаковках - Структура - см. функцию ПараметрыПолученияИнформацииОПотребительскихУпаковках.
//   * ПараметрыПолученияИнформацииОТранспортныхУпаковках    - Структура - см. функцию ПараметрыПолученияИнформацииОТранспортныхУпаковках.
//
Функция ПараметрыПолученияИнформацииОПотребительскихИТранспортныхУпаковках() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ПараметрыПолученияИнформацииОПотребительскихУпаковках", ПараметрыПолученияИнформацииОПотребительскихУпаковках());
	Параметры.Вставить("ПараметрыПолученияИнформацииОТранспортныхУпаковках"   , ПараметрыПолученияИнформацииОТранспортныхУпаковках());
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию о потребительских и транспортных упаковках.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОПотребительскихИТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Структура:
//                * КИЗ - Соответствие - данные о потребительских упаковках.
//                * ТранспортныеУпаковки - Соответствие - данные о транспортных упаковках.
//
Функция ПолучитьИнформациюОПотребительскихИТранспортныхУпаковках(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОПотребительскихИТранспортныхУпаковках", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОПотребительскихИТранспортныхУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Структура);
		
		Результат.Данные.Вставить("КИЗ", Новый Соответствие);
		Результат.Данные.Вставить("ТранспортныеУпаковки", Новый Соответствие);
		
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ПараметрыПолученияИнформацииОПотребительскихУпаковках) Тогда
			РезультатКИЗ = ПолучитьИнформациюОПотребительскихУпаковках(ПараметрыПодключения, РабочиеПараметрыМетода.ПараметрыПолученияИнформацииОПотребительскихУпаковках);
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные.КИЗ, РезультатКИЗ.Данные, Истина);
			Если РезультатКИЗ.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатКИЗ));
				Возврат Результат;
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ПараметрыПолученияИнформацииОТранспортныхУпаковках) Тогда
			РезультатТранспортныеУпаковки = ПолучитьИнформациюОТранспортныхУпаковках(ПараметрыПодключения, РабочиеПараметрыМетода.ПараметрыПолученияИнформацииОТранспортныхУпаковках);
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные.ТранспортныеУпаковки, РезультатТранспортныеУпаковки.Данные, Истина);
			Если РезультатТранспортныеУпаковки.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатТранспортныеУпаковки));
				Возврат Результат;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьИнформациюОПотребительскихУпаковках.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * НомераУпаковок                           - Массив - номера упаковок, по которым необходимо получить информацию.
//   * ТипИсточникаИнформацииОбУпаковках        - ПеречислениеСсылка.ТипыИсточниковИнформацииОбУпаковкахМДЛП - (по умолчанию Приватный) - Приватный или Публичный.
//   * ТипЗапросаМетодовАПИ                     - ПеречислениеСсылка.ТипыЗапросовМетодовАПИМДЛП - (по умолчанию значение из константы ТипЗапросаМетодовАПИПоУмолчаниюМДЛП)
//                                                Асинхронный - методы будут выполняться с использованием механизма асинхронных задач
//                                                              (см. в документации к методам АПИ, на соответствующих ресурсах ИС "Маркировка.МДЛП").
//                                                Синхронный - методы будут выполняться стандартно.
//   * ВладелецАсинхроннойЗадачи                - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * ПолучатьВерхнеуровневыеУпаковки          - Булево - признак необходимости получения информации о транспортной упаковке самого верхнего уровня (например, паллеты),
//                                                         в которой находится потребительская упаковка.
//
Функция ПараметрыПолученияИнформацииОПотребительскихУпаковках(ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("НомераУпаковок"                   , Новый Массив);
	Параметры.Вставить("ТипИсточникаИнформацииОбУпаковках", ПредопределенноеЗначение("Перечисление.ТипыИсточниковИнформацииОбУпаковкахМДЛП.Приватный"));
	
	Параметры.Вставить("ТипЗапросаМетодовАПИ"             , ТранспортМДЛПАПИВызовСервера.ТипЗапросаМетодовАПИПоУмолчанию());
	Параметры.Вставить("ВладелецАсинхроннойЗадачи"        , ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("ПолучатьВерхнеуровневыеУпаковки"  , Ложь);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию о потребительских упаковках.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОПотребительскихУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о потребительских упаковках.
//
Функция ПолучитьИнформациюОПотребительскихУпаковках(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	Если ПараметрыМетода.ТипЗапросаМетодовАПИ = ПредопределенноеЗначение("Перечисление.ТипыЗапросовМетодовАПИМДЛП.Асинхронный")
	   И ПараметрыМетода.ТипИсточникаИнформацииОбУпаковках = ПредопределенноеЗначение("Перечисление.ТипыИсточниковИнформацииОбУпаковкахМДЛП.Публичный") Тогда
		Возврат ПолучитьИнформациюОПотребительскихУпаковкахАсинхронно(ПараметрыПодключения, ПараметрыМетода);
	Иначе
		Возврат ПолучитьИнформациюОПотребительскихУпаковкахСинхронно(ПараметрыПодключения, ПараметрыМетода);
	КонецЕсли;
	
КонецФункции

// Получает информацию о потребительских упаковках асинхронно.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОПотребительскихУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о потребительских упаковках.
//
Функция ПолучитьИнформациюОПотребительскихУпаковкахАсинхронно(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОПотребительскихУпаковкахАсинхронно", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаОбщедоступнойИнформацииПоSGTIN");
		
		// Инициализация параметров получения информации об упаковках.
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОПотребительскихУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		НомераУпаковок                  = РабочиеПараметрыМетода.НомераУпаковок;
		ВладелецАсинхроннойЗадачи       = РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи;
		ПолучатьВерхнеуровневыеУпаковки = РабочиеПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки;
		
		РазмерПорции = 100; // Количество запрашиваемых номеров упаковок в одной задаче не может превышать 100.
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		УникальныеНомераУпаковок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НомераУпаковок);
		Пока УникальныеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = ПолучитьПорциюДанных(УникальныеНомераУпаковок, РазмерПорции);
			
			// Регистрация задачи получения информации об упаковках.
			РезультатПорции = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, ВладелецАсинхроннойЗадачи, Новый Структура("sgtins", ПорцияНомеровУпаковок));
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			ИдентификаторЗадачи = РезультатПорции.Данные["id"];
			
			// Получение результата задачи с проверками результата и выполнением соответствующих действий.
			РезультатПорции = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			// Формирование порции результата по потребительским упаковкам.
			ДанныеПорцииУпаковок = Новый Соответствие;
			
			Для Каждого НомерУпаковки Из ПорцияНомеровУпаковок Цикл
				// По умолчанию считаем, что данные об упаковках не найдены.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				ДанныеПорцииУпаковок.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
			
			НайденныеКИЗ = РезультатПорции.Данные["entries"];
			Если ЗначениеЗаполнено(НайденныеКИЗ) Тогда
				Для Каждого НайденныйКИЗ Из НайденныеКИЗ Цикл
					
					КлючДанных = НайденныйКИЗ["sgtin"];
					
					// Унификация полей методов.
					НайденныйКИЗ.Вставить("sys_id"  , НайденныйКИЗ["branch_id"]);
					НайденныйКИЗ.Вставить("pack3_id", НайденныйКИЗ["sscc"]);
					Если НайденныйКИЗ["prod_d_name"] = Неопределено Тогда
						НайденныйКИЗ.Вставить("prod_d_name", НайденныйКИЗ["prod_dname"]);
					КонецЕсли;
					
					ДанныеПорцииУпаковок.Вставить(КлючДанных, НайденныйКИЗ);
					
				КонецЦикла;
			КонецЕсли;
			
			Если ПолучатьВерхнеуровневыеУпаковки Тогда
				
				ПараметрыМетода = ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках();
				ПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки = Истина;
				
				Для Каждого КлючИЗначение Из ДанныеПорцииУпаковок Цикл
					НомерТранспортнойУпаковки = КлючИЗначение.Значение["sscc"];
					Если ЗначениеЗаполнено(НомерТранспортнойУпаковки) Тогда
						ПараметрыМетода.НомераУпаковок.Добавить(НомерТранспортнойУпаковки);
					КонецЕсли;
				КонецЦикла;
				
				Если ПараметрыМетода.НомераУпаковок.Количество() > 0 Тогда
					
					РезультатПолученияТранспортныхУпаковок = ПолучитьИнформациюОСуществующихТранспортныхУпаковках(ПараметрыПодключения, ПараметрыМетода);
					Если РезультатПолученияТранспортныхУпаковок.Статус = "Ошибка" Тогда
						ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПолученияТранспортныхУпаковок));
						Возврат Результат;
					КонецЕсли;
					
					Для Каждого КлючИЗначение Из ДанныеПорцииУпаковок Цикл
						НомерТранспортнойУпаковки = КлючИЗначение.Значение["sscc"];
						НомерНовойВерхнеуровневойТранспортнойУпаковки = НомерТранспортнойУпаковки;
						НомерВерхнеуровневойТранспортнойУпаковки = НомерНовойВерхнеуровневойТранспортнойУпаковки;
						Пока ЗначениеЗаполнено(НомерНовойВерхнеуровневойТранспортнойУпаковки) Цикл
							НомерВерхнеуровневойТранспортнойУпаковки = НомерНовойВерхнеуровневойТранспортнойУпаковки;
							ДанныеТранспортнойУпаковки = РезультатПолученияТранспортныхУпаковок.Данные[НомерНовойВерхнеуровневойТранспортнойУпаковки];
							НомерНовойВерхнеуровневойТранспортнойУпаковки = ДанныеТранспортнойУпаковки["parent_sscc"];
						КонецЦикла;
						КлючИЗначение.Значение.Вставить("parent_sscc", НомерВерхнеуровневойТранспортнойУпаковки);
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЕсли;
			
			// Данные каждой упаковки результирующей коллекции заменяются данными упаковки порции.
			// Деление на порции необходимо для того, чтоб в результирующей коллекции по каждой порции были полные данные.
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные, ДанныеПорцииУпаковок, Истина);
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Получает информацию о потребительских упаковках синхронно.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОПотребительскихУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о потребительских упаковках.
//
Функция ПолучитьИнформациюОПотребительскихУпаковкахСинхронно(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОПотребительскихУпаковкахСинхронно", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		// Инициализация параметров получения информации об упаковках.
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОПотребительскихУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		НомераУпаковок                  = РабочиеПараметрыМетода.НомераУпаковок;
		ПолучатьПубличнуюИнформациюОКИЗ = РабочиеПараметрыМетода.ТипИсточникаИнформацииОбУпаковках = ПредопределенноеЗначение("Перечисление.ТипыИсточниковИнформацииОбУпаковкахМДЛП.Публичный");
		ПолучатьВерхнеуровневыеУпаковки = РабочиеПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки;
		
		РазмерПорции = 500; // Количество запрашиваемых номеров упаковок не может превышать 500.
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		УникальныеНомераУпаковок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НомераУпаковок);
		Пока УникальныеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = ПолучитьПорциюДанных(УникальныеНомераУпаковок, РазмерПорции);
			
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
			
			Если ПолучатьПубличнуюИнформациюОКИЗ Тогда
				ТаймаутМеждуЗапросами = 5000;
				ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/public/sgtins-by-list";
			Иначе
				ТаймаутМеждуЗапросами = 10000;
				ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/sgtins-by-list";
			КонецЕсли;
			
			ТелоЗапроса = Новый Структура;
			ТелоЗапроса.Вставить("filter", Новый Структура("sgtins", ПорцияНомеровУпаковок));
			ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
			
			РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если РезультатПорции.Статус = "Ошибка" И РезультатПорции.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатПорции, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			Для Каждого НомерУпаковки Из ПорцияНомеровУпаковок Цикл
				// По умолчанию считаем, что данные об упаковках не найдены.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("sgtin"     , НомерУпаковки);
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				Результат.Данные.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
			
			НайденныеКИЗ = РезультатПорции.Данные["entries"];
			Если ЗначениеЗаполнено(НайденныеКИЗ) Тогда
				Для Каждого НайденныйКИЗ Из НайденныеКИЗ Цикл
					
					Если ПолучатьПубличнуюИнформациюОКИЗ Тогда
						
						// Унификация полей методов.
						НайденныйКИЗ.Вставить("sys_id"    , НайденныйКИЗ["branch_id"]);
						НайденныйКИЗ.Вставить("prod_dname", НайденныйКИЗ["prod_d_name"]);
						НайденныйКИЗ.Вставить("pack3_id"  , НайденныйКИЗ["sscc"]);
						Если Не ЗначениеЗаполнено(НайденныйКИЗ["gtin"]) Тогда
							НайденныйКИЗ["gtin"] = Лев(НайденныйКИЗ["sgtin"], 14);
						КонецЕсли;
						
					Иначе
						
						// Унификация полей методов.
						НайденныйКИЗ.Вставить("branch_id" , НайденныйКИЗ["sys_id"]);
						НайденныйКИЗ.Вставить("prod_dname", НайденныйКИЗ["prod_d_name"]);
						НайденныйКИЗ.Вставить("sscc"      , НайденныйКИЗ["pack3_id"]);
						
					КонецЕсли;
					
					Результат.Данные.Вставить(НайденныйКИЗ["sgtin"], НайденныйКИЗ);
					
				КонецЦикла;
			КонецЕсли;
			
			ОшибочныеКИЗ = РезультатПорции.Данные["failed_entries"];
			Если ЗначениеЗаполнено(ОшибочныеКИЗ) Тогда
				Для Каждого ОшибочныйКИЗ Из ОшибочныеКИЗ Цикл
					Если ПолучатьПубличнуюИнформациюОКИЗ Тогда
						ДанныеОшибочногоКИЗ = Новый Соответствие;
						ДанныеОшибочногоКИЗ.Вставить("sgtin"     , ОшибочныйКИЗ);
						ДанныеОшибочногоКИЗ.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
						ДанныеОшибочногоКИЗ.Вставить("error_code", 2);
						Результат.Данные.Вставить(ОшибочныйКИЗ, ДанныеОшибочногоКИЗ);
					Иначе
						Результат.Данные.Вставить(ОшибочныйКИЗ["sgtin"], ОшибочныйКИЗ);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			Если УникальныеНомераУпаковок.Количество() > 0 Тогда
				Таймаут(ТаймаутМеждуЗапросами);
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПолучатьВерхнеуровневыеУпаковки Тогда
			
			ПараметрыМетода = ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках();
			ПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки = Истина;
			
			Для Каждого КлючИЗначение Из Результат.Данные Цикл
				НомерТранспортнойУпаковки = КлючИЗначение.Значение["sscc"];
				Если ЗначениеЗаполнено(НомерТранспортнойУпаковки) Тогда
					ПараметрыМетода.НомераУпаковок.Добавить(НомерТранспортнойУпаковки);
				КонецЕсли;
			КонецЦикла;
			
			Если ПараметрыМетода.НомераУпаковок.Количество() > 0 Тогда
				
				РезультатПолученияТранспортныхУпаковок = ПолучитьИнформациюОСуществующихТранспортныхУпаковках(ПараметрыПодключения, ПараметрыМетода);
				Если РезультатПолученияТранспортныхУпаковок.Статус = "Ошибка" Тогда
					ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПолученияТранспортныхУпаковок));
					Возврат Результат;
				КонецЕсли;
				
				Для Каждого КлючИЗначение Из Результат.Данные Цикл
					НомерТранспортнойУпаковки = КлючИЗначение.Значение["sscc"];
					НомерНовойВерхнеуровневойТранспортнойУпаковки = НомерТранспортнойУпаковки;
					НомерВерхнеуровневойТранспортнойУпаковки = НомерНовойВерхнеуровневойТранспортнойУпаковки;
					Пока ЗначениеЗаполнено(НомерНовойВерхнеуровневойТранспортнойУпаковки) Цикл
						НомерВерхнеуровневойТранспортнойУпаковки = НомерНовойВерхнеуровневойТранспортнойУпаковки;
						ДанныеТранспортнойУпаковки = РезультатПолученияТранспортныхУпаковок.Данные[НомерНовойВерхнеуровневойТранспортнойУпаковки];
						НомерНовойВерхнеуровневойТранспортнойУпаковки = ДанныеТранспортнойУпаковки["parent_sscc"];
					КонецЦикла;
					КлючИЗначение.Значение.Вставить("parent_sscc", НомерВерхнеуровневойТранспортнойУпаковки);
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьСписокПотребительскихУпаковокПоОтбору.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * Отбор - Структура - отбор, по которому необходимо выполнить фильтрацию данных
//                         (более подробно см. в документации к методам АПИ, на соответствующих ресурсах ИС "Маркировка.МДЛП").
//   * НачальныйИндекс - Число - индекс, начиная с которого необходимо получить данные из списка.
//   * РазмерПорции - Число - количество получаемых элементов из списка.
//
Функция ПараметрыПолученияСпискаПотребительскихУпаковокПоОтбору() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("Отбор"          , Новый Структура);
	Параметры.Вставить("НачальныйИндекс", 0);
	Параметры.Вставить("РазмерПорции"   , Неопределено);
	
	Возврат Параметры;
	
КонецФункции

// Получает список потребительских упаковок по отбору.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияСпискаПотребительскихУпаковокПоОтбору.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о потребительских упаковках.
//
Функция ПолучитьСписокПотребительскихУпаковокПоОтбору(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокПотребительскихУпаковокПоОтбору", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		// Инициализация параметров получения информации об упаковках.
		РабочиеПараметрыМетода = ПараметрыПолученияСпискаПотребительскихУпаковокПоОтбору();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		Отбор           = РабочиеПараметрыМетода.Отбор;
		НачальныйИндекс = РабочиеПараметрыМетода.НачальныйИндекс;
		РазмерПорции    = РабочиеПараметрыМетода.РазмерПорции;
		
		ТаймаутМеждуЗапросами = 5000;
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/filter";
		
		Фильтр = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		РезультатСписок = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, РазмерПорции, ТаймаутМеждуЗапросами);
		Если РезультатСписок.Статус = "Ошибка" Тогда
			ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатСписок));
			Возврат Результат;
		КонецЕсли;
		
		Для Каждого Элемент Из РезультатСписок.Список Цикл
			Результат.Данные.Вставить(Элемент["sgtin"], Элемент);
		КонецЦикла;
		
		Результат.Вставить("Всего" , РезультатСписок.Всего);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьИнформациюОТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * НомераУпаковок                             - Массив - номера упаковок, по которым необходимо получить информацию.
//   * ПолучатьВерхнеуровневыеУпаковки            - Булево - (по умолчанию Ложь) - результат выполнения функции будет включать данные о верхнеуровневых упаковках.
//   * ПолучатьВложенныеУпаковки                  - Булево - (по умолчанию Истина) - результат выполнения функции будет включать данные о вложенных упаковках.
//   * ТипЗапросаМетодовАПИ                       - ПеречислениеСсылка.ТипыЗапросовМетодовАПИМДЛП - (по умолчанию значение из константы ТипЗапросаМетодовАПИПоУмолчаниюМДЛП)
//                                                  Асинхронный - методы будут выполняться с использованием механизма асинхронных задач
//                                                                (см. в документации к методам АПИ, на соответствующих ресурсах ИС "Маркировка.МДЛП").
//                                                  Синхронный - методы будут выполняться стандартно.
//   * ВладелецАсинхроннойЗадачи                  - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//                                                  При отмене выполнения длительной операции по получению данных, с использованием асинхронных задач,
//                                                  по владельцу определяются те задачи, которые необходимо завершить.
//   * ПолучатьРасширеннуюИнформациюОВложенныхКИЗ - Булево - (по умолчанию Ложь) признак необходимости получения расширенной информации о вложенных КИЗ.
//                                                  Расшренной считается информация полученная методами reestr/sgtin/sgtins-by-list или reestr/sgtin/public/sgtins-by-list.
//   * ТипИсточникаИнформацииОВложенныхКИЗ        - ПеречислениеСсылка.ТипыИсточниковИнформацииОбУпаковкахМДЛП - (по умолчанию Приватный) - Приватный или Публичный.
//                                                  Используется только если ПолучатьРасширеннуюИнформациюОВложенныхКИЗ = Истина.
//                                                  Приватный - данные будут получены методом reestr/sgtin/sgtins-by-list.
//                                                  Публичный - данные будут получены методом reestr/sgtin/public/sgtins-by-list.
//
Функция ПараметрыПолученияИнформацииОТранспортныхУпаковках(ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("НомераУпаковок"                            , Новый Массив);
	Параметры.Вставить("ПолучатьВерхнеуровневыеУпаковки"           , Ложь);
	Параметры.Вставить("ПолучатьВложенныеУпаковки"                 , Истина);
	
	Параметры.Вставить("ТипЗапросаМетодовАПИ"                      , ТранспортМДЛПАПИВызовСервера.ТипЗапросаМетодовАПИПоУмолчанию());
	Параметры.Вставить("ВладелецАсинхроннойЗадачи"                 , ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("ПолучатьРасширеннуюИнформациюОВложенныхКИЗ", Ложь);
	Параметры.Вставить("ТипИсточникаИнформацииОВложенныхКИЗ"       , ПредопределенноеЗначение("Перечисление.ТипыИсточниковИнформацииОбУпаковкахМДЛП.Приватный"));
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию о транспортных упаковках.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о транспортных упаковках.
//
Функция ПолучитьИнформациюОТранспортныхУпаковках(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	Если ПараметрыМетода.ТипЗапросаМетодовАПИ = ПредопределенноеЗначение("Перечисление.ТипыЗапросовМетодовАПИМДЛП.Асинхронный") Тогда
		Возврат ПолучитьИнформациюОТранспортныхУпаковкахАсинхронно(ПараметрыПодключения, ПараметрыМетода);
	Иначе
		Возврат ПолучитьИнформациюОТранспортныхУпаковкахСинхронно(ПараметрыПодключения, ПараметрыМетода);
	КонецЕсли;
	
КонецФункции

// Получает информацию о транспортных упаковках асинхронно.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о транспортных упаковках.
//
Функция ПолучитьИнформациюОТранспортныхУпаковкахАсинхронно(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОТранспортныхУпаковкахАсинхронно", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаИерархииУпаковок");
		
		// Инициализация параметров получения информации об упаковках.
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОТранспортныхУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		НомераУпаковок                             = РабочиеПараметрыМетода.НомераУпаковок;
		ВладелецАсинхроннойЗадачи                  = РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи;
		ПолучатьВерхнеуровневыеУпаковки            = РабочиеПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки;
		ПолучатьВложенныеУпаковки                  = РабочиеПараметрыМетода.ПолучатьВложенныеУпаковки;
		ПолучатьРасширеннуюИнформациюОВложенныхКИЗ = РабочиеПараметрыМетода.ПолучатьРасширеннуюИнформациюОВложенныхКИЗ;
		ТипИсточникаИнформацииОВложенныхКИЗ        = РабочиеПараметрыМетода.ТипИсточникаИнформацииОВложенныхКИЗ;
		
		РазмерПорции = 10; // Количество запрашиваемых номеров упаковок в одной задаче не может превышать 10.
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		УникальныеНомераУпаковок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НомераУпаковок);
		Пока УникальныеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = ПолучитьПорциюДанных(УникальныеНомераУпаковок, РазмерПорции);
			
			// Регистрация задачи получения информации об упаковках.
			РезультатПорции = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, ВладелецАсинхроннойЗадачи, Новый Структура("sscc", ПорцияНомеровУпаковок));
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			ИдентификаторЗадачи = РезультатПорции.Данные["id"];
			
			// Получение результата задачи с проверками результата и выполнением соответствующих действий.
			РезультатПорции = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			// Формирование порции результата по транспортным упаковкам.
			ДанныеПорцииУпаковок = Новый Соответствие;
			
			Для Каждого НомерУпаковки Из ПорцияНомеровУпаковок Цикл
				// По умолчанию считаем, что данные об упаковках не найдены.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				ДанныеПорцииУпаковок.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
			
			Данные = РезультатПорции.Данные["package"];
			Для Каждого Элемент Из Данные Цикл
				
				КлючДанных = Элемент["sscc"];
				ИсходныеДанныеУпаковки = Элемент["package_components"];
				
				ДанныеУпаковки = Новый Соответствие;
				Если ПолучатьВерхнеуровневыеУпаковки Тогда
					
					// Приводим полученный результат по верхнеуровневым упаковкам к общему виду.
					ДанныеВерхнеуровневыхУпаковок = Новый Соответствие;
					ИсходныеДанныеВерхнеуровневыхУпаковок = ИсходныеДанныеУпаковки["up"];
					ТекущиеДанные = ДанныеВерхнеуровневыхУпаковок;
					Пока ИсходныеДанныеВерхнеуровневыхУпаковок.Количество() > 0 Цикл
						Граница = ИсходныеДанныеВерхнеуровневыхУпаковок.ВГраница();
						ИсходныеДанныеВерхнеуровневойУпаковки = ИсходныеДанныеВерхнеуровневыхУпаковок[Граница];
						ИсходныеДанныеВерхнеуровневыхУпаковок.Удалить(Граница);
						ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ТекущиеДанные, ИсходныеДанныеВерхнеуровневойУпаковки, Истина);
						ТекущиеДанные.Вставить("childs", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Новый Соответствие));
						ТекущиеДанные = ТекущиеДанные["childs"][0];
					КонецЦикла;
					ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ТекущиеДанные, ИсходныеДанныеУпаковки["down"][0], Истина);
					ТекущиеДанные.Удалить("childs");
					
					ДанныеУпаковки.Вставить("up", ДанныеВерхнеуровневыхУпаковок);
					
				КонецЕсли;
				
				Если ПолучатьВложенныеУпаковки Тогда
					ДанныеУпаковки.Вставить("down", ИсходныеДанныеУпаковки["down"][0]);
				КонецЕсли;
				
				ДанныеПорцииУпаковок.Вставить(КлючДанных, ДанныеУпаковки);
				
			КонецЦикла;
			
			Если ПолучатьВложенныеУпаковки И ПолучатьРасширеннуюИнформациюОВложенныхКИЗ Тогда
				// Дополнение информации о вложенных потребительских упаковках.
				РезультатДополненияВложенныхКИЗ = ДополнитьДанныеВложенныхПотребительскихУпаковок(ПараметрыПодключения, ДанныеПорцииУпаковок, ТипИсточникаИнформацииОВложенныхКИЗ, ВладелецАсинхроннойЗадачи);
				Если РезультатДополненияВложенныхКИЗ.Статус = "Ошибка" Тогда
					ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатДополненияВложенныхКИЗ));
					Возврат Результат;
				КонецЕсли;
			КонецЕсли;
			
			// Данные каждой упаковки результирующей коллекции заменяются данными упаковки порции.
			// Деление на порции необходимо для того, чтоб в результирующей коллекции по каждой порции были полные данные.
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные, ДанныеПорцииУпаковок, Истина);
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Получает информацию о транспортных упаковках синхронно.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о транспортных упаковках.
//
Функция ПолучитьИнформациюОТранспортныхУпаковкахСинхронно(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОТранспортныхУпаковкахСинхронно", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОТранспортныхУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		НомераУпаковок                             = РабочиеПараметрыМетода.НомераУпаковок;
		ПолучатьВерхнеуровневыеУпаковки            = РабочиеПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки;
		ПолучатьВложенныеУпаковки                  = РабочиеПараметрыМетода.ПолучатьВложенныеУпаковки;
		ПолучатьРасширеннуюИнформациюОВложенныхКИЗ = РабочиеПараметрыМетода.ПолучатьРасширеннуюИнформациюОВложенныхКИЗ;
		ТипИсточникаИнформацииОВложенныхКИЗ        = РабочиеПараметрыМетода.ТипИсточникаИнформацииОВложенныхКИЗ;
		
		РазмерПорции = 10; // Количество запрашиваемых номеров упаковок не может превышать 10.
		ТаймаутМеждуЗапросами = 30000; // Вызов метода доступен не чаще чем раз в 30 секунд.
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		УникальныеНомераУпаковок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НомераУпаковок);
		Пока УникальныеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = ПолучитьПорциюДанных(УникальныеНомераУпаковок, РазмерПорции);
			
			ПараметрыЗапроса = "?sscc=" + СтрСоединить(ПорцияНомеровУпаковок, "&sscc=");
			
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/full-hierarchy" + ПараметрыЗапроса;
			
			РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если РезультатПорции.Статус = "Ошибка" И РезультатПорции.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатПорции, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			// Формирование порции результата по транспортным упаковкам.
			ДанныеПорцииУпаковок = Новый Соответствие;
			
			Для Каждого НомерУпаковки Из ПорцияНомеровУпаковок Цикл
				// По умолчанию считаем, что данные об упаковках не найдены.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				ДанныеПорцииУпаковок.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
			
			Данные = РезультатПорции.Данные;
			Для Каждого Элемент Из Данные Цикл
				
				КлючДанных = Элемент["down"]["sscc"];
				
				ДанныеУпаковки = Новый Соответствие;
				Если ПолучатьВерхнеуровневыеУпаковки Тогда
					ДанныеУпаковки.Вставить("up", Элемент["up"]);
				КонецЕсли;
				Если ПолучатьВложенныеУпаковки Тогда
					ДанныеУпаковки.Вставить("down", Элемент["down"]);
				КонецЕсли;
				ДанныеПорцииУпаковок.Вставить(КлючДанных, ДанныеУпаковки);
				
			КонецЦикла;
			
			Если ПолучатьВложенныеУпаковки И ПолучатьРасширеннуюИнформациюОВложенныхКИЗ Тогда
				// Дополнение информации о вложенных потребительских упаковках.
				РезультатДополненияВложенныхКИЗ = ДополнитьДанныеВложенныхПотребительскихУпаковок(ПараметрыПодключения, ДанныеПорцииУпаковок, ТипИсточникаИнформацииОВложенныхКИЗ);
				Если РезультатДополненияВложенныхКИЗ.Статус = "Ошибка" Тогда
					ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатДополненияВложенныхКИЗ));
					Возврат Результат;
				КонецЕсли;
			КонецЕсли;
			
			// Данные каждой упаковки результирующей коллекции заменяются данными упаковки порции.
			// Деление на порции необходимо для того, чтоб в результирующей коллекции по каждой порции были полные данные.
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные, ДанныеПорцииУпаковок, Истина);
			
			Если УникальныеНомераУпаковок.Количество() > 0 Тогда
				Таймаут(ТаймаутМеждуЗапросами);
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ДополнитьДанныеВложенныхПотребительскихУпаковок(ПараметрыПодключения, ДанныеРодительскихУпаковок, ТипИсточникаИнформацииОВложенныхКИЗ, ВладелецАсинхроннойЗадачи = Неопределено)
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	
	ОчередьВложенныхУпаковок      = Новый Массив;
	ДанныеПотребительскихУпаковок = Новый Массив;
	НомераПотребительскихУпаковок = Новый Массив;
	ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из ДанныеРодительскихУпаковок Цикл
		
		ДанныеУпаковки = КлючИЗначение.Значение;
		Состав = ДанныеУпаковки["down"];
		Если Не ЗначениеЗаполнено(Состав) Тогда
			Продолжить;
		КонецЕсли;
		
		ОчередьВложенныхУпаковок.Добавить(Состав);
		Пока ОчередьВложенныхУпаковок.Количество() > 0 Цикл
			
			ТекущиеДанныеУпаковки = ОчередьВложенныхУпаковок[0];
			ОчередьВложенныхУпаковок.Удалить(0);
			
			ВложенныеУпаковки = ТекущиеДанныеУпаковки["childs"];
			Если Не ЗначениеЗаполнено(ВложенныеУпаковки) Тогда
				Продолжить;
			КонецЕсли;
			
			Для Каждого ВложеннаяУпаковка Из ВложенныеУпаковки Цикл
				
				Если ВложеннаяУпаковка["childs"] <> Неопределено Тогда
					ОчередьВложенныхУпаковок.Добавить(ВложеннаяУпаковка);
				Иначе
					
					НомерПотребительскойУпаковки = ВложеннаяУпаковка["sgtin"];
					Если Не ЗначениеЗаполнено(НомерПотребительскойУпаковки) Тогда
						Продолжить;
					КонецЕсли;
					
					ДанныеПотребительскихУпаковок.Добавить(ВложеннаяУпаковка);
					НомераПотребительскихУпаковок.Добавить(НомерПотребительскойУпаковки);
					ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок.Вставить(НомерПотребительскойУпаковки, ДанныеУпаковки);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если НомераПотребительскихУпаковок.Количество() > 0 Тогда
		
		ПараметрыПолученияИнформацииОВложенныхКИЗ = ПараметрыПолученияИнформацииОПотребительскихУпаковках(ВладелецАсинхроннойЗадачи);
		ПараметрыПолученияИнформацииОВложенныхКИЗ.НомераУпаковок = НомераПотребительскихУпаковок;
		ПараметрыПолученияИнформацииОВложенныхКИЗ.ТипИсточникаИнформацииОбУпаковках = ТипИсточникаИнформацииОВложенныхКИЗ;
		
		РезультатПолученияПотребительскихУпаковок = ПолучитьИнформациюОПотребительскихУпаковках(ПараметрыПодключения, ПараметрыПолученияИнформацииОВложенныхКИЗ);
		Если РезультатПолученияПотребительскихУпаковок.Статус = "Ошибка" Тогда
			
			Если Не РезультатПолученияПотребительскихУпаковок.ТребуетсяАвторизация Тогда
				// Если есть ошибки в расширенных данных вложенных упаковок, запишем ошибку запрашиваемой транспортной упаковке.
				Для Каждого НомерПотребительскойУпаковки Из НомераПотребительскихУпаковок Цикл
					ДанныеУпаковки = ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок[НомерПотребительскойУпаковки];
					ДанныеУпаковки.Вставить("error_code", 2);
					ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые расширенные данные вложенных КИЗ не найдены'"));
				КонецЦикла;
			КонецЕсли;
			
			ЗаполнитьЗначенияСвойств(Результат, РезультатПолученияПотребительскихУпаковок);
			Возврат Результат;
			
		КонецЕсли;
		
		// После того, как получили полные данные потребительских упаковок, необходимо ими актуализировать иерархию, на соответствующих уровнях.
		// Т.к. в массиве ДанныеПотребительскихУпаковок находятся ссылки на элементы соответствия ДанныеРодительскихУпаковок,
		// изменения данных массива ДанныеПотребительскихУпаковок приведет к изменению соответствия ДанныеРодительскихУпаковок.
		Для Каждого ДанныеПотребительскойУпаковки Из ДанныеПотребительскихУпаковок Цикл
			
			НомерПотребительскойУпаковки = ДанныеПотребительскойУпаковки["sgtin"];
			
			// Дополним данные потребительской упаковки расширенными данными.
			РасширенныеДанныеПотребительскойУпаковки = РезультатПолученияПотребительскихУпаковок.Данные[НомерПотребительскойУпаковки];
			Если РасширенныеДанныеПотребительскойУпаковки = Неопределено Тогда
				РасширенныеДанныеПотребительскойУпаковки = Новый Соответствие;
				РасширенныеДанныеПотребительскойУпаковки.Вставить("sgtin"     , НомерПотребительскойУпаковки);
				РасширенныеДанныеПотребительскойУпаковки.Вставить("error_code", 2);
				РасширенныеДанныеПотребительскойУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые расширенные данные не найдены'"));
			КонецЕсли;
			
			Для Каждого КлючИЗначение Из РасширенныеДанныеПотребительскойУпаковки Цикл
				ДанныеПотребительскойУпаковки.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
			КонецЦикла;
			
			// Если есть ошибки в расширенных данных вложенных упаковок, запишем ошибку запрашиваемой транспортной упаковке.
			Если ДанныеПотребительскойУпаковки["error_code"] <> Неопределено Тогда
				ДанныеУпаковки = ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок[НомерПотребительскойУпаковки];
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые расширенные данные вложенных КИЗ не найдены'"));
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьИнформациюОСуществующихТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * НомераУпаковок - Массив - номера упаковок, по которым необходимо получить информацию.
//   * ПолучатьВерхнеуровневыеУпаковки - Булево - признак необходимости получения информации о транспортных упаковках верхних уровней.
//
Функция ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("НомераУпаковок", Новый Массив);
	Параметры.Вставить("ПолучатьВерхнеуровневыеУпаковки", Ложь);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию о существующих транспортных упаковках.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об упаковках.
//              Данные об упаковках хранятся в поле Данные - Соответствие - данные о транспортных упаковках.
//
Функция ПолучитьИнформациюОСуществующихТранспортныхУпаковках(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОСуществующихТранспортныхУпаковках", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		РабочиеПараметрыМетода = ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		НомераУпаковок = РабочиеПараметрыМетода.НомераУпаковок;
		ПолучатьВерхнеуровневыеУпаковки = РабочиеПараметрыМетода.ПолучатьВерхнеуровневыеУпаковки;
		
		РазмерПорции = 35; // Количество запрашиваемых номеров упаковок не может превышать 35.
		ТаймаутМеждуЗапросами = 500; // Вызов метода доступен не чаще чем раз в 0.5 секунды.
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		Если ПолучатьВерхнеуровневыеУпаковки Тогда
			ВерхнеуровневыеУпаковкиКОбработке = Новый Соответствие;
		КонецЕсли;
		
		УникальныеНомераУпаковок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(НомераУпаковок);
		Пока УникальныеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = ПолучитьПорциюДанных(УникальныеНомераУпаковок, РазмерПорции);
			
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/sscc_check";
			
			ТелоЗапроса = Новый Структура;
			ТелоЗапроса.Вставить("sscc", ПорцияНомеровУпаковок);
			ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
			
			РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если РезультатПорции.Статус = "Ошибка" И РезультатПорции.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатПорции, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			// Формирование порции результата по транспортным упаковкам.
			ДанныеПорцииУпаковок = Новый Соответствие;
			
			Для Каждого НомерУпаковки Из ПорцияНомеровУпаковок Цикл
				// По умолчанию считаем, что данные об упаковках не найдены.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("error_code", 2);
				ДанныеУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				ДанныеПорцииУпаковок.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
			
			Данные = РезультатПорции.Данные["entries"];
			Для Каждого Элемент Из Данные Цикл
				
				КлючДанных = Элемент["sscc"];
				ДанныеПорцииУпаковок.Вставить(КлючДанных, Элемент);
				
				Если ПолучатьВерхнеуровневыеУпаковки Тогда
					ВерхнеуровневаяУпаковка = Элемент["parent_sscc"];
					Если ЗначениеЗаполнено(ВерхнеуровневаяУпаковка) Тогда
						ВерхнеуровневыеУпаковкиКОбработке.Вставить(ВерхнеуровневаяУпаковка);
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			ДанныеСОшибками = РезультатПорции.Данные["failed_entries"];
			Для Каждого Элемент Из ДанныеСОшибками Цикл
				
				КлючДанных = Элемент["sscc"];
				ДанныеПорцииУпаковок.Вставить(КлючДанных, Элемент);
				
			КонецЦикла;
			
			// Данные каждой упаковки результирующей коллекции заменяются данными упаковки порции.
			// Деление на порции необходимо для того, чтоб в результирующей коллекции по каждой порции были полные данные.
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Результат.Данные, ДанныеПорцииУпаковок, Истина);
			
			Если ПолучатьВерхнеуровневыеУпаковки Тогда
				Если ВерхнеуровневыеУпаковкиКОбработке.Количество() > 0 И УникальныеНомераУпаковок.Количество() = 0 Тогда
					Для Каждого КлючИЗначение Из ВерхнеуровневыеУпаковкиКОбработке Цикл
						Если Результат.Данные[КлючИЗначение.Ключ] = Неопределено Тогда
							// Добавляем в коллекцию УникальныеНомераУпаковок только те уникальные упаковки, которые еще не обрабатывались.
							УникальныеНомераУпаковок.Добавить(КлючИЗначение.Ключ);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			
			Если УникальныеНомераУпаковок.Количество() > 0 Тогда
				Таймаут(ТаймаутМеждуЗапросами);
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область ПолучениеИнформацииИзРеестраРешенийОВводеЛПвГражданскийОборот

// Параметры, для передачи в функцию ПолучитьРешенияОВводеЛПВГражданскийОборотПоСпискуЛП.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * СписокФильтров - Массив - массив структур, свойства которых должны включать:
//       ** gtin       - Строка - gtin.
//       ** НомерСерии - Строка - номер серии.
//
Функция ПараметрыПолученияРешенийОВводеЛПВГражданскийОборотПоСпискуЛП() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("СписокФильтров", Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает данные о записях из реестра решений о вводе лекарственных препарата в гражданский оборот по списку ЛП.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияРешенийОВводеЛПВГражданскийОборотПоСпискуЛП.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными из реестра.
//              Данные реестра хранятся в поле Данные - Соответствие - данные решений о вводе ЛП в гражданский оборот.
//
Функция ПолучитьРешенияОВводеЛПВГражданскийОборотПоСпискуЛП(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьРешенияОВводеЛПВГражданскийОборотПоСпискуЛП", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		РабочиеПараметрыМетода = ПараметрыПолученияРешенийОВводеЛПВГражданскийОборотПоСпискуЛП();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		ТаймаутМеждуЗапросами = 500;
		
		СписокФильтров = РабочиеПараметрыМетода.СписокФильтров;
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		Для Каждого Фильтр Из СписокФильтров Цикл
			
			Отбор = Новый Структура("gtin, batch", Фильтр.gtin, Фильтр.НомерСерии);
			
			РезультатПорции = ПолучитьРешенияОВводеЛПВГражданскийОборот(ПараметрыПодключения, Отбор);
			Если РезультатПорции.Статус = "Ошибка" И РезультатПорции.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатПорции, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					РезультатПорции = ПолучитьРешенияОВводеЛПВГражданскийОборот(ПараметрыПодключения, Отбор);
				КонецЦикла;
			КонецЕсли;
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			ДанныеПоGTIN = Результат.Данные[Отбор.gtin];
			Если ДанныеПоGTIN = Неопределено Тогда
				ДанныеПоGTIN = Новый Соответствие;
				Результат.Данные[Отбор.gtin] = ДанныеПоGTIN;
			КонецЕсли;
			
			ДанныеПоНомеруСерии = ДанныеПоGTIN[Отбор.batch];
			Если ДанныеПоНомеруСерии = Неопределено Тогда
				ДанныеПоНомеруСерии = Новый Массив;
				ДанныеПоGTIN[Отбор.batch] = ДанныеПоНомеруСерии;
			КонецЕсли;
			
			Для Каждого ДанныеПорции Из РезультатПорции.Список Цикл
				ДанныеПорции["date"]         = СтрокаВДату(Лев(ДанныеПорции["date"], СтрНайти(ДанныеПорции["date"], "T") - 1));
				ДанныеПорции["op_exec_date"] = ИнтеграцияМДЛПВызовСервера.СтрокаВДатуЧасовогоПоясаСеанса(ДанныеПорции["op_exec_date"]);
				ДанныеПоНомеруСерии.Добавить(ДанныеПорции);
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьРешенияОВводеЛПВГражданскийОборот(ПараметрыПодключения, Отбор = Неопределено, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(НачальныйИндекс);
		ПараметрыМетода.Добавить(МаксимальноеКоличествоДокументов);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьРешенияОВводеЛПВГражданскийОборот", ПараметрыМетода);
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/lp-in-circulation-decisions/filter";
		
		ТаймаутМеждуЗапросами = 500;
		
		Фильтр = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, МаксимальноеКоличествоДокументов, ТаймаутМеждуЗапросами);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область ПолучениеОстатковИОборотов

// Параметры, для передачи в функцию ПолучитьОстаткиПотребительскихУпаковок.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ВладелецАсинхроннойЗадачи - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * Отбор - Структура - набор значений фильтрации.
//     ** ИдентификаторМестаДеятельности           - Строка - Идентификатор места деятельности.
//     ** sgtin                                    - Строка - sgtin.
//     ** gtin                                     - Строка - gtin.
//     ** НомерГрупповойУпаковки                   - Строка - sscc.
//     ** НомерСерии                               - Строка - Номер производственной серии.
//     ** Статус                                   - Массив - Массив статусов в виде строки, как они заданы в ИС МДЛП, например in_circulation.
//     ** НомерРУ                                  - Строка - Номер РУ.
//     ** НачалоПериодаДатыРУ                      - Дата   - Начало периода даты РУ.
//     ** КонецПериодаДатыРУ                       - Дата   - Конец периода даты РУ.
//     ** НачалоПериодаВводаВГражданскийОборот     - Дата   - Дата упаковки, начала временного диапазона - дата ввода в гражданский оборот.
//     ** КонецПериодаВводаВГражданскийОборот      - Дата   - Дата упаковки, конец временного диапазона - дата окончания ввода в гражданский оборот.
//     ** МНН                                      - Строка - Международное непатентованное наименование, или группировочное, или химическое наименование.
//     ** ТорговоеНаименование                     - Строка - Торговое наименование.
//     ** НачалоПериодаРегистрации                 - Дата   - Дата начала периода регистрации.
//     ** КонецПериодаРегистрации                  - Дата   - Дата окончания периода регистрации.
//     ** ИсточникФинансирования                   - Массив - Массив значений (чисел) источника финансирования:
//                                                            1 - собственные средства.
//                                                            2 - средства федерального бюджета.
//                                                            3 - средства регионального бюджета.
//     ** НачалоПериодаВыполненияПоследнейОперации - Дата   - Дата начала периода выполнения последней операции.
//     ** КонецПериодаВыполненияПоследнейОперации  - Дата   - Дата окончания периода выполнения последней операции.
//     ** ИдентификаторЗаказаСУЗ                   - Строка - Идентификатор заказа системы управления заказами (СУЗ).
//     ** ПризнакЖНВЛП                             - Булево - Признак наличия в ЖНВЛП.
//     ** Признак7ВЗН                              - Булево - Признак, отображающий, относится ли ЛП к списку 7ВЗН.
//     ** ТипВыводаИзОборота                       - Число  - Тип вывода из оборота:
//                                                              1 - Выбыл по документу.
//                                                              2 - Продан в розницу.
//                                                              3 - Выбыл через РВ.
//                                                              4 - Выбыл для оказания мед. помощи.
//                                                              5 - Выбыл по льготному рецепту.
//                                                              6 - Продан через дистанционную торговлю.
//     ** СпособВыбытия                            - Число  - Способ выбытия;
//                                                              1 - Документ.
//                                                              2 - Устройство.
//                                                              3 - ККТ.
//                                                              4 - РВ.
//     ** НачалоПериодаСрокаГодности               - Дата   - Начало периода срока годности.
//     ** КонецПериодаСрокаГодности                - Дата   - Конец периода срока годности.
//     ** МаркетплейсИНН                           - Массив - Массив ИНН организаций, осуществивших продажу (дистанционн ой площадки).
//
//   * ПоляРезультата - Массив - набор полей возвращаемого результата.
//                      Неопределено - все поля.
//     Доступные поля:
//     ** inn                     - ИНН владельца
//     ** gtin                    - gtin
//     ** sgtin                   - sgtin
//     ** status                  - Статус
//     ** status_date             - Дата последней смены статуса
//     ** batch                   - Номер производственной серии
//     ** owner                   - Наименование владельца
//     ** reg_number              - Номер РУ
//     ** reg_date                - Дата РУ
//     ** emission_type           - Тип эмиссии
//     ** release_date            - Дата изготовления
//     ** emission_operation_date - Дата регистрации
//     ** federal_subject_code    - Код субъекта РФ
//     ** federal_subject_name    - Местонахождение ЛП
//     ** expiration_date         - Срок годности
//     ** prod_name               - Торговая марка (бренд)
//     ** sell_name               - Торговое наименование
//     ** full_prod_name          - Полное наименование товара
//     ** reg_holder              - Держатель рег. Удостоверения
//     ** pack1_desc              - Описание вложенной немаркированной (первичной) упаковки
//     ** pack3_id                - Идентификационный код третичной упаковки (SSCC)
//     ** last_tracing_op_date    - Дата последней операции
//     ** source_type             - Источник финансирования 
//     ** customs_point_id        - Идентификатор места нахождения товара в ЗТК
//     ** drug_code               - Внутренний уникальный идентификатор ЛП в реестре ЕСКЛП
//     ** prod_d_name             - Количество единиц измерения дозировки ЛП (строковое представление)
//     ** prod_form_name          - Лекарственная форма
//     ** oms_order_id            - Идентификатор заказа системы управления заказами (СУЗ)
//     ** is_prepaid              - Признак предоплаты
//     ** free_code               - Признак бесплатного кода
//     ** is_paid                 - Статус оплаты
//     ** contains_vzn            - Признак вхождения в список 7ВЗН
//     ** billing_state           - Состояние оплаты SGTIN
//     ** vzn_drug                - Признак, отображающий, относится ли ЛП к списку 7ВЗН
//     ** gnvlp                   - Признак наличия в ЖНВЛП
//     ** sys_id                  - Идентификатор субъекта обращенияв «ИС "Маркировка". МДЛП»
//     ** packing_inn             - ИНН/ITIN упаковщика во вторичную/третичную упаковку
//     ** packing_name            - Наименование упаковщика во вторичную/третичную упаковку
//     ** packing_id              - Идентификатор упаковщика во вторичную/третичную упаковку
//     ** control_inn             - ИНН/ITIN производителя стадии выпускающий контроль качества
//     ** control_name            - Наименование производителя стадии выпускающий контроль качества
//     ** control_id              - Идентификатор производителя стадии выпускающий контроль качества
//     ** withdrawal_type         - Тип вывода из оборота
//     ** via_device              - Способ выбытия
//     ** payment_date            - Дата оплаты платежа
//     ** tariff                  - Тариф оплаты
//     ** total_cost              - Суммарная стоимость
//     ** marketplace_inn         - ИНН дистанционной площадки, осуществившей последнюю продажу
//     ** verified                - Признак прохождения кодом проверки на СЭ
//     ** total_sold_part         - Суммарная проданная доля
//     ** total_withdrawal_part   - Суммарная списанная доля
//     ** not_on_my_balance       - Отгружено отправителем
// Более подробно см. в документации к АПИ МДЛП.
//
Функция ПараметрыПолученияОстатковПотребительскихУпаковок(ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВладелецАсинхроннойЗадачи", ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("Отбор", Новый Структура);
	Параметры.Отбор.Вставить("ИдентификаторМестаДеятельности"          , Неопределено);
	Параметры.Отбор.Вставить("sgtin"                                   , Неопределено);
	Параметры.Отбор.Вставить("gtin"                                    , Неопределено);
	Параметры.Отбор.Вставить("НомерГрупповойУпаковки"                  , Неопределено);
	Параметры.Отбор.Вставить("НомерСерии"                              , Неопределено);
	Параметры.Отбор.Вставить("Статус"                                  , Неопределено);
	Параметры.Отбор.Вставить("НомерРУ"                                 , Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаДатыРУ"                     , Неопределено);
	Параметры.Отбор.Вставить("КонецПериодаДатыРУ"                      , Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаВводаВГражданскийОборот"    , Неопределено);
	Параметры.Отбор.Вставить("КонецПериодаВводаВГражданскийОборот"     , Неопределено);
	Параметры.Отбор.Вставить("МНН"                                     , Неопределено);
	Параметры.Отбор.Вставить("ТорговоеНаименование"                    , Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаРегистрации"                , Неопределено);
	Параметры.Отбор.Вставить("КонецПериодаРегистрации"                 , Неопределено);
	Параметры.Отбор.Вставить("ИсточникФинансирования"                  , Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаВыполненияПоследнейОперации", Неопределено);
	Параметры.Отбор.Вставить("КонецПериодаВыполненияПоследнейОперации" , Неопределено);
	Параметры.Отбор.Вставить("ИдентификаторЗаказаСУЗ"                  , Неопределено);
	Параметры.Отбор.Вставить("ПризнакЖНВЛП"                            , Неопределено);
	Параметры.Отбор.Вставить("Признак7ВЗН"                             , Неопределено);
	Параметры.Отбор.Вставить("ТипВыводаИзОборота"                      , Неопределено);
	Параметры.Отбор.Вставить("СпособВыбытия"                           , Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаСрокаГодности"              , Неопределено);
	Параметры.Отбор.Вставить("КонецПериодаСрокаГодности"               , Неопределено);
	Параметры.Отбор.Вставить("МаркетплейсИНН"                          , Неопределено);
	
	Параметры.Вставить("ПоляРезультата", Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию об остатках потребительских упаковок.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияОстатковПотребительскихУпаковок.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об остатках потребительских упаковок.
//
Функция ПолучитьОстаткиПотребительскихУпаковок(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьОстаткиПотребительскихУпаковок", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаДанныхИзРеестраКИЗ");
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыПолученияОстатковПотребительскихУпаковок(Неопределено);
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		ВладелецАсинхроннойЗадачи = РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи;
		
		Отбор = Новый Структура;
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "sys_id"                      , "ИдентификаторМестаДеятельности");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "sgtin"                       , "sgtin");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "gtin"                        , "gtin");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "pack3_id"                    , "НомерГрупповойУпаковки");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "batches"                     , "НомерСерии");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "status"                      , "Статус");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "reg_number"                  , "НомерРУ");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "reg_date_from"               , "НачалоПериодаДатыРУ");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "reg_date_to"                 , "КонецПериодаДатыРУ");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "release_date_from"           , "НачалоПериодаВводаВГражданскийОборот");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "release_date_to"             , "КонецПериодаВводаВГражданскийОборот");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "prod_name"                   , "МНН");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "sell_name"                   , "ТорговоеНаименование");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "emission_operation_date_from", "НачалоПериодаРегистрации");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "emission_operation_date_to"  , "КонецПериодаРегистрации");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "source_type"                 , "ИсточникФинансирования");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "last_tracing_op_date_from"   , "НачалоПериодаВыполненияПоследнейОперации");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "last_tracing_op_date_to"     , "КонецПериодаВыполненияПоследнейОперации");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "oms_order_id"                , "ИдентификаторЗаказаСУЗ");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "gnvlp"                       , "ПризнакЖНВЛП");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "vzn_drug"                    , "Признак7ВЗН");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "withdrawal_type"             , "ТипВыводаИзОборота");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "via_device"                  , "СпособВыбытия");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "expiration_date_from"        , "НачалоПериодаСрокаГодности");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "expiration_date_to"          , "КонецПериодаСрокаГодности");
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "marketplace_inn"             , "МаркетплейсИНН");
		
		Если Не ЗначениеЗаполнено(Отбор) Тогда
			Отбор = Неопределено;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ПоляРезультата) Тогда
			ПоляРезультата = РабочиеПараметрыМетода.ПоляРезультата;
		Иначе
			ПоляРезультата = Неопределено;
		КонецЕсли;
		
		// Регистрация задачи.
		Результат = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, ВладелецАсинхроннойЗадачи, Отбор, ПоляРезультата);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		ИдентификаторЗадачи = Результат.Данные["id"];
		
		// Получение результата задачи с проверками результата и выполнением соответствующих действий.
		Результат = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьОстаткиЛекарственногоПрепарата.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ВладелецАсинхроннойЗадачи - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * gtin                          - ОпределяемыйТип.GTIN - Поле отбора.GTIN по которому необходимо получить остатки. Обязательный.
//   * НомераСерий                   - Массив - Поле отбора. Набор серий. Обязателен, если не указан период нанесения.
//   * ДатаНачалаПериода             - Дата - Поле отбора. Дата начала периода нанесения. Обязателен, если не заполнен набор серий и дата окончания периода нанесения.
//   * ДатаОкончанияПериода          - Дата - Поле отбора. Дата окончания периода нанесения. Обязателен, если не заполнен набор серий и дата начала периода нанесения.
//   * КодСубъектаРФ                 - Строка - Поле отбора. Код субъекта РФ.
//   * НаселенныйПункт               - Строка - Поле отбора. Населенный пункт.
//   * ИННТекущегоВладельца          - Строка - Поле отбора. ИНН текущего владельца.
//   * НаименованиеТекущегоВладельца - Строка - Поле отбора. Наименование текущего владельца.
//   * ИННПроизводителя              - Строка - Поле отбора. ИНН производителя.
//   * ПоляРезультата                - Массив - набор полей, необходимых в результате.
//                                              Доступные поля: gtin, batch, prod_name, federal_subject_name, city, area, inn, owner, packing_inn, emitent, cnt, update_date.
// Более подробно см. в документации к АПИ МДЛП.
//
Функция ПараметрыПолученияОстатковЛекарственногоПрепарата(gtin, ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВладелецАсинхроннойЗадачи", ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("gtin"                         , gtin);
	Параметры.Вставить("НомераСерий"                  , Новый Массив);
	Параметры.Вставить("ДатаНачалаПериода"            , Дата(1, 1, 1));
	Параметры.Вставить("ДатаОкончанияПериода"         , Дата(1, 1, 1));
	Параметры.Вставить("КодСубъектаРФ"                , Неопределено);
	Параметры.Вставить("НаселенныйПункт"              , Неопределено);
	Параметры.Вставить("ИННТекущегоВладельца"         , Неопределено);
	Параметры.Вставить("НаименованиеТекущегоВладельца", Неопределено);
	Параметры.Вставить("ИННПроизводителя"             , Неопределено);
	
	Параметры.Вставить("ПоляРезультата"               , Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию об остатках лекарственного препарата.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияОстатковЛекарственногоПрепарата.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об остатках лекарственного препарата.
//
Функция ПолучитьОстаткиЛекарственногоПрепарата(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьОстаткиЛекарственногоПрепарата", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаОтчетаПоОстаткамЛП");
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыПолученияОстатковЛекарственногоПрепарата(Неопределено);
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		Отбор = Новый Структура;
		Отбор.Вставить("gtin", РабочиеПараметрыМетода.gtin);
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НомераСерий) Тогда
			Отбор.Вставить("batches", РабочиеПараметрыМетода.НомераСерий);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ДатаНачалаПериода) Тогда
			Отбор.Вставить("utilization_date_start", Формат(РабочиеПараметрыМетода.ДатаНачалаПериода, "ДФ=yyyy-MM-dd"));
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ДатаОкончанияПериода) Тогда
			Отбор.Вставить("utilization_date_end", Формат(РабочиеПараметрыМетода.ДатаОкончанияПериода, "ДФ=yyyy-MM-dd"));
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.КодСубъектаРФ) Тогда
			Отбор.Вставить("federal_subject_code", РабочиеПараметрыМетода.КодСубъектаРФ);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НаселенныйПункт) Тогда
			Отбор.Вставить("city_with_type", РабочиеПараметрыМетода.НаселенныйПункт);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИННТекущегоВладельца) Тогда
			Отбор.Вставить("inn", РабочиеПараметрыМетода.ИННТекущегоВладельца);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НаименованиеТекущегоВладельца) Тогда
			Отбор.Вставить("owner", РабочиеПараметрыМетода.НаименованиеТекущегоВладельца);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИННПроизводителя) Тогда
			Отбор.Вставить("packing_inn", РабочиеПараметрыМетода.ИННПроизводителя);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(РабочиеПараметрыМетода.ПоляРезультата) Тогда
			РабочиеПараметрыМетода.ПоляРезультата = СтрРазделить("gtin, batch, prod_name, federal_subject_name, city, area, inn, owner, packing_inn, emitent, cnt, update_date", ", ", Ложь);
		КонецЕсли;
		
		// Регистрация задачи.
		Результат = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи, Отбор, РабочиеПараметрыМетода.ПоляРезультата);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		ИдентификаторЗадачи = Результат.Данные["id"];
		
		// Получение результата задачи с проверками результата и выполнением соответствующих действий.
		Результат = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьОстаткиЛекарственногоПрепаратаНаМД.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ВладелецАсинхроннойЗадачи - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * gtin                      - ОпределяемыйТип.GTIN - Поле отбора. GTIN по которому необходимо получить остатки. Обязателен, если не указан идентификатор места деятельности.
//   * ИдентификаторМД           - Строка - Поле отбора. Идентификатор места деятельности. Обязателен, если не указан GTIN.
//   * ИдентификаторМОХ          - Строка - Поле отбора. Идентификатор места ответственного хранения. Обязателен, если не указан GTIN.
//   * ПоляРезультата            - Массив - набор полей, необходимых в результате.
//                                          Доступные поля: gtin, branch_id, prod_name, prod_sell_name, cnt, update_date.
// Более подробно см. в документации к АПИ МДЛП.
//
Функция ПараметрыПолученияОстатковЛекарственногоПрепаратаНаМД(ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВладелецАсинхроннойЗадачи", ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("gtin"           , Неопределено);
	Параметры.Вставить("ИдентификаторМД", Неопределено);
	Параметры.Вставить("ИдентификаторМОХ", Неопределено);
	
	Параметры.Вставить("ПоляРезультата" , Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию об остатках лекарственного препарата на местах деятельности.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияОстатковЛекарственногоПрепаратаНаМД.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными об остатках лекарственного препарата на МД.
//
Функция ПолучитьОстаткиЛекарственногоПрепаратаНаМД(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьОстаткиЛекарственногоПрепаратаНаМД", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаОтчетаПоОстаткамНаМД");
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыПолученияОстатковЛекарственногоПрепаратаНаМД(Неопределено);
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		Отбор = Новый Структура;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.gtin) Тогда
			Отбор.Вставить("gtin", РабочиеПараметрыМетода.gtin);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИдентификаторМД) Тогда
			Отбор.Вставить("branch_id", РабочиеПараметрыМетода.ИдентификаторМД);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИдентификаторМОХ) Тогда
			Отбор.Вставить("warehouse_id", РабочиеПараметрыМетода.ИдентификаторМОХ);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(РабочиеПараметрыМетода.ПоляРезультата) Тогда
			РабочиеПараметрыМетода.ПоляРезультата = СтрРазделить("gtin, branch_id, prod_name, prod_sell_name, cnt, update_date", ", ", Ложь);
		КонецЕсли;
		
		// Регистрация задачи.
		Результат = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи, Отбор, РабочиеПараметрыМетода.ПоляРезультата);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		ИдентификаторЗадачи = Результат.Данные["id"];
		
		// Получение результата задачи с проверками результата и выполнением соответствующих действий.
		Результат = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


// Параметры, для передачи в функцию ПолучитьВыбытияЛекарственногоПрепарата.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ВладелецАсинхроннойЗадачи - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * gtin                          - ОпределяемыйТип.GTIN - Поле отбора. GTIN по которому необходимо получить остатки. Обязательный.
//   * НомераСерий                   - Массив - Поле отбора. Набор серий. Обязателен, если не указан период выбытия.
//   * ДатаНачалаПериода             - Дата - Поле отбора. Дата начала периода выбытия. Обязателен, если не заполнен набор серий и дата окончания периода выбытия.
//   * ДатаОкончанияПериода          - Дата - Поле отбора. Дата окончания периода выбытия. Обязателен, если не заполнен набор серий и дата начала периода выбытия.
//   * КодСубъектаРФ                 - Строка - Поле отбора. Код субъекта РФ.
//   * НаселенныйПункт               - Строка - Поле отбора. Населенный пункт.
//   * ИННТекущегоВладельца          - Строка - Поле отбора. ИНН текущего владельца.
//   * НаименованиеТекущегоВладельца - Строка - Поле отбора. Наименование текущего владельца.
//   * ИННПроизводителя              - Строка - Поле отбора. ИНН производителя.
//   * ТипВыводаИзОборота            - Число:
//                                      1 - Продажа
//                                      2 - Отпуск по льготному рецепту
//                                      3 - Медицинское использование
//                                      4 - Отпуск ЛП по документам
//                                      5 - Выбытие по инымпричинам
//   * ПоляРезультата                - Массив - набор полей, необходимых в результате.
//                                              Доступные поля: gtin, batch, prod_name, federal_subject_name, city, area, inn, owner, packing_inn, emitent, exit_type, cnt, update_date.
// Более подробно см. в документации к АПИ МДЛП.
//
Функция ПараметрыПолученияВыбытияЛекарственногоПрепарата(gtin, ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВладелецАсинхроннойЗадачи", ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("gtin"                         , gtin);
	Параметры.Вставить("НомераСерий"                  , Новый Массив);
	Параметры.Вставить("ДатаНачалаПериода"            , Дата(1, 1, 1));
	Параметры.Вставить("ДатаОкончанияПериода"         , Дата(1, 1, 1));
	Параметры.Вставить("КодСубъектаРФ"                , Неопределено);
	Параметры.Вставить("НаселенныйПункт"              , Неопределено);
	Параметры.Вставить("ИННТекущегоВладельца"         , Неопределено);
	Параметры.Вставить("НаименованиеТекущегоВладельца", Неопределено);
	Параметры.Вставить("ИННПроизводителя"             , Неопределено);
	Параметры.Вставить("ТипВыводаИзОборота"           , 0);
	
	Параметры.Вставить("ПоляРезультата"               , Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает информацию о выбытиях лекарственного препарата.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыПолученияВыбытияЛекарственногоПрепарата.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными о выбытиях лекарственного препарата.
//
Функция ПолучитьВыбытияЛекарственногоПрепарата(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьВыбытияЛекарственногоПрепарата", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаОтчетаПоВыбытиюЛП");
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыПолученияВыбытияЛекарственногоПрепарата(Неопределено);
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		Отбор = Новый Структура;
		Отбор.Вставить("gtin", РабочиеПараметрыМетода.gtin);
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НомераСерий) Тогда
			Отбор.Вставить("batches", РабочиеПараметрыМетода.НомераСерий);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ДатаНачалаПериода) Тогда
			Отбор.Вставить("exit_date_start", Формат(РабочиеПараметрыМетода.ДатаНачалаПериода, "ДФ=yyyy-MM-dd"));
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ДатаОкончанияПериода) Тогда
			Отбор.Вставить("exit_date_end", Формат(РабочиеПараметрыМетода.ДатаОкончанияПериода, "ДФ=yyyy-MM-dd"));
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.КодСубъектаРФ) Тогда
			Отбор.Вставить("federal_subject_code", РабочиеПараметрыМетода.КодСубъектаРФ);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НаселенныйПункт) Тогда
			Отбор.Вставить("city_with_type", РабочиеПараметрыМетода.НаселенныйПункт);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИННТекущегоВладельца) Тогда
			Отбор.Вставить("inn", РабочиеПараметрыМетода.ИННТекущегоВладельца);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.НаименованиеТекущегоВладельца) Тогда
			Отбор.Вставить("owner", РабочиеПараметрыМетода.НаименованиеТекущегоВладельца);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ИННПроизводителя) Тогда
			Отбор.Вставить("packing_inn", РабочиеПараметрыМетода.ИННПроизводителя);
		КонецЕсли;
		Если ЗначениеЗаполнено(РабочиеПараметрыМетода.ТипВыводаИзОборота) Тогда
			Отбор.Вставить("exit_type", РабочиеПараметрыМетода.ТипВыводаИзОборота);
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(РабочиеПараметрыМетода.ПоляРезультата) Тогда
			РабочиеПараметрыМетода.ПоляРезультата = СтрРазделить("gtin, batch, prod_name, federal_subject_name, city, area, inn, owner, packing_inn, emitent, exit_type, cnt, update_date", ", ", Ложь);
		КонецЕсли;
		
		// Регистрация задачи.
		Результат = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи, Отбор, РабочиеПараметрыМетода.ПоляРезультата);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		ИдентификаторЗадачи = Результат.Данные["id"];
		
		// Получение результата задачи с проверками результата и выполнением соответствующих действий.
		Результат = ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти // ПолучениеОстатковИОборотов

#Область ЗагрузкаОстатковИОборотов

// Параметры, для передачи в функцию ЗагрузитьОстаткиПотребительскихУпаковок.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ВладелецАсинхроннойЗадачи - ЛюбаяСсылка, Строка - ссылка на объект или другой идентификатор, в разрезе которого можно зарегистрировать асинхронную задачу.
//   * Отбор - Структура - набор значений фильтрации.
//     ** ИдентификаторМестаДеятельности - Строка - (обязательный) идентификатор места деятельности.
// Важно! Используется отбор только по идентификатору места деятельности.
//
Функция ПараметрыЗагрузкиОстатковПотребительскихУпаковок(ВладелецАсинхроннойЗадачи = Неопределено) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВладелецАсинхроннойЗадачи", ВладелецАсинхроннойЗадачи);
	
	Параметры.Вставить("Отбор", Новый Структура);
	Параметры.Отбор.Вставить("ИдентификаторМестаДеятельности", Неопределено);
	Параметры.Отбор.Вставить("НачалоПериодаВыполненияПоследнейОперации", Неопределено);
	
	ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаДанныхИзРеестраКИЗ");
	ПараметрыЗагрузки = ТранспортМДЛПАПИВызовСервера.ПараметрыЗагрузкиДанныхРезультатовМетода(ТипЗадачи);
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Параметры, ПараметрыЗагрузки, Истина);
	
	Возврат Параметры;
	
КонецФункции

// Загружает информацию об остатках потребительских упаковок в соответствующий регистр сведений.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыЗагрузкиОстатковПотребительскихУпаковок.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации().
//                          Сами данные хранятся в соответствующем регистре сведений.
//
Функция ЗагрузитьОстаткиПотребительскихУпаковок(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ЗагрузитьОстаткиПотребительскихУпаковок", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		ТипЗадачи = ПредопределенноеЗначение("Перечисление.ТипыАсинхронныхЗадачМДЛП.ВыгрузкаДанныхИзРеестраКИЗ");
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыЗагрузкиОстатковПотребительскихУпаковок(Неопределено);
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		ВладелецАсинхроннойЗадачи = РабочиеПараметрыМетода.ВладелецАсинхроннойЗадачи;
		
		ИдентификаторМестаДеятельности = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(РабочиеПараметрыМетода.Отбор, "ИдентификаторМестаДеятельности");
		Если Не ЗначениеЗаполнено(ИдентификаторМестаДеятельности) Тогда
			Результат =  ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			Результат.Статус = "Ошибка";
			Результат.ОписаниеОшибки = НСтр("ru = 'Не заполнен обазательный параметр отбора ""ИдентификаторМестаДеятельности"".'");
			Возврат Результат;
		КонецЕсли;
		
		Отбор = Новый Структура;
		Отбор.Вставить("sys_id", ИдентификаторМестаДеятельности);
		ДополнитьОтборСПроверкой(Отбор, РабочиеПараметрыМетода.Отбор, "last_tracing_op_date_from", "НачалоПериодаВыполненияПоследнейОперации");
		
		ПоляРезультата = Новый Массив;
		ПоляРезультата.Добавить("sgtin");
		ПоляРезультата.Добавить("gtin");
		ПоляРезультата.Добавить("sys_id");
		ПоляРезультата.Добавить("status");
		ПоляРезультата.Добавить("status_date");
		ПоляРезультата.Добавить("pack3_id");
		ПоляРезультата.Добавить("not_on_my_balance");
		ПоляРезультата.Добавить("batch");
		ПоляРезультата.Добавить("expiration_date");
		
		// Регистрация задачи.
		Результат = ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, ВладелецАсинхроннойЗадачи, Отбор, ПоляРезультата);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		ИдентификаторЗадачи = Результат.Данные["id"];
		
		// Загрузка результата задачи с проверками результата и выполнением соответствующих действий.
		ПараметрыЗагрузки = ПараметрыЗагрузкиРезультатаАсинхроннойЗадачи(ИдентификаторЗадачи, ТипЗадачи);
		ЗаполнитьЗначенияСвойств(ПараметрыЗагрузки, ПараметрыМетода);
		
		Результат = ЗагрузитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ПараметрыЗагрузки);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

// Параметры, для передачи в функцию ЗагрузитьОстаткиГрупповыхУпаковок.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * ЗагрузкаВТранзакции - Булево - признак необходимости загрузки в транзакции.
//   * Отбор - Структура - набор значений фильтрации.
//     ** ИдентификаторМестаДеятельности - Строка - (обязательный) идентификатор места деятельности.
// Важно! Используется отбор только по идентификатору места деятельности.
//
Функция ПараметрыЗагрузкиОстатковГрупповыхУпаковок() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ЗагрузкаВТранзакции", Истина);
	
	Параметры.Вставить("Отбор", Новый Структура);
	Параметры.Отбор.Вставить("ИдентификаторМестаДеятельности", Неопределено);
	
	ТипЗадачи = "ЗагрузитьОстаткиГрупповыхУпаковокСинхронно";
	ПараметрыЗагрузки = ТранспортМДЛПАПИВызовСервера.ПараметрыЗагрузкиДанныхРезультатовМетода(ТипЗадачи);
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Параметры, ПараметрыЗагрузки, Истина);
	
	Возврат Параметры;
	
КонецФункции

Функция ЗагрузитьОстаткиГрупповыхУпаковок(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	Возврат ЗагрузитьОстаткиГрупповыхУпаковокСинхронно(ПараметрыПодключения, ПараметрыМетода);
	
КонецФункции

Функция ЗагрузитьОстаткиГрупповыхУпаковокСинхронно(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ЗагрузитьОстаткиГрупповыхУпаковокСинхронно", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		// Инициализация параметров.
		РабочиеПараметрыМетода = ПараметрыЗагрузкиОстатковГрупповыхУпаковок();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		ЗагрузкаВТранзакции = РабочиеПараметрыМетода.ЗагрузкаВТранзакции;
		
		ИдентификаторМестаДеятельности = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(РабочиеПараметрыМетода.Отбор, "ИдентификаторМестаДеятельности");
		Если Не ЗначениеЗаполнено(ИдентификаторМестаДеятельности) Тогда
			Результат =  ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			Результат.Статус = "Ошибка";
			Результат.ОписаниеОшибки = НСтр("ru = 'Не заполнен обазательный параметр отбора ""ИдентификаторМестаДеятельности"".'");
			Возврат Результат;
		КонецЕсли;
		
		// Подготовка параметров выполняемого метода.
		ПараметрыВложенногоМетода = ПараметрыПолученияИнформацииОСуществующихТранспортныхУпаковках();
		ПараметрыВложенногоМетода.ПолучатьВерхнеуровневыеУпаковки = Истина;
		ПараметрыВложенногоМетода.НомераУпаковок = ТранспортМДЛПАПИВызовСервера.ТранспортныеНомераУпаковокДляПолученияОстатков(ИдентификаторМестаДеятельности);
		
		// Получения данных выполняемого метода.
		РезультатВложенногоМетода = ПолучитьИнформациюОСуществующихТранспортныхУпаковках(ПараметрыПодключения, ПараметрыВложенногоМетода);
		Если РезультатВложенногоМетода.Статус = "Ошибка" Тогда
			Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатВложенногоМетода));
			Возврат Результат;
		КонецЕсли;
		
		// Получение результата загрузки данных выполняемого метода.
		ПараметрыЗагрузки = ТранспортМДЛПАПИВызовСервера.ПараметрыЗагрузкиДанныхРезультатовМетода("ЗагрузитьОстаткиГрупповыхУпаковокСинхронно");
		Результат = ТранспортМДЛПАПИВызовСервера.ЗагрузитьДанныеРезультатовМетода(РезультатВложенногоМетода.Данные, ПараметрыЗагрузки);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти // ЗагрузкаОстатковИОборотов


#Область ВерификацияКодовМаркировки

// Параметры, для передачи в функцию ВерифицироватьКодыМаркировки.
//
// Возвращаемое значение:
//  Параметры - Структура - параметры, которые необходимо заполнить перед передачей в соответствующую функцию:
//   * КодыМаркировкиBase64 - Массив - полные коды маркировки в формате Base64. Строка Base64 должна быть без символов Символы.ПС и Символы.ВК.
//
Функция ПараметрыВерификацииКодовМаркировки() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("КодыМаркировкиBase64", Новый Массив);
	
	Возврат Параметры;
	
КонецФункции

// Получает результат верификации кодов маркировки.
// Возвращает признаки валидности КМ, наличия КМ в реестрах СЭ и признак прохождения КМ криптографической проверки.
//
// Параметры:
//  ПараметрыПодключения - Структура - параметры подключения к ИС "Маркировка.МДЛП".
//  ПараметрыМетода      - Структура - см. функцию ПараметрыВерификацииКодовМаркировки.
//
// Возвращаемое значение:
//  Результат - Структура - ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(), дополненная данными о верификации кодов маркировки.
//              Данные о верификации КМ хранятся в поле Данные - Соответствие - данные с признаками верификации КМ.
//
Функция ВерифицироватьКодыМаркировки(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ВерифицироватьКодыМаркировки", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		РабочиеПараметрыМетода = ПараметрыВерификацииКодовМаркировки();
		ЗаполнитьЗначенияСвойств(РабочиеПараметрыМетода, ПараметрыМетода);
		
		РазмерПорции = 100; // Количество верифицируемых кодов маркировки не может превышать 100.
		ТаймаутМеждуЗапросами = 30000; // Вызов метода доступен не чаще чем раз в 30 секунд.
		
		КодыМаркировкиBase64 = РабочиеПараметрыМетода.КодыМаркировкиBase64;
		
		// Результат метода по умолчанию.
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", Новый Соответствие);
		
		УникальныеКодыМаркировкиBase64 = ОбщегоНазначенияКлиентСервер.СвернутьМассив(КодыМаркировкиBase64);
		Пока УникальныеКодыМаркировкиBase64.Количество() > 0 Цикл
			
			ПорцияКодовМаркировкиBase64 = ПолучитьПорциюДанных(УникальныеКодыМаркировкиBase64, РазмерПорции);
			
			ПорцияРабочихКодовМаркировки = Новый Массив;
			Для Каждого КодМаркировкиBase64 Из ПорцияКодовМаркировкиBase64 Цикл
				ПорцияРабочихКодовМаркировки.Добавить(ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(КодМаркировкиBase64)));
			КонецЦикла;
			
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "sgtin/verification";
			
			ТелоЗапроса = Новый Структура;
			ТелоЗапроса.Вставить("sgtins", ПорцияРабочихКодовМаркировки);
			ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
			
			РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если РезультатПорции.Статус = "Ошибка" И РезультатПорции.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатПорции, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					РезультатПорции = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если РезультатПорции.Статус = "Ошибка" Тогда
				ЗаполнитьЗначенияСвойств(Результат, ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(РезультатПорции));
				Возврат Результат;
			КонецЕсли;
			
			Для Каждого КодМаркировкиBase64 Из ПорцияКодовМаркировкиBase64 Цикл
				// По умолчанию считаем, что КМ не прошли проверку.
				ДанныеУпаковки = Новый Соответствие;
				ДанныеУпаковки.Вставить("sgtin"   , КодМаркировкиBase64);
				ДанныеУпаковки.Вставить("valid"   , Ложь);
				ДанныеУпаковки.Вставить("found"   , Ложь);
				ДанныеУпаковки.Вставить("verified", Ложь);
				Результат.Данные.Вставить(КодМаркировкиBase64, ДанныеУпаковки);
			КонецЦикла;
			
			НайденныеКМ = РезультатПорции.Данные["entries"];
			Если ЗначениеЗаполнено(НайденныеКМ) Тогда
				Для Каждого НайденныйКМ Из НайденныеКМ Цикл
					
					// Изменение результата метода на привычный формат.
					КодМаркировкиBase64 = Base64Строка(ПолучитьДвоичныеДанныеИзСтроки(НайденныйКМ["sgtin"]));
					КодМаркировкиBase64 = СтрЗаменить(СтрЗаменить(КодМаркировкиBase64, Символы.ПС, ""), Символы.ВК, "");
					
					НайденныйКМ.Вставить("sgtin", КодМаркировкиBase64);
					
					Результат.Данные.Вставить(КодМаркировкиBase64, НайденныйКМ);
					
				КонецЦикла;
			КонецЕсли;
			
			Если УникальныеКодыМаркировкиBase64.Количество() > 0 Тогда
				Таймаут(ТаймаутМеждуЗапросами);
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#Область ПолучениеАналитическихДанных

Функция ЗарегистрироватьАсинхроннуюЗадачуСПроверкой(ПараметрыПодключения, ТипЗадачи, ВладелецАсинхроннойЗадачи, Отбор = Неопределено, Поля = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ТипЗадачи);
		ПараметрыМетода.Добавить(ВладелецАсинхроннойЗадачи);
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(Поля);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ЗарегистрироватьАсинхроннуюЗадачуСПроверкой", ПараметрыМетода);
	#Иначе
		
		Результат = ЗарегистрироватьАсинхроннуюЗадачу(ПараметрыПодключения, ТипЗадачи, Отбор, Поля);
		Если Результат.Статус = "Ошибка" Тогда
			
			Данные = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Результат, "Данные");
			Если Данные <> Неопределено И СтрНайти(Данные["error_code"], "TASKS_LIMIT_EXCEEDED") > 0 Тогда
				
				// Превышено максимальное количество задач. Необходимо проверить, нет ли задач, которые можно удалить из списка.
				Результат = УдалитьНеактуальныеАсинхронныеЗадачи(ПараметрыПодключения);
				Если Результат.Статус = "Ошибка" Тогда
					Возврат Результат;
				КонецЕсли;
				
				Результат = ЗарегистрироватьАсинхроннуюЗадачу(ПараметрыПодключения, ТипЗадачи, Отбор, Поля);
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если Результат.Статус = "Успешно" Тогда
			ДанныеЗадачи = Новый Структура;
			ДанныеЗадачи.Вставить("Идентификатор" , Результат.Данные["id"]);
			ДанныеЗадачи.Вставить("ТипЗадачи"     , ТипЗадачи);
			ДанныеЗадачи.Вставить("ВладелецЗадачи", ВладелецАсинхроннойЗадачи);
			ТранспортМДЛПАПИВызовСервера.ДобавитьЗадачуВСписокОжиданияАсинхронныхЗадач(ДанныеЗадачи);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция УдалитьНеактуальныеАсинхронныеЗадачи(ПараметрыПодключения) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "УдалитьНеактуальныеАсинхронныеЗадачи");
	#Иначе
		
		// Получение списка задач пользователя.
		Результат = ПолучитьСписокЗарегистрированныхАсинхронныхЗадач(ПараметрыПодключения);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		СписокЗарегистрированныхЗадач = Результат.Данные["items"];
		
		ТекущаяДатаСеанса = ПолучитьТекущуюДатуСеанса();
		
		ГраницаОжиданияЗадачи = ТекущаяДатаСеанса - 15*60; // 15 мин.
		
		ИдентификаторыЗадач = Новый Массив;
		ГраницыЗадач = Новый Соответствие;
		Для Каждого Задача Из СписокЗарегистрированныхЗадач Цикл
			СтатусЗадачи        = Задача["status"];
			ИдентификаторЗадачи = Задача["id"];
			ИдентификаторыЗадач.Добавить(ИдентификаторЗадачи);
			Если СтатусЗадачи = "COMPLETED" Или СтатусЗадачи = "FAILED" Тогда
				ГраницыЗадач.Вставить(ИдентификаторЗадачи, ГраницаОжиданияЗадачи);
			Иначе
				ГраницыЗадач.Вставить(ИдентификаторЗадачи, ГраницаОжиданияЗадачи);
			КонецЕсли;
		КонецЦикла;
		
		АсинхронныеЗадачи = ТранспортМДЛПАПИВызовСервера.ПолучитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторыЗадач));
		
		Для Каждого ИдентификаторЗадачи Из ИдентификаторыЗадач Цикл
			АсинхроннаяЗадача = АсинхронныеЗадачи[ИдентификаторЗадачи];
			// Если задачи нет среди списка ожидающих, или срок ожидания прошел, тогда ее можно удалять.
			Если АсинхроннаяЗадача = Неопределено Тогда
				УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
			ИначеЕсли ЗначениеЗаполнено(АсинхроннаяЗадача.ДатаРегистрации) И АсинхроннаяЗадача.ДатаРегистрации < ГраницыЗадач[ИдентификаторЗадачи] Тогда
				ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
				УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ИдентификаторЗадачи) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторЗадачи);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьРезультатАсинхроннойЗадачиСПроверкой", ПараметрыМетода);
	#Иначе
		
		// Ожидание выполнения асинхронной задачи.
		Результат = ОжидатьВыполнениеАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		// Получение исходных данных результата выполнения задачи.
		Результат = ПолучитьРезультатАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			
			ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
			
			Если Не Результат.ТребуетсяАвторизация Тогда
				УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
			КонецЕсли;
			
			Возврат Результат;
			
		КонецЕсли;
		
		// Удаление задачи, после получения результата.
		ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
		УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
		
		// Получение конечных данных выполнения задачи.
		Результат = ТранспортМДЛПАПИВызовСервера.ПолучитьДанныеАсинхроннойЗадачиИзАрхива(Результат.Данные);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПараметрыЗагрузкиРезультатаАсинхроннойЗадачи(ИдентификаторЗадачи, ТипЗадачи) Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ИдентификаторЗадачи", ИдентификаторЗадачи);
	Параметры.Вставить("ТипЗадачи"          , ТипЗадачи);
	
	ПараметрыЗагрузки = ТранспортМДЛПАПИВызовСервера.ПараметрыЗагрузкиДанныхРезультатовМетода(ТипЗадачи);
	
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Параметры, ПараметрыЗагрузки, Истина);
	
	Возврат Параметры;
	
КонецФункции

Функция ЗагрузитьРезультатАсинхроннойЗадачиСПроверкой(ПараметрыПодключения, ПараметрыМетода) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ЗагрузитьРезультатАсинхроннойЗадачиСПроверкой", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ПараметрыМетода));
	#Иначе
		
		// Инициализация параметров.
		ИдентификаторЗадачи = ПараметрыМетода.ИдентификаторЗадачи;
		ТипЗадачи           = ПараметрыМетода.ТипЗадачи;
		
		Результат = ТранспортМДЛПАПИВызовСервера.ПроверитьВозможностьЗагрузкиДанныхРезультатовМетода(ТипЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		// Ожидание выполнения асинхронной задачи.
		Результат = ОжидатьВыполнениеАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		// Получение исходных данных результата выполнения задачи.
		Результат = ПолучитьРезультатАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи);
		Если Результат.Статус = "Ошибка" Тогда
			
			ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
			
			Если Не Результат.ТребуетсяАвторизация Тогда
				УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
			КонецЕсли;
			
			Возврат Результат;
			
		КонецЕсли;
		
		// Удаление задачи, после получения результата.
		ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
		УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
		
		// Получение результата загрузки данных выполняемой задачи.
		ПараметрыЗагрузки = ТранспортМДЛПАПИВызовСервера.ПараметрыЗагрузкиДанныхРезультатовМетода(ТипЗадачи);
		ЗаполнитьЗначенияСвойств(ПараметрыЗагрузки, ПараметрыМетода);
		
		Результат = ТранспортМДЛПАПИВызовСервера.ЗагрузитьДанныеРезультатовМетода(Результат.Данные, ПараметрыЗагрузки);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ОжидатьВыполнениеАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ОжидатьВыполнениеАсинхроннойЗадачи", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ИдентификаторЗадачи));
	#Иначе
		
		// Цикл ожидания выполнения задачи на сервере.
		Пока Истина Цикл
			
			Таймаут(5000);
			
			Результат = ПолучитьСписокЗарегистрированныхАсинхронныхЗадач(ПараметрыПодключения, Новый Структура("task_ids", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ИдентификаторЗадачи)));
			Если Результат.Статус = "Ошибка" Тогда
				
				// При любой возникшей ошибке необходимо удалить задачу из списка ожидающих задач, даже при ТребуетсяАвторизация,
				// т.к. после повторной авторизации будут создаваться новые задачи.
				ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
				
				Если Не Результат.ТребуетсяАвторизация Тогда
					УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
				Иначе
					// Задача на сервере будет удалена в функции УдалитьНеактуальныеАсинхронныеЗадачи, при повторном вызове, т.к. в списке ожидающих задач этой задачи нет.
				КонецЕсли;
				
				Возврат Результат;
				
			КонецЕсли;
			
			Если Результат.Данные["total"] > 0 Тогда
				
				Задача = Результат.Данные["items"][0];
				СтатусЗадачи = Задача["status"];
				
				Если СтатусЗадачи = "COMPLETED" Тогда
					
					// Задача выполнилать. Прекращаем ожидание.
					Прервать;
					
				ИначеЕсли СтатусЗадачи = "FAILED" Тогда
					
					ТранспортМДЛПАПИВызовСервера.УдалитьЗадачиИзСпискаОжиданияАсинхронныхЗадач(Новый Структура("Идентификатор", ИдентификаторЗадачи));
					УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи);
					
					Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
					Результат.Статус = "Ошибка";
					Результат.ОписаниеОшибки = СтрШаблон("status %1: %2", СтатусЗадачи, Задача["reason"]);
					Возврат Результат;
					
				Иначе
					// Задача выполняется. Ожидаем пока не выполнится или не закончится период ожидания выполнения задачи.
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции


Функция ПолучитьСписокОграниченийНаКоличествоАсинхронныхЗадач(ПараметрыПодключения) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокОграниченийНаКоличествоАсинхронныхЗадач");
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/settings";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьСписокЗарегистрированныхАсинхронныхЗадач(ПараметрыПодключения, Отбор = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(Отбор);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокЗарегистрированныхАсинхронныхЗадач", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/filter";
		
		Фильтр = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ЗарегистрироватьАсинхроннуюЗадачу(ПараметрыПодключения, ТипЗадачи, Отбор = Неопределено, Поля = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ТипЗадачи);
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(Поля);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ЗарегистрироватьАсинхроннуюЗадачу", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ИдентификаторТипаАсинхроннойЗадачи = ТранспортМДЛПАПИВызовСервера.ИдентификаторТипаАсинхроннойЗадачи(ТипЗадачи);
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/" + ИдентификаторТипаАсинхроннойЗадачи;
		
		ПараметрыЗадачи = Новый Структура;
		Если Отбор <> Неопределено Тогда
			ПараметрыЗадачи.Вставить("filters", Отбор);
		КонецЕсли;
		Если Поля <> Неопределено Тогда
			ПараметрыЗадачи.Вставить("fields", Поля);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("task_filter", ПараметрыЗадачи);
		
		ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьРезультатАсинхроннойЗадачи(ПараметрыПодключения, ИдентификаторЗадачи) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторЗадачи);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьРезультатАсинхроннойЗадачи", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/" + ИдентификаторЗадачи + "/result";
		ДанныеЗапроса.ПолучитьОтветКакДвоичныеДанные = Истина;
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ОтменитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторЗадачи);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ОтменитьАсинхроннуюЗадачу", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/" + ИдентификаторЗадачи + "/cancel";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция УдалитьАсинхроннуюЗадачу(ПараметрыПодключения, ИдентификаторЗадачи) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторЗадачи);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "УдалитьАсинхроннуюЗадачу", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 500;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("DELETE");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "export/tasks/" + ИдентификаторЗадачи;
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти // ПолучениеАналитическихДанных

#Область УстаревшиеПроцедурыИФункции

Функция ПолучитьДетальнуюИнформациюОКИЗ(ПараметрыПодключения, КИЗ) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьДетальнуюИнформациюОКИЗ", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(КИЗ));
	#Иначе
		
		Если ТипЗнч(КИЗ) <> Тип("Массив") Тогда
			СписокКИЗ = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(КИЗ);
		Иначе
			СписокКИЗ = КИЗ;
		КонецЕсли;
		
		ДанныеКИЗ = Новый Соответствие;
		Для Каждого НомерКИЗ Из СписокКИЗ Цикл
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/" + НомерКИЗ;
			
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				ТаймаутМеждуЗапросами = 5000;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если Результат.Статус = "Ошибка" Тогда
				Возврат Результат;
			КонецЕсли;
			
			ДанныеКИЗ.Вставить(НомерКИЗ, Результат.Данные);
		КонецЦикла;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", ДанныеКИЗ);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьИнформациюОбУпаковках(ПараметрыПодключения, НомераУпаковок, АдресХранения = Неопределено, Данные = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(НомераУпаковок);
		ПараметрыМетода.Добавить(АдресХранения);
		ПараметрыМетода.Добавить(Данные);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОбУпаковках", ПараметрыМетода);
	#Иначе
		
		ВремяОжидания = 5000;
		
		Если Данные = Неопределено Тогда
			Данные = Новый Структура;
			Данные.Вставить("КИЗ", Новый Соответствие);
			Данные.Вставить("ТранспортныеУпаковки", Новый Соответствие);
			Данные.Вставить("НеправильныеКода", Новый Соответствие);
		КонецЕсли;
		
		НомераКИЗ = Новый Массив;
		НомераТранспортныхУпаковок = Новый Массив;
		НеправильныеКода = Новый Массив;
		Для Каждого НомерУпаковки Из НомераУпаковок Цикл
			
			Если СтрДлина(НомерУпаковки) = 27 Тогда
				НомераКИЗ.Добавить(НомерУпаковки);
			ИначеЕсли СтрДлина(НомерУпаковки) = 18 Тогда
				НомераТранспортныхУпаковок.Добавить(НомерУпаковки);
			Иначе
				НеправильныеКода.Добавить(НомерУпаковки);
			КонецЕсли;
			
		КонецЦикла;
		
		Если НеправильныеКода.Количество() > 0 Тогда
			Для Каждого НомерУпаковки Из НеправильныеКода Цикл
				ДанныеУпаковки = Новый Структура;
				ДанныеУпаковки.Вставить("КодОшибки", "0");
				ДанныеУпаковки.Вставить("ОписаниеОшибки", НСтр("ru = 'Неверный код упаковки'"));
				Данные.НеправильныеКода.Вставить(НомерУпаковки, ДанныеУпаковки);
			КонецЦикла;
		КонецЕсли;
		НомераУпаковок = ОбщегоНазначенияКлиентСервер.РазностьМассивов(НомераУпаковок, НеправильныеКода);
		
		Если НомераКИЗ.Количество() > 0 Тогда
			Результат = ПолучитьИнформациюОКИЗ(ПараметрыПодключения, НомераКИЗ);
			Если Результат.Статус = "Ошибка" Тогда
				Возврат Результат;
			КонецЕсли;
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Данные.КИЗ, Результат.Данные, Истина);
		КонецЕсли;
		НомераУпаковок = ОбщегоНазначенияКлиентСервер.РазностьМассивов(НомераУпаковок, НомераКИЗ);
		
		Если НомераТранспортныхУпаковок.Количество() > 0 Тогда
			
			Результат = ПолучитьПолныйСоставУпаковок(ПараметрыПодключения, НомераТранспортныхУпаковок);
			Если Результат.Статус = "Ошибка" Тогда
				Если Результат.ТребуетсяАвторизация Тогда
					// Формирование результата с промежуточными данными, для повторного вызова, в случае окончания времени ключа сессии.
					ПараметрыМетода = Новый Массив;
					ПараметрыМетода.Добавить(НомераУпаковок);
					ПараметрыМетода.Добавить(АдресХранения);
					ПараметрыМетода.Добавить(Данные);
					Результат.Вставить("ПараметрыМетода", ПараметрыМетода);
				КонецЕсли;
				Возврат Результат;
			КонецЕсли;
			ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(Данные.ТранспортныеУпаковки, Результат.Данные, Истина);
			
			Для Каждого НомерУпаковки Из НомераТранспортныхУпаковок Цикл
				НомераУпаковок.Удалить(НомераУпаковок.Найти(НомерУпаковки));
			КонецЦикла;
			
		КонецЕсли;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		
		Если АдресХранения <> Неопределено Тогда
			Результат.Вставить("Данные", ПоместитьВоВременноеХранилище(Данные, АдресХранения));
		Иначе
			Результат.Вставить("Данные", Данные);
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьИнформациюОКИЗ(ПараметрыПодключения, КИЗ) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИнформациюОКИЗ", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(КИЗ));
	#Иначе
		
		ВремяОжидания = 10000;
		
		Если ТипЗнч(КИЗ) <> Тип("Массив") Тогда
			СписокКИЗ = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(КИЗ);
		Иначе
			СписокКИЗ = КИЗ;
		КонецЕсли;
		
		ДанныеКИЗ = Новый Соответствие;
		ЗапрашиваемыеДанные = Новый Массив;
		МаксимальноеКоличествоВОдномЗапросе = 500;
		
		ВсегоНомеров = СписокКИЗ.ВГраница() + 1;
		Для Сч = 1 По ВсегоНомеров Цикл
			
			ЗапрашиваемыеДанные.Добавить(СписокКИЗ[Сч - 1]);
			Если Сч % МаксимальноеКоличествоВОдномЗапросе = 0 Или Сч = ВсегоНомеров Тогда
				
				ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
				ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/sgtins-by-list";
				ТелоЗапроса = Новый Структура;
				ТелоЗапроса.Вставить("filter", Новый Структура("sgtins", ЗапрашиваемыеДанные));
				ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
				
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
					НомерПопытки = 1;
					Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ВремяОжидания, НомерПопытки) Цикл
						Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
					КонецЦикла;
				КонецЕсли;
				Если Результат.Статус = "Ошибка" Тогда
					Возврат Результат;
				КонецЕсли;
				
				НайденныеКИЗ = Результат.Данные["entries"];
				Если ЗначениеЗаполнено(НайденныеКИЗ) Тогда
					Для Каждого НайденныйКИЗ Из НайденныеКИЗ Цикл
						ДанныеКИЗ.Вставить(НайденныйКИЗ["sgtin"], НайденныйКИЗ);
					КонецЦикла;
				КонецЕсли;
				
				ОшибочныеКИЗ = Результат.Данные["failed_entries"];
				Если ЗначениеЗаполнено(ОшибочныеКИЗ) Тогда
					Для Каждого ОшибочныйКИЗ Из ОшибочныеКИЗ Цикл
						ДанныеКИЗ.Вставить(ОшибочныйКИЗ["sgtin"], ОшибочныйКИЗ);
					КонецЦикла;
				КонецЕсли;
				
				ЗапрашиваемыеДанные.Очистить();
				
				Если Сч < ВсегоНомеров Тогда
					Таймаут(ВремяОжидания);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", ДанныеКИЗ);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьСоставУпаковки(ПараметрыПодключения, НомерУпаковки) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСоставУпаковки", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(НомерУпаковки));
	#Иначе
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/" + НомерУпаковки + "/hierarchy";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			ТаймаутМеждуЗапросами = 20000;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		ВремяОжидания = 20000;
		
		ДанныеУпаковки = Новый Соответствие;
		ДанныеУпаковки.Вставить("sscc", НомерУпаковки);
		ДанныеУпаковки.Вставить("tree", Новый Массив);
		
		Данные = Результат.Данные;
		Состав = Данные["down"];
		Если Данные["error_code"] <> Неопределено Тогда
			
			ДанныеУпаковки.Вставить("error_code", Данные["error_code"]);
			ДанныеУпаковки.Вставить("error_desc", Данные["error_desc"]);
			
		ИначеЕсли Состав.Количество() = 1 Тогда
			ДанныеУпаковки.Вставить("release_date", Состав[0]["release_date"]);
			ДанныеУпаковки.Вставить("system_subj_id", Состав[0]["system_subj_id"]);
			
			ДанныеЗапросаУпаковок = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
			ДанныеЗапросаУпаковок.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/" + НомерУпаковки + "/sgtins";
			ТелоЗапроса = Новый Структура("sscc", НомерУпаковки);
			Таймаут(ВремяОжидания);
			Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапросаУпаковок, ТелоЗапроса,,, ВремяОжидания);
			Если Результат.Статус = "Ошибка" Тогда
				Возврат Результат;
			КонецЕсли;
			
			ДанныеУпаковки["tree"] = Результат.Список;
			Если Результат.ДополнительныеПоля["error_code"] <> Неопределено Тогда
				ДанныеУпаковки.Вставить("error_code", Результат.ДополнительныеПоля["error_code"]);
				ДанныеУпаковки.Вставить("error_desc", Результат.ДополнительныеПоля["error_desc"]);
			КонецЕсли;
		Иначе
			Для Каждого ВложеннаяУпаковка Из Состав Цикл
				НомерВложеннойУпаковки = ВложеннаяУпаковка["sscc"];
				Если ВложеннаяУпаковка["sscc"] = НомерУпаковки Тогда
					ДанныеУпаковки.Вставить("release_date", Состав[0]["release_date"]);
					ДанныеУпаковки.Вставить("system_subj_id", Состав[0]["system_subj_id"]);
					Продолжить;
				КонецЕсли;
				
				Таймаут(ВремяОжидания);
				Результат = ПолучитьСоставУпаковки(ПараметрыПодключения, НомерВложеннойУпаковки);
				Если Результат.Статус = "Ошибка" Тогда
					Возврат Результат;
				КонецЕсли;
				
				ДанныеУпаковки["tree"].Добавить(Результат.Данные);
			КонецЦикла;
		КонецЕсли;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", ДанныеУпаковки);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьПолныйСоставУпаковок(ПараметрыПодключения, НомераУпаковок) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьПолныйСоставУпаковок", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(НомераУпаковок));
	#Иначе
		
		ДанныеУпаковок = Новый Соответствие;
		
		РазмерПорции = 10; // Количество запрашиваемых номеров упаковок не может превышать 10.
		ТаймаутМеждуЗапросами = 30000; // Вызов метода доступен не чаще чем раз в 30 секунд.
		
		РабочиеНомераУпаковок = Новый Массив;
		Для Каждого НомерУпаковки Из НомераУпаковок Цикл
			ДанныеУпаковок.Вставить(НомерУпаковки, Новый Соответствие);
			Если РабочиеНомераУпаковок.Найти(НомерУпаковки) = Неопределено Тогда
				РабочиеНомераУпаковок.Добавить(НомерУпаковки);
			КонецЕсли;
		КонецЦикла;
		
		Пока РабочиеНомераУпаковок.Количество() > 0 Цикл
			
			ПорцияНомеровУпаковок = Новый Массив;
			Граница = Мин(РабочиеНомераУпаковок.Количество(), РазмерПорции) - 1;
			Для Индекс = 0 По Граница Цикл
				ПорцияНомеровУпаковок.Добавить(РабочиеНомераУпаковок[0]);
				РабочиеНомераУпаковок.Удалить(0);
			КонецЦикла;
			
			ПараметрыЗапроса = "?sscc=" + СтрСоединить(ПорцияНомеровУпаковок, "&sscc=");
			
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/full-hierarchy" + ПараметрыЗапроса;
			
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если Результат.Статус = "Ошибка" Тогда
				Возврат Результат;
			КонецЕсли;
			
			ОчередьВложенныхУпаковок      = Новый Массив;
			ДанныеПотребительскихУпаковок = Новый Массив;
			НомераПотребительскихУпаковок = Новый Массив;
			ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок = Новый Соответствие;
			
			Данные = Результат.Данные;
			Для Каждого Элемент Из Данные Цикл
				
				Состав = Элемент["down"];
				
				// Для обратной совместимости коллекция childs дублируется в коллекцию tree на каждом уровне иерархии.
				Состав.Вставить("tree", Состав["childs"]);
				
				ДанныеУпаковок.Вставить(Состав["sscc"], Состав);
				
				ОчередьВложенныхУпаковок.Добавить(Состав);
				Пока ОчередьВложенныхУпаковок.Количество() > 0 Цикл
					
					ТекущиеДанныеУпаковки = ОчередьВложенныхУпаковок[0];
					ОчередьВложенныхУпаковок.Удалить(0);
					
					ВложенныеУпаковки = ТекущиеДанныеУпаковки["tree"];
					Если Не ЗначениеЗаполнено(ВложенныеУпаковки) Тогда
						Продолжить;
					КонецЕсли;
					
					Для Каждого ВложеннаяУпаковка Из ВложенныеУпаковки Цикл
						
						Если ВложеннаяУпаковка["childs"] <> Неопределено Тогда
							ВложеннаяУпаковка.Вставить("tree", ВложеннаяУпаковка["childs"]);
							ОчередьВложенныхУпаковок.Добавить(ВложеннаяУпаковка);
							ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок.Вставить(ВложеннаяУпаковка["sscc"], ТекущиеДанныеУпаковки);
						Иначе
							
							НомерПотребительскойУпаковки = ВложеннаяУпаковка["sgtin"];
							Если Не ЗначениеЗаполнено(НомерПотребительскойУпаковки) Тогда
								Продолжить;
							КонецЕсли;
							
							ДанныеПотребительскихУпаковок.Добавить(ВложеннаяУпаковка);
							НомераПотребительскихУпаковок.Добавить(НомерПотребительскойУпаковки);
							ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок.Вставить(НомерПотребительскойУпаковки, ТекущиеДанныеУпаковки);
							
						КонецЕсли;
						
					КонецЦикла;
				КонецЦикла;
				
			КонецЦикла;
			
			// Таймаут в случае, когда перед получением информации о транспортных упаковках был запрос информации о потребительских упаковках.
			ТаймаутМеждуПолучениемИнформацииОКИЗ = 5000;
			Таймаут(ТаймаутМеждуПолучениемИнформацииОКИЗ);
			
			РезультатПолученияПотребительскихУпаковок = ПолучитьИнформациюОКИЗ(ПараметрыПодключения, НомераПотребительскихУпаковок);
			Если РезультатПолученияПотребительскихУпаковок.Статус = "Ошибка" Тогда
				Возврат РезультатПолученияПотребительскихУпаковок;
			КонецЕсли;
			
			// После того, как получили полные данные потребительских упаковок, необходимо ими актуализировать иерархию, на соответствующих уровнях.
			// Т.к. в массиве ДанныеПотребительскихУпаковок находятся ссылки на элементы соответствия ДанныеУпаковок,
			// изменения данных массива ДанныеПотребительскихУпаковок приведет к изменению соответствия ДанныеУпаковок.
			Для Каждого ДанныеПотребительскойУпаковки Из ДанныеПотребительскихУпаковок Цикл
				
				НомерПотребительскойУпаковки = ДанныеПотребительскойУпаковки["sgtin"];
				
				НовыеДанныеПотребительскойУпаковки = РезультатПолученияПотребительскихУпаковок.Данные[НомерПотребительскойУпаковки];
				Если НовыеДанныеПотребительскойУпаковки = Неопределено Тогда
					// Эмулируем поведение для обратной совместимости.
					НовыеДанныеПотребительскойУпаковки = Новый Соответствие;
					НовыеДанныеПотребительскойУпаковки.Вставить("sgtin"     , НомерПотребительскойУпаковки);
					НовыеДанныеПотребительскойУпаковки.Вставить("tree"      , Новый Массив);
					НовыеДанныеПотребительскойУпаковки.Вставить("error_code", 2);
					НовыеДанныеПотребительскойУпаковки.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
				КонецЕсли;
				
				Для Каждого КлючИЗначение Из НовыеДанныеПотребительскойУпаковки Цикл
					ДанныеПотребительскойУпаковки.Вставить(КлючИЗначение.Ключ, КлючИЗначение.Значение);
				КонецЦикла;
				
				// Если есть ошибки в данных вложенных упаковок, запишем ошибки родителям.
				// Т.к. в ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок находятся ссылки на элементы соответствия ДанныеУпаковок,
				// изменения данных ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок приведет к изменению соответствия ДанныеУпаковок.
				Если ДанныеПотребительскойУпаковки["error_code"] <> Неопределено Тогда
					Родитель = ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок[НомерПотребительскойУпаковки];
					Пока Родитель <> Неопределено Цикл
						Родитель.Вставить("error_code", ДанныеПотребительскойУпаковки["error_code"]);
						Родитель.Вставить("error_desc", ДанныеПотребительскойУпаковки["error_desc"]);
						Родитель = ДанныеЗапрашиваемыхРодителейПотребительскихУпаковок[Родитель["sscc"]];
					КонецЦикла;
				КонецЕсли;
				
			КонецЦикла;
			
			Если РабочиеНомераУпаковок.Количество() > 0 Тогда
				Таймаут(ТаймаутМеждуЗапросами);
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого КлючИЗначение Из ДанныеУпаковок Цикл
			Если Не ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
				// Эмулируем поведение для обратной совместимости.
				КлючИЗначение.Значение.Вставить("sscc"      , КлючИЗначение.Ключ);
				КлючИЗначение.Значение.Вставить("tree"      , Новый Массив);
				КлючИЗначение.Значение.Вставить("error_code", 2);
				КлючИЗначение.Значение.Вставить("error_desc", НСтр("ru = 'Запрашиваемые данные не найдены'"));
			КонецЕсли;
		КонецЦикла;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", ДанныеУпаковок);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьИерархиюУпаковок(ПараметрыПодключения, НомераУпаковок) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьИерархиюУпаковок", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(НомераУпаковок));
	#Иначе
		
		ТаймаутМеждуЗапросами = 20000;
		ДанныеУпаковок = Новый Массив;
		
		Для Каждого НомерУпаковки Из НомераУпаковок Цикл
			ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
			ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/" + НомерУпаковки + "/hierarchy";
			
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
				НомерПопытки = 1;
				Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
					Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
				КонецЦикла;
			КонецЕсли;
			Если Результат.Статус = "Ошибка" Тогда
				Возврат Результат;
			КонецЕсли;
			
			ДанныеУпаковки = Новый Соответствие;
			ДанныеУпаковки.Вставить("sscc", НомерУпаковки);
			ДанныеУпаковки.Вставить("up", Новый Массив);
			ДанныеУпаковки.Вставить("down", Новый Массив);
			
			Данные = Результат.Данные;
			ВерхнеуровневыеУпаковки = Данные["up"];
			ВложеныеУпаковки = Данные["down"];
			Если Данные["error_code"] <> Неопределено Тогда
				ДанныеУпаковки.Вставить("error_code", Данные["error_code"]);
				ДанныеУпаковки.Вставить("error_desc", Данные["error_desc"]);
			Иначе
				Для Каждого ВерхняяУпаковка Из ВерхнеуровневыеУпаковки Цикл
					Если ВерхняяУпаковка["sscc"] <> НомерУпаковки Тогда
						ДанныеУпаковки["up"].Добавить(ВерхняяУпаковка);
					КонецЕсли;
				КонецЦикла;
				Для Каждого ВложеннаяУпаковка Из ВложеныеУпаковки Цикл
					Если ВложеннаяУпаковка["sscc"] = НомерУпаковки Тогда
						ДанныеУпаковки.Вставить("release_date", ВложеннаяУпаковка["release_date"]);
						ДанныеУпаковки.Вставить("system_subj_id", ВложеннаяУпаковка["system_subj_id"]);
					Иначе
						ДанныеУпаковки["down"].Добавить(ВложеннаяУпаковка);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			ДанныеУпаковок.Добавить(ДанныеУпаковки);
			Таймаут(ТаймаутМеждуЗапросами);
		КонецЦикла;
		
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Вставить("Данные", ДанныеУпаковок);
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьПолнуюИерархиюУпаковки(ПараметрыПодключения, НомерУпаковки) Экспорт
	
	// Вызов метода доступен не чаще чем раз в 30 секунд. См. Протокол обмена интерфейсного уровня МДЛП.
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьПолнуюИерархиюУпаковки", НомерУпаковки);
	#Иначе
		
		ТаймаутМеждуЗапросами = 30000;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/" + НомерУпаковки + "/full-hierarchy";
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат.Вставить("ГраницаТаймаута", ПолучитьТекущуюДатуСеанса() + 30);
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьПолнуюИерархиюНесколькихУпаковок(ПараметрыПодключения, НомераУпаковок) Экспорт
	
	// Вызов метода доступен не чаще чем раз в 30 секунд.
	// Количество запрашиваемых номеров упаковок не может превышать 10.
	// См. Протокол обмена интерфейсного уровня МДЛП.
	
	#Если ВебКлиент Тогда
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьПолнуюИерархиюНесколькихУпаковок", ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(НомераУпаковок));
	#Иначе
		
		ТаймаутМеждуЗапросами = 30000;
		
		ПараметрыЗапроса = "?sscc=" + СтрСоединить(НомераУпаковок, "&sscc=");
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sscc/full-hierarchy" + ПараметрыЗапроса;
		
		Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
			НомерПопытки = 1;
			Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
				Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
			КонецЦикла;
		КонецЕсли;
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Результат.Вставить("ГраницаТаймаута", ПолучитьТекущуюДатуСеанса() + 30);
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

Функция ПолучитьСписокПотребительскихУпаковокМестаДеятельности(ПараметрыПодключения, ИдентификаторМестаХранения, Отбор = Неопределено, Знач НачальныйИндекс = 0, Знач МаксимальноеКоличествоДокументов = Неопределено) Экспорт
	
	#Если ВебКлиент Тогда
		ПараметрыМетода = Новый Массив;
		ПараметрыМетода.Добавить(ИдентификаторМестаХранения);
		ПараметрыМетода.Добавить(Отбор);
		ПараметрыМетода.Добавить(НачальныйИндекс);
		ПараметрыМетода.Добавить(МаксимальноеКоличествоДокументов);
		Возврат ТранспортМДЛПАПИВызовСервера.ВыполнитьМетодАПИ(ПараметрыПодключения, "ПолучитьСписокПотребительскихУпаковокМестаДеятельности", ПараметрыМетода);
	#Иначе
		
		ТаймаутМеждуЗапросами = 5000;
		
		ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
		ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "reestr/sgtin/filter";
		
		Фильтр = Новый Структура;
		Фильтр.Вставить("sys_id", ИдентификаторМестаХранения);
		Если Отбор <> Неопределено Тогда
			ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(Фильтр, Отбор);
		КонецЕсли;
		
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("filter", Фильтр);
		
		Результат = ПолучитьСписокОбъектов(ПараметрыПодключения, ДанныеЗапроса, ТелоЗапроса, НачальныйИндекс, МаксимальноеКоличествоДокументов, ТаймаутМеждуЗапросами);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Возврат Результат;
		
	#КонецЕсли
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Если Не ВебКлиент Тогда

#Область РаботаССообщениями

Функция ОтправитьТекстСообщения(ТранспортныйМодуль, Сообщение) Экспорт
	
	Если Не ТранспортныйМодуль.Свойство("ОграничениеРазмераНебольшихДокументов") Тогда
		Результат = ПолучитьОграничениеРазмераНебольшихДокументов(ТранспортныйМодуль);
		Если Результат.Статус = "Ошибка" Тогда
			Если Результат.ТребуетсяАвторизация Тогда
				Возврат Результат;
			Иначе
				ТранспортныйМодуль.Вставить("ОграничениеРазмераНебольшихДокументов", 1048576); // 1 Мб
			КонецЕсли;
		Иначе
			ТранспортныйМодуль.Вставить("ОграничениеРазмераНебольшихДокументов", Результат.ОграничениеРазмераНебольшихДокументов);
		КонецЕсли;
	КонецЕсли;
	
	Если Сообщение.Размер > ТранспортныйМодуль.ОграничениеРазмераНебольшихДокументов Тогда
		РезультатОтправки = ОтправитьСообщениеБольшогоРазмера(ТранспортныйМодуль, Сообщение);
	Иначе
		РезультатОтправки = ОтправитьСообщениеУпрощенно(ТранспортныйМодуль, Сообщение);
	КонецЕсли;
	
	Возврат РезультатОтправки;
	
КонецФункции

Функция ОтправитьСообщениеУпрощенно(ТранспортныйМодуль, Сообщение)
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
	ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/send";
	
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("doc_type"  , Сообщение.КодОперации);
	ТелоЗапроса.Вставить("document"  , Base64Строка(ПолучитьДвоичныеДанныеИзСтроки(Сообщение.ТекстСообщения)));
	Если ЗначениеЗаполнено(Сообщение.Подпись) Тогда
		ТелоЗапроса.Вставить("sign", Сообщение.Подпись);
	КонецЕсли;
	ТелоЗапроса.Вставить("request_id", Сообщение.ИдентификаторЗапроса);
	
	ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
	
	Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
	
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	
	Если Результат.Статус <> "Ошибка" Тогда
		Результат.Вставить("ИдентификаторЗапроса"  , Сообщение.ИдентификаторЗапроса);
		Результат.Вставить("ИдентификаторДокумента", Результат.Данные["document_id"]);
	ИначеЕсли Результат.КодОшибки = 504 Тогда
		
		// Проверка обработки отправленного сообщения, в случае когда сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера для завершения текущего запроса.
		КоличествоЗапросов = 3;
		ТаймаутМеждуЗапросами = 3000;
		Для Счетчик = 1 По КоличествоЗапросов Цикл
			
			// После отправки документа первый запрос на получение его статуса рекомендуется выполнять не раньше, чем через 3 секунды.
			// https://честныйзнак.рф/upload/Rekomendacii_po_rabote_s_API_i_dokumentami_MDLP.pdf
			Таймаут(ТаймаутМеждуЗапросами);
			
			РезультатПроверки = ПолучитьИдентификаторДокументаПоИдентификаторуЗапроса(ТранспортныйМодуль, Сообщение.ИдентификаторЗапроса);
			Если РезультатПроверки.Статус <> "Ошибка" И ЗначениеЗаполнено(РезультатПроверки.ИдентификаторДокумента) Тогда
				
				Данные = Новый Соответствие;
				Данные.Вставить("document_id", РезультатПроверки.ИдентификаторДокумента);
				
				Результат = РезультатПроверки;
				Результат.Вставить("Данные"                  , Данные);
				Результат.Вставить("ОтветТранспортногоМодуля", ТранспортМДЛПКлиентСервер.ПреобразоватьЗначениеВJSON(Данные));
				Результат.Вставить("ИдентификаторЗапроса"    , Сообщение.ИдентификаторЗапроса);
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ОтправитьСообщениеБольшогоРазмера(ТранспортныйМодуль, Сообщение)
	
	Результат = НачатьОтправкуСообщенияБольшогоРазмера(ТранспортныйМодуль, Сообщение, Сообщение.ИдентификаторЗапроса);
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	Ответ = Результат.Ответ;
	ИдентификаторДокумента = Результат.ИдентификаторДокумента;
	
	Результат = ПередатьСообщениеБольшогоРазмера(ТранспортныйМодуль, Сообщение, Результат.Ссылка);
	Если Результат.Статус = "Ошибка" Тогда
		Если Не Результат.ТребуетсяАвторизация Тогда
			ОтменитьОтправкуСообщенияБольшогоРазмера(ТранспортныйМодуль, ИдентификаторДокумента, Сообщение.ИдентификаторЗапроса);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	Результат = ЗавершитьОтправкуСообщенияБольшогоРазмера(ТранспортныйМодуль, ИдентификаторДокумента);
	Если Результат.Статус = "Ошибка" Тогда
		Если Не Результат.ТребуетсяАвторизация Тогда
			ОтменитьОтправкуСообщенияБольшогоРазмера(ТранспортныйМодуль, ИдентификаторДокумента, Сообщение.ИдентификаторЗапроса);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	
	Результат.Вставить("ИдентификаторДокумента"  , ИдентификаторДокумента);
	Результат.Вставить("ОтветТранспортногоМодуля", Ответ);
	Возврат Результат
	
КонецФункции

Функция НачатьОтправкуСообщенияБольшогоРазмера(ПараметрыПодключения, Сообщение, ИдентификаторЗапроса)
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
	ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "documents/send_large";
	
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("doc_type"  , Сообщение.КодОперации);
	ТелоЗапроса.Вставить("hash_sum"  , Сообщение.ХешСумма);
	Если ЗначениеЗаполнено(Сообщение.Подпись) Тогда
		ТелоЗапроса.Вставить("sign", Сообщение.Подпись);
	КонецЕсли;
	ТелоЗапроса.Вставить("request_id", ИдентификаторЗапроса);
	
	ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
	
	РезультатЗапроса = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
	Если РезультатЗапроса.Статус = "Ошибка" И РезультатЗапроса.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(РезультатЗапроса, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			РезультатЗапроса = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	Если РезультатЗапроса.Статус = "Ошибка" Тогда
		Возврат РезультатЗапроса;
	КонецЕсли;
	
	Данные = РезультатЗапроса.Данные;
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	Результат.Вставить("Ссылка", Данные["link"]);
	Результат.Вставить("ИдентификаторДокумента", Данные["document_id"]);
	Результат.Вставить("Ответ", РезультатЗапроса.ОтветТранспортногоМодуля);
	
	Возврат Результат;
	
КонецФункции

Функция ПередатьСообщениеБольшогоРазмера(ПараметрыПодключения, Сообщение, Ссылка)
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	
	ПараметрыЗагрузки = ОбщегоНазначенияКлиентСервер.СтруктураURI(Ссылка);
	Транспорт = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ПараметрыПодключения);
	Транспорт.Адрес = ПараметрыЗагрузки.Хост;
	Транспорт.Порт = ПараметрыЗагрузки.Порт;
	Если ПараметрыЗагрузки.Схема = "https" Тогда
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Транспорт, "ЗащищенноеСоединение", Ложь);
		Если ЗащищенноеСоединение = Ложь Тогда
			Транспорт.Вставить("ЗащищенноеСоединение", Истина);
		КонецЕсли;
	Иначе
		Транспорт.Вставить("ЗащищенноеСоединение", Ложь);
	КонецЕсли;
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("PUT");
	ДанныеЗапроса.АдресЗапроса = ПараметрыЗагрузки.ПутьНаСервере;
	ДанныеЗапроса.Заголовки.Вставить("Content-Type"    , "application/xml");
	ДанныеЗапроса.Заголовки.Вставить("Content-Encoding", "gzip");
	
	ДанныеЗапроса.ТелоЗапроса = Сообщение.ТекстСообщения;
	Транспорт.Таймаут = ТаймаутПоРазмеруФайла(Сообщение.Размер);
	
	Возврат ВыполнитьАвторизованныйЗапрос(Транспорт, ДанныеЗапроса);
	
КонецФункции

Функция ЗавершитьОтправкуСообщенияБольшогоРазмера(ПараметрыПодключения, ИдентификаторДокумента)
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
	ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "documents/send_finished";
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("document_id", ИдентификаторДокумента);
	
	ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
	
	Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	Данные = Результат.Данные;
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	Результат.Вставить("ИдентификаторЗапроса", Данные["request_id"]);
	
	Возврат Результат;
	
КонецФункции

Функция ОтменитьОтправкуСообщенияБольшогоРазмера(ПараметрыПодключения, ИдентификаторДокумента, ИдентификаторЗапроса) Экспорт
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
	ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "documents/cancel";
	
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("document_id", ИдентификаторДокумента);
	ТелоЗапроса.Вставить("request_id" , ИдентификаторЗапроса);
	
	ДанныеЗапроса.ТелоЗапроса = ТелоЗапроса;
	
	Возврат ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
	
КонецФункции

Функция ПолучитьКвитанцииИсходящегоЗапроса(ПараметрыПодключения, ИдентификаторЗапроса, ПараметрыВыполненияОбмена = Неопределено) Экспорт
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "documents/request/" + ИдентификаторЗапроса;
	
	Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	Данные = Результат.Данные;
	
	КодыОперацийКвитанций = КодыОперацийКвитанций();
	КодыОперацийПолученияИнформацииОбУпаковках = КодыОперацийПолученияИнформацииОбУпаковках();
	КодыОперацийВходящихУведомлений = КодыОперацийВходящихУведомлений();
	
	Квитанции = Новый Массив;
	
	Если Данные["total"] = 1 Тогда
		
		Документ = Данные["documents"][0];
		Если Документ["doc_status"] = "FAILED" Тогда
			ТекущаяДата = ПолучитьТекущуюУниверсальнуюДату();
			Если СтрокаВДату(Документ["date"]) < ТекущаяДата Тогда // Ожидание описания ошибки не более 3 часов. Так как в МДЛП дата по Москве, то как раз и получается 3 часа.
				ТекстОшибки = "FAILED";
				ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Произошла ошибка во время разбора документа: %1'"), ТекстОшибки);
				Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", ТекстСообщения, НСтр("ru = 'Обработка документа'")));
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли Данные["total"] > 1 Тогда
		
		// Определяем действие пользователя. Возможно, выполняется операция по получению данных только квитанции.
		// В этом случае необходимо получить полные данные квитанции.
		ДальнейшееДействие = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ПараметрыВыполненияОбмена, "ДальнейшееДействие");
		ЭтоОперацияПолученияКвитанции = ДальнейшееДействие = ПредопределенноеЗначение("Перечисление.ДальнейшиеДействияПоВзаимодействиюМДЛП.ПолучитеКвитанциюОФиксации");
		
		Для Каждого Документ Из Данные["documents"] Цикл
			
			ТипДокумента = Документ["doc_type"];
			
			Если КодыОперацийКвитанций.Найти(ТипДокумента) <> Неопределено Или КодыОперацийВходящихУведомлений.Найти(ТипДокумента) <> Неопределено Тогда
				// Квитанции пропускаем, т.к. получать данные квитанции по ее идентификатору - ненадежно.
				// При наличии технических ошибок на стороне сервера, в поле document_id квитанции может быть записан идентификатор самого документа, а не квитанции.
				// Так же пропускаем входящие уведомления, если грузоотправитель и грузополучатель - один и тот же участник оборота.
				Продолжить;
			КонецЕсли;
			
			СтатусДокумента = Документ["doc_status"];
			Если СтатусДокумента = "PROCESSED_DOCUMENT" Или СтатусДокумента = "FAILED_RESULT_READY" Тогда
				
				СтатусОбработкиДокумента = Документ["processing_document_status"];
				Если Не ЭтоОперацияПолученияКвитанции И СтатусОбработкиДокумента = "ACCEPTED" И КодыОперацийПолученияИнформацииОбУпаковках.Найти(ТипДокумента) = Неопределено Тогда
					
					Результат = СформироватьУспешнуюКвитанциюДокумента(ТипДокумента, Документ["request_id"], СтрокаВДату(Документ["date"]));
					
					Если Результат.Статус = "Ошибка" Тогда
						ТекстОшибки = "FAILED";
						ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Произошла ошибка во время разбора документа: %1'"), ТекстОшибки);
						Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", ТекстСообщения, НСтр("ru = 'Обработка документа'")));
					Иначе
						
						Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", Результат.ТекстСообщения, ТипДокумента));
						
					КонецЕсли;
					
				Иначе
					
					// Запрос на получение квитанции после того, как статус документа изменился, рекомендуется выполнять не раньше, чем через 5 секунд после получения данного статуса документа.
					// https://честныйзнак.рф/upload/Rekomendacii_po_rabote_s_API_i_dokumentami_MDLP.pdf
					ДатаОбработкиДокумента = СтрокаВДату(Документ["processed_date"]) - 10800; // В МДЛП дата по Москве (+10800 секунд). Нужно привести к универсальной дате.
					ОжидатьПриНеобходимости(ДатаОбработкиДокумента, 5000);
					
					//// Выполним три попытки получения квитанции.
					//Для Счетчик = 1 По 3 Цикл
					//	// Для получения данных квитанции используем метод получения квитанции по идентификатору документа.
					//	Результат = ЗагрузитьКвитанциюДокумента(ПараметрыПодключения, Документ["document_id"]);
					//	Если Результат.Статус = "Ошибка" И Не Результат.ТребуетсяАвторизация И Не Результат.НедостаточноПрав Тогда
					//		// Если при запросе квитанции, квитанция отсутствует, рекомендуется использовать постепенно увеличивающиеся интервалы между запросами или повторные запросы с единым шагом не менее 15 секунд.
					//		// https://честныйзнак.рф/upload/Rekomendacii_po_rabote_s_API_i_dokumentami_MDLP.pdf
					//		ОжидатьПриНеобходимости(ДатаОбработкиДокумента, 15000);
					//	Иначе
					//		Прервать;
					//	КонецЕсли;
					//КонецЦикла;
					
					// На текущий момент следовать реккомендациям ЦРПТ, касательно повторного выполнения запросов с таймаутом в 15 секунд, не будем,
					// т.к. пользователь самостоятельно (по кнопке) вызывает обработку получения квитанций документа.
					Результат = ЗагрузитьКвитанциюДокумента(ПараметрыПодключения, Документ["document_id"]);
					
					Если Результат.Статус = "Ошибка" Тогда
						Если СтатусДокумента <> "PROCESSED_DOCUMENT" И Не Результат.ТребуетсяАвторизация И Не Результат.НедостаточноПрав Тогда
							ТекстОшибки = "FAILED";
							ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Произошла ошибка во время разбора документа: %1'"), ТекстОшибки);
							Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", ТекстСообщения, НСтр("ru = 'Обработка документа'")));
						Иначе
							Возврат Результат;
						КонецЕсли;
					Иначе
						
						Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", Результат.ТекстСообщения, ТипДокумента));
						
					КонецЕсли;
					
				КонецЕсли;
				
			ИначеЕсли СтатусДокумента = "FAILED" Тогда
				ТекущаяДата = ПолучитьТекущуюУниверсальнуюДату();
				Если СтрокаВДату(Документ["date"]) < ТекущаяДата Тогда // Ожидание описания ошибки не более 3 часов. Так как в МДЛП дата по Москве, то как раз и получается 3 часа.
					ТекстОшибки = "FAILED";
					ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Произошла ошибка во время разбора документа: %1'"), ТекстОшибки);
					Квитанции.Добавить(Новый Структура("ТекстСообщения, ТипДокумента", ТекстСообщения, НСтр("ru = 'Обработка документа'")));
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	Результат.Вставить("Квитанции", Квитанции);
	Возврат Результат;
	
КонецФункции

Функция ЗагрузитьДокумент(ТранспортныйМодуль, ИдентификаторДокумента) Экспорт
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/download/" + ИдентификаторДокумента;
	
	Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
	
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	СсылкаДляСкачивания = Результат.Данные["link"];
	Возврат ЗагрузитьДокументПоСсылке(ТранспортныйМодуль, СсылкаДляСкачивания);
	
КонецФункции

Функция ЗагрузитьКвитанциюДокумента(ТранспортныйМодуль, ИдентификаторДокумента) Экспорт
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/" + ИдентификаторДокумента + "/ticket";
	
	Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
	
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ТранспортныйМодуль, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	СсылкаДляСкачивания = Результат.Данные["link"];
	Возврат ЗагрузитьДокументПоСсылке(ТранспортныйМодуль, СсылкаДляСкачивания);
	
КонецФункции

Функция СформироватьУспешнуюКвитанциюДокумента(ТипДокумента, ИдентификаторЗапроса, ДатаДокумента)
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	Результат.Вставить("ТекстСообщения", ТранспортМДЛПАПИВызовСервера.СформироватьТекстУспешнойКвитанцииДокумента(ТипДокумента, ИдентификаторЗапроса, ДатаДокумента));
	
	Возврат Результат;
	
КонецФункции

Функция ЗагрузитьДокументПоСсылке(ТранспортныйМодуль, СсылкаДляСкачивания);
	
	ПараметрыЗагрузки = ОбщегоНазначенияКлиентСервер.СтруктураURI(СсылкаДляСкачивания);
	Транспорт = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ТранспортныйМодуль);
	Транспорт.Адрес = ПараметрыЗагрузки.Хост;
	Транспорт.Порт = ПараметрыЗагрузки.Порт;
	Если ПараметрыЗагрузки.Схема = "https" Тогда
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Транспорт, "ЗащищенноеСоединение", Ложь);
		Если ЗащищенноеСоединение = Ложь Тогда
			Транспорт.Вставить("ЗащищенноеСоединение", Истина);
		КонецЕсли;
	Иначе
		Транспорт.Вставить("ЗащищенноеСоединение", Ложь);
	КонецЕсли;
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = "/" + ПараметрыЗагрузки.ПутьНаСервере;
	
	Результат = ВыполнитьАвторизованныйЗапрос(Транспорт, ДанныеЗапроса);
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(Транспорт, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	
	Если Результат.Статус <> "Ошибка" Тогда
		Результат.Вставить("ТекстСообщения", Результат.ОтветТранспортногоМодуля);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИдентификаторДокументаПоИдентификаторуЗапроса(ПараметрыПодключения, ИдентификаторЗапроса)
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("GET");
	ДанныеЗапроса.АдресЗапроса = ПараметрыПодключения.ПрефиксВерсии + "documents/request/" + ИдентификаторЗапроса;
	
	Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		НомерПопытки = 1;
		ТаймаутМеждуЗапросами = 500;
		Пока ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки) Цикл
			Результат = ВыполнитьАвторизованныйЗапрос(ПараметрыПодключения, ДанныеЗапроса);
		КонецЦикла;
	КонецЕсли;
	Если Результат.Статус = "Ошибка" Тогда
		Возврат Результат;
	КонецЕсли;
	
	Данные = Результат.Данные;
	
	КодыОперацийКвитанций = КодыОперацийКвитанций();
	
	ИдентификаторДокумента = Неопределено;
	Если Данные["total"] > 0 Тогда
		Для Каждого Документ Из Данные["documents"] Цикл
			Если КодыОперацийКвитанций.Найти(Документ["doc_type"]) = Неопределено Тогда
				ИдентификаторДокумента = Документ["document_id"];
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	Результат.Вставить("ИдентификаторДокумента", ИдентификаторДокумента);
	Возврат Результат;
	
КонецФункции

#КонецОбласти

Функция ОбработатьОчередьПолученияКвитанций(ТранспортныйМодуль, ПараметрыВыполненияОбмена = Неопределено)
	
	Данные = ТранспортМДЛПАПИВызовСервера.ПолучитьДанныеСообщенийОжидающихКвитанции(ТранспортныйМодуль.ИдентификаторОрганизации, ПараметрыВыполненияОбмена);
	Для Каждого Сообщение Из Данные Цикл
		
		Результат = ОбработатьРезультатОтправкиСообщения(ТранспортныйМодуль, Сообщение, ПараметрыВыполненияОбмена);
		Если Результат.Статус = "Ошибка" Тогда
			Если Результат.ТребуетсяАвторизация Тогда
				Возврат Результат;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	
КонецФункции

Функция ОбработатьРезультатОтправкиСообщения(ТранспортныйМодуль, Сообщение, ПараметрыВыполненияОбмена = Неопределено)
	
	Попытка
		
		Результат = ПолучитьКвитанцииИсходящегоЗапроса(ТранспортныйМодуль, Сообщение.ИдентификаторЗапроса, ПараметрыВыполненияОбмена);
		Если Результат.Статус = "Ошибка" Тогда
			Возврат Результат;
		КонецЕсли;
		
		Если Результат.Квитанции.Количество() > 0 Тогда
			ТранспортМДЛПАПИВызовСервера.ЗарегистрироватьКвитанцииСообщения(Сообщение, Результат.Квитанции);
		КонецЕсли;
		
	Исключение
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;
	
	Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	
КонецФункции


Функция ЗагрузитьВходящиеСообщения(ТранспортныйМодуль, ТипСписка, ПараметрыВыполненияОбмена = Неопределено)
	
	ДальнейшееДействие = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ПараметрыВыполненияОбмена, "ДальнейшееДействие");
	Если ДальнейшееДействие = ПредопределенноеЗначение("Перечисление.ДальнейшиеДействияПоВзаимодействиюМДЛП.ПолучитеКвитанциюОФиксации") Тогда
		Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
	КонецЕсли;
	
	Попытка
		ПараметрыБлокировки = ТранспортМДЛПАПИВызовСервера.УстановитьБлокировку(ТипСписка, ТранспортныйМодуль.ИдентификаторОрганизации);
	Исключение
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;
	
	Результат = ОбновитьСписокДокументов(ТранспортныйМодуль, ТипСписка);
	Если Результат.Статус = "Ошибка" Тогда
		ТранспортМДЛПАПИВызовСервера.СнятьБлокировку(ПараметрыБлокировки);
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		Очередь = ТранспортМДЛПАПИВызовСервера.ОчередьЗагрузкиДокументов(ТипСписка, ТранспортныйМодуль.ИдентификаторОрганизации);
	Исключение
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТранспортМДЛПАПИВызовСервера.СнятьБлокировку(ПараметрыБлокировки);
		Возврат Результат;
	КонецПопытки;
	
	Для Каждого ДокументИзОчереди Из Очередь Цикл
		
		ДополнительныеПараметры = Новый Структура;
		
		Результат = ЗагрузитьДокумент(ТранспортныйМодуль, ДокументИзОчереди.ИдентификаторДокумента);
		Если Результат.Статус = "Ошибка" Тогда
			Прервать;
		КонецЕсли;
		ТекстСообщения = Результат.ТекстСообщения;
		
		Если ВРег(ТипСписка) = "ВХОДЯЩИЕ" Тогда
			ДополнительныеПараметры.Вставить("ИдентификаторОрганизацииОтправителя", ДокументИзОчереди.ИдентификаторОрганизацииОтправителя);
		Иначе
			
			Если ДокументИзОчереди.СтатусОбработкиДокумента = "ACCEPTED" Тогда
				Результат = СформироватьУспешнуюКвитанциюДокумента(ДокументИзОчереди.ТипДокумента, ДокументИзОчереди.ИдентификаторДокумента, ДокументИзОчереди.ДатаДокумента);
			Иначе
				Результат = ЗагрузитьКвитанциюДокумента(ТранспортныйМодуль, ДокументИзОчереди.ИдентификаторДокумента);
			КонецЕсли;
			
			Если Результат.Статус = "Ошибка" Тогда
				Прервать;
			КонецЕсли;
			ДополнительныеПараметры.Вставить("Квитанция", Результат.ТекстСообщения);
			
		КонецЕсли;
		
		Попытка
			ТранспортМДЛПАПИВызовСервера.ЗарегистрироватьВходящееСообщениеКОбработке(ТипСписка, ДокументИзОчереди, ТекстСообщения, ДополнительныеПараметры);
		Исключение
			Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
			Результат.Статус = "Ошибка";
			Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			Прервать;
		КонецПопытки;
		
	КонецЦикла;
	
	ТранспортМДЛПАПИВызовСервера.УстановитьГраницуЗагрузкиДокументовСписка(ТипСписка, ТранспортныйМодуль.ИдентификаторОрганизации);
	
	ТранспортМДЛПАПИВызовСервера.СнятьБлокировку(ПараметрыБлокировки);
	
	Возврат Результат;
	
КонецФункции

Функция ОбновитьСписокДокументов(ТранспортныйМодуль, ТипСписка)
	
	Попытка
		ДатаПоследнегоДокумента = ТранспортМДЛПАПИВызовСервера.ПолучитьГраницуЗагрузкиДокументовСписка(ТипСписка, ТранспортныйМодуль.ИдентификаторОрганизации);
	Исключение
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;
	
	Фильтр = Новый Структура;
	
	ДанныеЗапроса = ТранспортМДЛПКлиентСервер.ДанныеHTTPЗапроса("POST");
	Если ВРег(ТипСписка) = "ВХОДЯЩИЕ" Тогда
		ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/income";
		Фильтр.Вставить("doc_status", "PROCESSED_DOCUMENT");
	Иначе
		ДанныеЗапроса.АдресЗапроса = ТранспортныйМодуль.ПрефиксВерсии + "documents/outcome";
	КонецЕсли;
	
	ДатаПоследнегоДокумента = Макс(ТранспортныйМодуль.ДатаНачалаИспользования, ДатаПоследнегоДокумента);
	Если ЗначениеЗаполнено(ДатаПоследнегоДокумента) Тогда
		Фильтр.Вставить("start_date", Формат(ДатаПоследнегоДокумента, "ДФ='yyyy-MM-dd HH:mm:ss'"));
	КонецЕсли;
	
	ТелоЗапроса = Новый Структура;
	ТелоЗапроса.Вставить("filter", Фильтр);
	
	Результат = ПолучитьСписокОбъектов(ТранспортныйМодуль, ДанныеЗапроса, ТелоЗапроса);
	Если Результат.Статус = "Ошибка" Тогда
		Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
	КонецЕсли;
	
	Попытка
		ТранспортМДЛПАПИВызовСервера.ДополнитьСписокДокументов(ТипСписка, Результат.Список);
	Исключение
		Результат = ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации();
		Результат.Статус = "Ошибка";
		Результат.ОписаниеОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		Возврат Результат;
	КонецПопытки;
	
	Возврат ТранспортМДЛПКлиентСервер.РезультатВыполненияОперации(Результат);
	
КонецФункции

Функция АдресОбъекта(Данные)
	
	АдресОбъекта = Новый Структура("Идентификатор, Адрес");
	Если Данные["id"] <> Неопределено Тогда
		АдресОбъекта.Идентификатор = Данные["id"];
		Если Данные["address"] <> Неопределено Тогда
			АдресОбъекта.Адрес = Данные["address"]["address_description"];
		ИначеЕсли Данные["address_resolved"] <> Неопределено Тогда
			АдресОбъекта.Адрес = Данные["address_resolved"]["address"];
		КонецЕсли;
	Иначе
		АдресОбъекта.Идентификатор = Данные["address_id"];
		АдресОбъекта.Адрес = Данные["address"]["address_description"];
	КонецЕсли;
	
	Возврат АдресОбъекта;
	
КонецФункции

Функция ТаймаутПоРазмеруФайла(Размер)
	
	БайтВМегабайте = 1048576;
	
	Если Размер > БайтВМегабайте Тогда
		КоличествоСекунд = Окр(Размер / БайтВМегабайте * 128);
		Возврат ?(КоличествоСекунд > 43200, 43200, КоличествоСекунд);
	КонецЕсли;
	
	Возврат 128;
	
КонецФункции

Функция ПолучитьHexСтрокуИзЧисла(Знач Число) Экспорт
	
	СимволыЧисла = "0123456789ABCDEF";
	СтрокаHex = "";
	Пока Число > 0 Цикл
		
		СтрокаHex = Сред(СимволыЧисла, Число % 16 + 1, 1) + СтрокаHex;
		Число = Цел(Число / 16);
		
	КонецЦикла;
	
	Если ПустаяСтрока(СтрокаHex) Тогда
		СтрокаHex = "0";
	КонецЕсли;
	
	Возврат СтрокаHex;
	
КонецФункции

Процедура Таймаут(Миллисекунды = 1000)
	
	НачалоЗамера = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	Параметры = ОбщегоНазначенияКлиентСервер.ПараметрыЗапускаПрограммы();
	Параметры.ДождатьсяЗавершения = Истина;
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	Если СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86
	 Или СистемнаяИнформация.ТипПлатформы = ТипПлатформы.Windows_x86_64 Тогда
		КомандаЗапуска = СтрШаблон("ping -n 1 -w %1 127.255.255.255", Формат(Миллисекунды, "ЧДЦ=0; ЧГ="));
	Иначе
		КомандаЗапуска = СтрШаблон("sleep %1", Формат(Миллисекунды / 1000, "ЧДЦ=3; ЧРД=.; ЧГ="));
	КонецЕсли;
	
	ОбщегоНазначенияКлиентСервер.ЗапуститьПрограмму(КомандаЗапуска, Параметры);
	
	Пока (ТекущаяУниверсальнаяДатаВМиллисекундах() - НачалоЗамера) < Миллисекунды Цикл
		// Если нужное время не прошло, оставшееся время дождемся в цикле.
	КонецЦикла;
	
КонецПроцедуры

Процедура ОжидатьПриНеобходимости(ДатаНачалаУниверсальная, Миллисекунды)
	
	ТекущаяУниверсальнаяДата = ПолучитьТекущуюУниверсальнуюДату();
	
	РазностьМиллисекунд = (ТекущаяУниверсальнаяДата - ДатаНачалаУниверсальная) * 1000;
	Если РазностьМиллисекунд < Миллисекунды Тогда
		// В любом случае ожидаем не дольше заданного времени.
		ВремяОжидания = Мин(Миллисекунды - РазностьМиллисекунд, Миллисекунды);
		Таймаут(ВремяОжидания);
	КонецЕсли;
	
КонецПроцедуры

Функция ЕстьНеобходимостьПовторноВыполнитьЗапрос(Результат, ТаймаутМеждуЗапросами, НомерПопытки)
	
	Если Результат.Статус = "Ошибка" И Результат.СлишкомМногоЗапросов Тогда
		
		МаксимальноеВремяОжидания = 180000;
		
		РасчетныйИнтервал = ИнтервалМеждуЗапросамиИзРезультатаЗапроса(Результат, ТаймаутМеждуЗапросами);
		
		ИтоговоеВремяОжидания = 0;
		Для Счетчик = 1 По НомерПопытки Цикл
			ИтоговоеВремяОжидания = ИтоговоеВремяОжидания + РасчетныйИнтервал * Счетчик;
		КонецЦикла;
		
		Ожидать = МаксимальноеВремяОжидания >= ИтоговоеВремяОжидания;
		
		Если Ожидать Тогда
			Таймаут(РасчетныйИнтервал * НомерПопытки);
		КонецЕсли;
		
		НомерПопытки = НомерПопытки + 1;
		
		Возврат Ожидать;
		
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция ИнтервалМеждуЗапросамиИзРезультатаЗапроса(Результат, ИнтервалПоУмолчанию = 0)
	
	Если Не ЗначениеЗаполнено(Результат.ОписаниеОшибки) Тогда
		Возврат ИнтервалПоУмолчанию;
	КонецЕсли;
	
	КлючНачала = "Действующий интервал:";
	ПозицияНачала = СтрНайти(Результат.ОписаниеОшибки, КлючНачала);
	Если ПозицияНачала = 0 Тогда
		Возврат ИнтервалПоУмолчанию;
	КонецЕсли;
	ПозицияНачала = ПозицияНачала + СтрДлина(КлючНачала);
	
	КлючКонца = "мс""}";
	ПозицияКонца = СтрНайти(Результат.ОписаниеОшибки, КлючКонца);
	Если ПозицияКонца = 0 Тогда
		Возврат ИнтервалПоУмолчанию;
	КонецЕсли;
	
	РасчетныйИнтервалСтрокой = СокрЛП(Сред(Результат.ОписаниеОшибки, ПозицияНачала, ПозицияКонца - ПозицияНачала));
	Если Не ЗначениеЗаполнено(РасчетныйИнтервалСтрокой) Тогда
		Возврат ИнтервалПоУмолчанию;
	КонецЕсли;
	
	ОписаниеЧисла = Новый ОписаниеТипов("Число");
	РасчетныйИнтервал = ОписаниеЧисла.ПривестиЗначение(СокрЛП(РасчетныйИнтервалСтрокой));
	Если Не ЗначениеЗаполнено(РасчетныйИнтервал) Тогда
		Возврат ИнтервалПоУмолчанию;
	КонецЕсли;
	
	Возврат РасчетныйИнтервал;
	
КонецФункции

#КонецЕсли

Функция КодыОперацийКвитанций()
	
	КодыОперацийКвитанций = Новый Массив;
	КодыОперацийКвитанций.Добавить(200);
	КодыОперацийКвитанций.Добавить(201);
	КодыОперацийКвитанций.Добавить(211); // Получение_ИнформацияОКиЗ, Получение_СоставУпаковки
	КодыОперацийКвитанций.Добавить(221); // Получение_ИерархияВложенностиУпаковок
	
	Возврат КодыОперацийКвитанций;
	
КонецФункции

Функция КодыОперацийПолученияИнформацииОбУпаковках()
	
	КодыОперацийПолученияИнформацииОбУпаковках = Новый Массив;
	КодыОперацийПолученияИнформацииОбУпаковках.Добавить(210);
	КодыОперацийПолученияИнформацииОбУпаковках.Добавить(220);
	КодыОперацийПолученияИнформацииОбУпаковках.Добавить(2101);
	КодыОперацийПолученияИнформацииОбУпаковках.Добавить(2102);
	КодыОперацийПолученияИнформацииОбУпаковках.Добавить(2103);
	
	Возврат КодыОперацийПолученияИнформацииОбУпаковках;
	
КонецФункции

Функция КодыОперацийВходящихУведомлений()
	
	КодыОперацийВходящихУведомлений = Новый Массив;
	КодыОперацийВходящихУведомлений.Добавить(627);
	КодыОперацийВходящихУведомлений.Добавить(628);
	КодыОперацийВходящихУведомлений.Добавить(629);
	КодыОперацийВходящихУведомлений.Добавить(630);
	КодыОперацийВходящихУведомлений.Добавить(631);
	
	Возврат КодыОперацийВходящихУведомлений;
	
КонецФункции

Функция ПолучитьДесятичнуюСтрокуИзHexСтроки(СтрокаHex)
	
	ПредставлениеЧисла = НРег(СтрокаHex);
	
	Число = 0;
	База = 1;
	ДлинаЧисла = СтрДлина(ПредставлениеЧисла);
	Для Индекс = 0 По ДлинаЧисла - 1 Цикл
		
		Символ = Сред(ПредставлениеЧисла, ДлинаЧисла - Индекс, 1);
		Если СтрНайти("0123456789", Символ) Тогда
			ТекущееЧисло = Число(Символ);
		Иначе
			ТекущееЧисло = КодСимвола(Символ) - КодСимвола("a") + 10;
		КонецЕсли;
		
		Число = Число + База * ТекущееЧисло;
		База = База * 16;
		
	КонецЦикла;
	
	Возврат Формат(Число, "ЧГ=0");
	
КонецФункции

// Преобразует исходную строку в дату.
//
// Параметры:
//  Значение - Строка - Строка, которую необходимо привести к дате.
//                      Формат даты должен быть в виде "ГГГГ-ММ-ДД чч:мм:сс".
// 
// Возвращаемое значение:
//  Дата - полученная дата.
//
Функция СтрокаВДату(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение, "-", "");
	Значение = СтрЗаменить(Значение, ":", "");
	Значение = СтрЗаменить(Значение, " ", "");
	Значение = СтрЗаменить(Значение, "T", "");
	Значение = СтрЗаменить(Значение, "Z", ""); // в случае, если часовой пояс не имеет значения (например если на входе формат даты со временем, но время не нужно учитывать)
	ОписаниеДаты = Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));
	Возврат ОписаниеДаты.ПривестиЗначение(Значение);
	
КонецФункции

Функция СтрокаВДатуСУчетомВременнойЗоны(Знач Значение) Экспорт
	
	СтрокаJSONСДатой = ТранспортМДЛПКлиентСервер.ПреобразоватьЗначениеВJSON(Новый Структура("Дата", Значение));
	ДанныеСДатойВременнойЗоны = ТранспортМДЛПКлиентСервер.ПреобразоватьJSONВЗначение(СтрокаJSONСДатой, Ложь, "Дата");
	
	Возврат ДанныеСДатойВременнойЗоны.Дата;
	
КонецФункции

Функция УдалитьРазделителиСтрок(Данные)
	Возврат СтрЗаменить(СтрЗаменить(Данные, Символы.ПС, ""), Символы.ВК, "");
КонецФункции

Функция ТипУчастника_ИностранныйКонтрагент() Экспорт
	
	Возврат "8";
	
КонецФункции

Функция ПолучитьПорциюДанных(Данные, РазмерПорции) Экспорт
	
	Порция = Новый Массив;
	Граница = Мин(Данные.Количество(), РазмерПорции) - 1;
	Для Индекс = 0 По Граница Цикл
		Порция.Добавить(Данные[0]);
		Данные.Удалить(0);
	КонецЦикла;
	
	Возврат Порция;
	
КонецФункции

Функция ПолучитьТекущуюДатуСеанса()
	
	#Если Сервер Или ТолстыйКлиент Или ВнешнееСоединение Тогда
		Возврат ТекущаяДатаСеанса();
	#Иначе
		Возврат ОбщегоНазначенияКлиент.ДатаСеанса();
	#КонецЕсли
	
КонецФункции

Функция ПолучитьТекущуюУниверсальнуюДату()
	
	#Если Сервер Или ТолстыйКлиент Или ВнешнееСоединение Тогда
		Возврат УниверсальноеВремя(ТекущаяДатаСеанса(), ЧасовойПоясСеанса());
	#Иначе
		Возврат ОбщегоНазначенияКлиент.ДатаУниверсальная();
	#КонецЕсли
	
КонецФункции

// Дополняет отбор приемник свойством отбора источника с условием,
// что значение свойства источник не равно Неопределено.
//
// Параметры:
//  Приемник - Структура - отбор приемник.
//  Источник - Структура - отбор источник.
//  СвойствоПриемник - Строка - имя совйства приемника.
//  СвойствоИсточник - Строка - имя свойства источника.
//
Процедура ДополнитьОтборСПроверкой(Приемник, Источник, СвойствоПриемник, СвойствоИсточник)
	
	Если Источник = Неопределено Или Приемник = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗначениеИсточник = Неопределено;
	Если Источник.Свойство(СвойствоИсточник, ЗначениеИсточник) Тогда
		Если ЗначениеИсточник <> Неопределено Тогда
			Приемник.Вставить(СвойствоПриемник, ЗначениеИсточник);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти
