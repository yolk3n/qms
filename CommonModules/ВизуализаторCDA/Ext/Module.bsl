 
#Область ПрограммныйИнтерфейс

// Функция - Формирует табличный документ из CDA и медицинского документа.
//
// Параметры:
//  Документы					 - Строка, СписокЗначений	 - CDA-документы для отображения (можно передать Неопределено).
//  СсылкиМД					 - ДокументСсылка.МедицинскийДокумент, СписокЗначений	 -  медицинские документы для отображения.
//  ДокументГотов				 - Булево	 - флаг готовности документа
//  ПолныйДокумент				 - Булево	 - флаг полный или усеченный документ
//  ИмпортируемыеВизуализаторы	 - Массив СправочникСсылка.ВизуализаторыМедицинскихДокументов	 - визуализаторы для отображения документов.
// 
// Возвращаемое значение:
//   - 
//
Функция CDA2ТабличныйДокумент(
		CDAДокументы,
		СсылкиМД = Неопределено,
		ДокументГотов = Неопределено,
		ПолныйДокумент = Истина,
		ИмпортируемыеВизуализаторы = Неопределено,
		ВыводитьШапку = Истина,
		ВыводитьДокументСНовойСтраницы = Ложь,
		ФайлыCDA = Неопределено
	) Экспорт
	
	Если CDAДокументы = Неопределено Тогда
		CDAДокументы = Новый СписокЗначений();
	КонецЕсли;
	Результат_ = Неопределено;
	Если ТипЗнч(СсылкиМД) <> Тип("СписокЗначений") Тогда
		СсылкаМД_ = СсылкиМД;
		CDAДокумент_ = Неопределено;
		Если ТипЗнч(CDAДокументы) = Тип("Строка") Тогда 
			CDAДокумент_ = CDAДокументы;
		КонецЕсли;
		Визуализатор_ = Неопределено;
		Если Метаданные.Справочники.Найти("ВизуализаторыМедицинскихДокументов") <> Неопределено
			И ТипЗнч(ИмпортируемыеВизуализаторы) = Тип("СправочникСсылка.ВизуализаторыМедицинскихДокументов")
		Тогда
			Визуализатор_ = ИмпортируемыеВизуализаторы;
		КонецЕсли;

		Результат_ = СформироватьТабличныйДокумент(СсылкаМД_, CDAДокумент_, ПолныйДокумент, , Визуализатор_, ВыводитьШапку);
	КонецЕсли;
	
	
	Если ТипЗнч(CDAДокументы) = Тип("СписокЗначений") и ТипЗнч(СсылкиМД) = Тип("СписокЗначений") Тогда
		Если ИмпортируемыеВизуализаторы = Неопределено Тогда
			ИмпортируемыеВизуализаторы = Новый Массив();
		КонецЕсли;
		
		Результат_ = Новый ТабличныйДокумент();
		РазрывСтраницы_ = Неопределено;
		Если ВыводитьДокументСНовойСтраницы Тогда
			Если Метаданные.Обработки.Найти("ТабличныйВизуализатор") <> Неопределено Тогда
				РазрывСтраницы_ = Обработки["ТабличныйВизуализатор"].ПолучитьМакет("Макет").ПолучитьОбласть("РазрывСтраницы");
			ИначеЕсли ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Печать") Тогда
				МодульУправлениеПечатью_ = ОбщегоНазначения.ОбщийМодуль("УправлениеПечатью");
				РазрывСтраницы_ = МодульУправлениеПечатью_.МакетПечатнойФормы("ОбщиеМакеты.ПФ_MXL_ТабличныйВизуализатор").ПолучитьОбласть("РазрывСтраницы");
			Иначе
				РазрывСтраницы_ = ПолучитьОбщийМакет("ПФ_MXL_ТабличныйВизуализатор").ПолучитьОбласть("РазрывСтраницы");
			КонецЕсли;
		КонецЕсли;		
		КоличествоВыведенныхДокументов_ = 0;
		
		Для Счетчик_ = 0 По СсылкиМД.Количество() - 1 Цикл
			СсылкаМД_ = СсылкиМД[Счетчик_].Значение;
			ФайлCDA_ = Неопределено;
			Если ЗначениеЗаполнено(ФайлыCDA) Тогда
				ФайлCDA_ = ФайлыCDA[Счетчик_];
			КонецЕсли;
			Визуализатор_ = Неопределено;
			Если Счетчик_ < ИмпортируемыеВизуализаторы.Количество() Тогда
				Визуализатор_ = ИмпортируемыеВизуализаторы[Счетчик_];
			КонецЕсли;
			CDAДокумент_ = Неопределено;
			Если Счетчик_ < CDAДокументы.Количество() Тогда
				CDAДокумент_ = CDAДокументы[Счетчик_].Значение;
			КонецЕсли;
			
			ВыводитьШапку_ = ВыводитьШапку;
			Если Не ПолныйДокумент Тогда
				ВыводитьШапку_ = ВыводитьШапку И Счетчик_ = 0;
			КонецЕсли;
			Док_ = СформироватьТабличныйДокумент(СсылкаМД_, CDAДокумент_, ПолныйДокумент, , Визуализатор_, ВыводитьШапку_,,,ФайлCDA_);
			Если Док_ <> Неопределено Тогда
				Если РазрывСтраницы_ <> Неопределено И КоличествоВыведенныхДокументов_ > 0 Тогда
					Результат_.Вывести(РазрывСтраницы_);
				КонецЕсли;
				Результат_.Вывести(Док_);
				КоличествоВыведенныхДокументов_ = КоличествоВыведенныхДокументов_ + 1;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	
	Возврат Результат_;
	
КонецФункции

// Формирует табличный документ на сервере.
//
// Параметры:
//  СсылкаМД									 - ДокументСсылка.МедицинскийДокумент	 - МД
//  ТелоДокумента							 - Строка	 - CDA-документ
//  ПолныйДокумент						 - Булево	 - Формировать полный документ или усеченную версию
//  ДокументГотов							 - Булево	 - Флаг готовности документа
//  ИмпортируемыйВизуализатор	 - СправочникСсылка.Визуализатор	 - 
//  ВыводитьШапку							 - Булево	 - Выводить ли шапку
//  ВывестиВкладыш						 - Булево	 - Выводить ли вкладыш
//  OutМакет									 - ТабличныйДокумент	 - Макет визуализатора (выходной параметр)
// 
// Возвращаемое значение:
//  ТабличныйДокумент - Табличный документ на основе CDA и МД.
//
Функция СформироватьТабличныйДокумент(
		СсылкаМД = Неопределено,
		ТелоДокумента = Неопределено,
		ПолныйДокумент = Истина,
		ДокументГотов = Неопределено,
		ИмпортируемыйВизуализатор = Неопределено,
		ВыводитьШапку = Истина,
		ВывестиВкладыш = Ложь,
		OutМакет = Неопределено,
		ФайлCDA = Неопределено
	) Экспорт
	
	ИспользуетсяСправочникВизуализаторов_ = Метаданные.Справочники.Найти("ВизуализаторыМедицинскихДокументов") <> Неопределено;
	ИспользуетсяРегистрСведенийТабличныеДокументыCDA_ = Метаданные.РегистрыСведений.Найти("ТабличныеДокументыCDA") <> Неопределено;
	Результат_ = Неопределено;
	Если ИспользуетсяРегистрСведенийТабличныеДокументыCDA_ Тогда
		Результат_ = ПолучитьТабличныйДокументИзКеша(СсылкаМД, ФайлCDA, ИмпортируемыйВизуализатор, ТелоДокумента, ПолныйДокумент, ВыводитьШапку, OutМакет);
	КонецЕсли;
	Если ТипЗнч(Результат_) = Тип("ТабличныйДокумент") Тогда
		Возврат Результат_;
	КонецЕсли;
	
	Результат_ = Новый ТабличныйДокумент();
	ПодписанЭП_ = Неопределено;
	
	Если ДокументГотов = Неопределено И ЗначениеЗаполнено(СсылкаМД) Тогда
		ДокументГотов = ВизуализаторПереопределяемый.ОпределитьГотовностьДокумента(СсылкаМД);
	Иначе
		ДокументГотов = Истина;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СсылкаМД) Тогда
		ПодписанЭП_ = ВизуализаторПереопределяемый.ДокументИмеетЭЦП(СсылкаМД);
	Иначе
		ПодписанЭП_ = Ложь;
	КонецЕсли;
	
	Если ТелоДокумента = Неопределено И ЗначениеЗаполнено(ФайлCDA) Тогда
		ТелоДокумента = ВизуализаторПереопределяемый.ПолучитьТелоМД(ФайлCDA);
	КонецЕсли;
	
	Если ТелоДокумента = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПодписанЭП_ = Неопределено Тогда
		ПодписанЭП_ = СтрНайти(ТелоДокумента, "</sdtc:signatureText>") > 0;
	КонецЕсли;
	
	Если СтрНайти(ТелоДокумента, "urn:f88") = 0 Тогда
		Если СтрНайти(ТелоДокумента, "urn:hl7-ru:identity") <> 0 Тогда
			ТелоДокумента = ВыполнитьЗаменуПространстваИменНаF88(ТелоДокумента, "urn:hl7-ru:identity", "identity");
		КонецЕсли;
	
		Если СтрНайти(ТелоДокумента, "urn:f103") <> 0 Тогда
			ТелоДокумента = ВыполнитьЗаменуПространстваИменНаF88(ТелоДокумента, "urn:f103", "f103");
		КонецЕсли;
	КонецЕсли;
	
	Если ИспользуетсяСправочникВизуализаторов_ Тогда
		СтандартныйВизуализатор_ = КешСеанса.ПолучитьЗначение("Справочники.ВизуализаторыМедицинскихДокументов.ВизуализаторСтандартнаяОбработка");
		ВизуализаторОбработка_ = КешСеанса.ПолучитьЗначение("Справочники.ВизуализаторыМедицинскихДокументов.ВизуализаторОбработка", ИмпортируемыйВизуализатор);
	Иначе
		// Обработки ТабличныйВизуализатор в конфигурации нет.
		СтандартныйВизуализатор_ = Неопределено;
		ВизуализаторОбработка_ = Неопределено;
		
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.Печать") Тогда
			МодульУправлениеПечатью_ = ОбщегоНазначения.ОбщийМодуль("УправлениеПечатью");
			OutМакет = МодульУправлениеПечатью_.МакетПечатнойФормы("ОбщиеМакеты.ПФ_MXL_ТабличныйВизуализатор");
		Иначе
			OutМакет = ПолучитьОбщийМакет("ПФ_MXL_ТабличныйВизуализатор");
		КонецЕсли;

	КонецЕсли;
	
	ВыводитьПриПечатиВкладыша_ = Неопределено;
	
	Если ИспользуетсяСправочникВизуализаторов_ Тогда
		Попытка
			ВыводитьПриПечатиВкладыша_ = ВизуализаторОбработка_.ВыводитьПриПечатиВкладыша();
		Исключение
			ВыводитьПриПечатиВкладыша_ = СтандартныйВизуализатор_.ВыводитьПриПечатиВкладыша();
		КонецПопытки;
	Иначе
		ВыводитьПриПечатиВкладыша_ = Новый Структура("Заголовок,ДокументНеГотов,Подвал,ЭлектроннаяПодпись,Dgn,Trtmplan,Drug,Doc,PMP");
	КонецЕсли;
	
	МассивДокументов_ =  ПолучитьДанныеИзCDA(ТелоДокумента);
	Если МассивДокументов_ = Неопределено Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	ПостроительDOM_ = Новый ПостроительDOM;
	ЧтениеXML_ = Новый ЧтениеXML;
	ЧтениеXML_.УстановитьСтроку(ТелоДокумента);
	Попытка
		ДокументDOM_ = ПостроительDOM_.Прочитать(ЧтениеXML_);
	Исключение
		Инфо_ = ИнформацияОбОшибке();
		Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
			МодульСообщенияПользователю_ = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
			МодульСообщенияПользователю_.Показать("Общие_ОшибкаЧтенияСохраненногоДокумента");
		Иначе
			Сообщить("Ошибка чтения сохраненного документа. Вероятнее всего он не является XML-документом.");
		КонецЕсли;
		
		Возврат Неопределено;
	КонецПопытки;
	
	// Получаем секции из макета и сортируем по порядку появления в макете
	Секции_ = СортироватьОбластиМакета(OutМакет.Области);
	ИменаСекций_ = Новый Структура();
	Для Каждого Область_ Из Секции_ Цикл
		ИменаСекций_.Вставить(Область_.Имя);
	КонецЦикла;
	
	ПервыйДокумент_ = Истина;
	СчетчикДокументов_ = 0;
	
	Для каждого Документ_ из МассивДокументов_ Цикл
		Док_ = ПолучитьЗначениеПоПути(Документ_, "ClinicalDocument");
		Если Док_ = Неопределено Тогда
			Док_ = ПолучитьЗначениеПоПути(Документ_, "ClinicalDocument1C");
		КонецЕсли;
		Если Не Док_ = Неопределено Тогда
			Документ_ = Док_;
		КонецЕсли;
		Компонент_ = Документ_;
		Если Компонент_.Свойства().Получить("component") <> Неопределено Тогда
			Компонент_ = Компонент_.component;
		Иначе
			Продолжить;
		КонецЕсли;
		Если Компонент_.Свойства().Получить("structuredBody") <> Неопределено Тогда
			Компонент_ = Компонент_.structuredBody;
		Иначе
			Продолжить;
		КонецЕсли;
		Если Компонент_.Свойства().Получить("component") <> Неопределено Тогда
			Компонент_ = Компонент_.component;
		Иначе
			Продолжить;
		КонецЕсли;
		
		Если Компонент_ = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СчетчикДокументов_ = СчетчикДокументов_ + 1;
		
		КодыСекций_ = Новый Соответствие();
		Если Метаданные.ОбщиеМодули.Найти("ПодсистемаМедицинаПоликлиника") <> Неопределено Тогда
			ЗаполнитьКодыСекций(Компонент_, КодыСекций_, Документы["МедицинскийДокумент"].ПолучитьШаблонМедицинскогоДокумента(СсылкаМД));
		КонецЕсли;

		Параметры_ = Новый Структура();
		Параметры_.Вставить("ДокументГотов", ДокументГотов);
		Параметры_.Вставить("ПолныйДокумент", ПолныйДокумент);
		Параметры_.Вставить("НомерДокумента", СчетчикДокументов_);
		Если ПолныйДокумент Тогда
			Параметры_.Вставить("ВыводитьШапку", ВыводитьШапку);
		Иначе
			Параметры_.Вставить("ВыводитьШапку", ПервыйДокумент_ И ВыводитьШапку);
		КонецЕсли;
		Параметры_.Вставить("ПодписанЭП", ПодписанЭП_);
		ПервыйДокумент_ = Ложь;
		
		ЕстьСвязанныеДокументы_ = Ложь;
		Для каждого Элемент_ Из КодыСекций_ Цикл
			Если Элемент_.Значение.Свойство("КодСекции") И Элемент_.Значение.КодСекции = "LINKDOCS" Тогда
				ЕстьСвязанныеДокументы_ = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		// Заполняем области
		Для Каждого Область_ Из Секции_ Цикл
			ИмяОбласти_ = Область_.Имя;
			
			// При налеичии секции СЭМД СвязанныеДокументы секцию ВыданныеДокументы не отображаем 
			Если ИмяОбласти_ = "Doc" И ЕстьСвязанныеДокументы_ = Истина Тогда
				Продолжить;
			КонецЕсли;
			
			// Вывод данных из CDA-документа в области определенные в макете c префиксом CDA_
			Если Лев(ИмяОбласти_, 4) = "CDA_" Тогда
				ИмяСекции_ = Сред(ИмяОбласти_, 5);

				Если ТипЗнч(Компонент_) = Тип("СписокXDTO") Тогда
					Для Счетчик_ = 0 По Компонент_.Количество() - 1 Цикл
						Данные_ = Компонент_.ПолучитьXDTO(Счетчик_);
						Данные_ = ПолучитьЗначениеПоПути(Данные_, "section");
						Код_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций_.Получить(Данные_), "КодОбласти");
						Если Код_<> Неопределено И Код_ = ИмяСекции_ Тогда 
							ЗаполнитьОбласть(
								Результат_, 
								ИмяСекции_, 
								Данные_, 
								OutМакет, 
								ПолныйДокумент, 
								ДокументDOM_,
								ВизуализаторОбработка_, 
								СтандартныйВизуализатор_, 
								КодыСекций_
							);
						КонецЕсли;
					КонецЦикла;
					
				ИначеЕсли ТипЗнч(Компонент_) = Тип("ОбъектXDTO") Тогда
					Данные_ = ПолучитьЗначениеПоПути(Компонент_, "section");

					Код_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций_.Получить(Данные_), "КодОбласти");
					Если Код_<> Неопределено И Код_ = ИмяСекции_ Тогда 
						ЗаполнитьОбласть(
							Результат_, 
							ИмяСекции_, 
							Данные_, 
							OutМакет,
							ПолныйДокумент, 
							ДокументDOM_,
							ВизуализаторОбработка_, 
							СтандартныйВизуализатор_,
							КодыСекций_
						);
					КонецЕсли;
				КонецЕсли;
				// Вывод данных из CDA, для которых отсутствует описание оформления в макете в область по умолчанию.
			ИначеЕсли Лев(ИмяОбласти_, 3) = "CDA" Тогда
				ИмяСекции_ = "CDA";
				
				Если ТипЗнч(Компонент_) = Тип("СписокXDTO") Тогда
					Для Счетчик_ = 0 По Компонент_.Количество() - 1 Цикл
						Данные_ = ПолучитьЗначениеПоПути(Компонент_.Получить(Счетчик_), "section");

						Код_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций_.Получить(Данные_), "КодОбласти");
						Если Код_ <> Неопределено и OutМакет.Области.Найти("CDA_"+Код_) <> Неопределено Тогда
							Продолжить;
						КонецЕсли;

						ЗаполнитьОбласть(
							Результат_, 
							ИмяСекции_, 
							Данные_, 
							OutМакет, 
							ПолныйДокумент, 
							ДокументDOM_, 
							ВизуализаторОбработка_, 
							СтандартныйВизуализатор_, 
							КодыСекций_
						);
					КонецЦикла;
					
				ИначеЕсли ТипЗнч(Компонент_) = Тип("ОбъектXDTO") Тогда
					Данные_ = ПолучитьЗначениеПоПути(Компонент_, "section");

					Код_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций_.Получить(Данные_), "КодОбласти");
					Если Код_ <> Неопределено и OutМакет.Области.Найти("CDA_"+Код_) <> Неопределено
						Тогда
						Продолжить;
					КонецЕсли;
					ЗаполнитьОбласть(
						Результат_, 
						ИмяСекции_, 
						Данные_, 
						OutМакет, 
						ПолныйДокумент, 
						ДокументDOM_, 
						ВизуализаторОбработка_, 
						СтандартныйВизуализатор_,
						КодыСекций_
					);
				КонецЕсли;
				
			ИначеЕсли ИмяОбласти_ = "ОтметкаЭП" Тогда
				Если ПодписанЭП_ Тогда
					ШтампЭП_ = ЗаполнитьОтметкуЭП(OutМакет, Документ_, СсылкаМД);
					Если Не ШтампЭП_ = Неопределено Тогда
						Результат_.Вывести(ШтампЭП_);
					КонецЕсли;
				КонецЕсли;
			Иначе
				// Вывод данных из ИБ (имя функции должно соответствовать имени области в макете)
				Параметры_.Вставить("КодСекции", ИмяОбласти_);
				ОбластьМакета_ = Неопределено;
				Попытка
					ОбластьМакета_ = OutМакет.ПолучитьОбласть(ИмяОбласти_);
				Исключение
				КонецПопытки;
				Если Неопределено = ОбластьМакета_ Тогда 
					Продолжить;
				КонецЕсли;
				
				Если Не ВывестиВкладыш ИЛИ ВыводитьПриПечатиВкладыша_.Свойство(ИмяОбласти_) Тогда
					Если Не ИспользуетсяСправочникВизуализаторов_ Или ПодписанЭП_ Или Не ЗначениеЗаполнено(СсылкаМД) Тогда
						ПользовательскаяОбласть_ = Неопределено;
						Попытка
							ПользовательскаяОбласть_ = ЗаполнитьОбластьИзCDA(ИмяОбласти_, ОбластьМакета_, Документ_, Параметры_);
						Исключение
						КонецПопытки;
						Если НЕ ПользовательскаяОбласть_ = Неопределено Тогда
							Результат_.Вывести(ПользовательскаяОбласть_);
						КонецЕсли;
					Иначе
						ПользовательскаяОбласть_ = Неопределено;
						
						Если ПользовательскаяОбласть_ = Неопределено Тогда
							Попытка
								ПользовательскаяОбласть_ = ЗаполнитьОбластьИзCDA(ИмяОбласти_, ОбластьМакета_, Документ_, Параметры_);
							Исключение
							КонецПопытки;
						КонецЕсли;
						Если НЕ ПользовательскаяОбласть_ = Неопределено Тогда
							Результат_.Вывести(ПользовательскаяОбласть_);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	НастроитьПараметрыСтраницыИзМакета(Результат_, OutМакет);
	
	Если ИспользуетсяСправочникВизуализаторов_ Тогда
			Если ИмпортируемыйВизуализатор = Неопределено Тогда
			УИД_ = Справочники["ВизуализаторыМедицинскихДокументов"].СтдВизуализатор().УникальныйИдентификатор();
		Иначе
			УИД_ = ИмпортируемыйВизуализатор.УникальныйИдентификатор();
		КонецЕсли;
	Иначе
		УИД_ = Новый УникальныйИдентификатор("fba65203-19a8-44ed-a396-6574fb057bd0");
	КонецЕсли;
	
	НастроитьПараметрыСтраницыИзНастроекПользователя(Результат_, УИД_);
	
	Если ИспользуетсяРегистрСведенийТабличныеДокументыCDA_ Тогда
		ЗаписатьТабличныйДокументВКеш(СсылкаМД, ФайлCDA, ИмпортируемыйВизуализатор, СтандартныйВизуализатор_, Результат_, ПолныйДокумент, ВыводитьШапку);
	КонецЕсли;
	Возврат Результат_;
КонецФункции

Функция ЗаполнитьОтметкуЭП(Макет, Документ, СсылкаМД)
	Если ЗначениеЗаполнено(СсылкаМД) Тогда
		МассивПодписейCades_ = ВизуализаторПереопределяемый.ПолучитьИнформациюОбЭЦП(СсылкаМД);
	Иначе
		МассивПодписейCades_ = Новый Массив;
	КонецЕсли;
	
	КоличествоПодписейCades_ = МассивПодписейCades_.Количество();
	
	Если КоличествоПодписейCades_ = 0 Тогда
		Возврат Неопределено;
	ИначеЕсли КоличествоПодписейCades_ = 1 Тогда
		ОбластьЭП_ = Макет.ПолучитьОбласть("ШтампОдинарнаяСтрока");
		Если Не ОбластьЭП_.Области.Найти("ШтампОдинарныйЭмблема") = Неопределено Тогда
			ОбластьЭП_.Области.ШтампОдинарныйЭмблема.Картинка = ВизуализаторПереопределяемый.ПолучитьКартинкуЭмблемаОрганизацииДляШтампаЭлектроннойПодписи(СсылкаМД);
		КонецЕсли;
		Если КоличествоПодписейCades_ > 0 Тогда
			Подпись_ = МассивПодписейCades_[0];
			Возврат ЗаполнитьОднуОтметкуЭПИзCades(ОбластьЭП_, Подпись_, СсылкаМД);
		КонецЕсли;
	Иначе
		Счетчик_ = 1;
		Результат_ = Новый ТабличныйДокумент;
		ШапкаЭП_ = Макет.ПолучитьОбласть("ШтампТабличныйШапка");
		Если Не ШапкаЭП_.Области.Найти("ШтампТаблицаШапкаЭмблема") = Неопределено Тогда
			ШапкаЭП_.Области.ШтампТаблицаШапкаЭмблема.Картинка = ВизуализаторПереопределяемый.ПолучитьКартинкуЭмблемаОрганизацииДляШтампаЭлектроннойПодписи(СсылкаМД);
		КонецЕсли;
		Результат_.Вывести(ШапкаЭП_);
		
		РазделительЭП_ = Макет.ПолучитьОбласть("ШтампТабличныйРазделитель");
		Для Каждого Подпись_ Из МассивПодписейCades_ Цикл
			ОбластьЭП_ = Макет.ПолучитьОбласть("ШтампТабличныйСтрока");
			Результат_.Вывести(ЗаполнитьОднуОтметкуЭПИзCades(ОбластьЭП_, Подпись_, СсылкаМД));
			ВывестиРазделительЭП(Результат_, РазделительЭП_, Счетчик_, КоличествоПодписейCades_);
			Счетчик_ = Счетчик_ + 1;
		КонецЦикла;
		
		ПодвалЭП_ = Макет.ПолучитьОбласть("ШтампТабличныйПодвал");
		Результат_.Вывести(ПодвалЭП_);
		
		Возврат Результат_;
		
	КонецЕсли;
КонецФункции

Функция ЗаполнитьОднуОтметкуЭПИзXML(Знач Макет, Объект)
	Параметры_ = Новый Структура;
	Дата_ = ПолучитьЗначениеПоПути(Объект, "time/value");
	
	Если Не Дата_ = Неопределено Тогда
		Параметры_.Вставить("ДатаПодписи", СтрШаблон("%1 %2", ПолучитьДату(Дата_ ), ПолучитьВремя(Дата_)));
	КонецЕсли;
	
	ВладелецСертификата_ = ПолучитьЗначениеПоПути(Объект, "assignedEntity/assignedPerson/name");
	Если Не ВладелецСертификата_ = Неопределено Тогда
		Параметры_.Вставить("ВладелецСертификата", ПолучитьИмя(ВладелецСертификата_, Ложь));
	КонецЕсли;
	
	Организация_ = ПолучитьЗначениеПоПути(Объект, "assignedEntity/representedOrganization/name");
	Если Не Организация_ = Неопределено Тогда
		Параметры_.Вставить("Организация", ПолучитьИмя(Организация_, Ложь));
	КонецЕсли;
	
	ОтпечатокЭП_ = ПолучитьЗначениеПоПути(Объект, "signatureText/thumbnail");
	ДанныеЭП_ = ПолучитьТекст(ОтпечатокЭП_);
	МассивДанныхЭП_ = СтрРазделить(ДанныеЭП_, Символы.Таб + Символы.Таб, Ложь);
	Если МассивДанныхЭП_.Количество() > 1 Тогда
		Параметры_.Вставить("НомерСертификата", МассивДанныхЭП_[1]);
	КонецЕсли;
	Если МассивДанныхЭП_.Количество() > 4 Тогда
		Параметры_.Вставить("СрокДействия", МассивДанныхЭП_[4]);
	КонецЕсли;
	
	Макет.Параметры.Заполнить(Параметры_);
	Возврат Макет;
КонецФункции

Функция ЗаполнитьОднуОтметкуЭПИзCades(Знач Макет, Подпись, СсылкаМД)
	Параметры_ = ПолучитьПараметрыОтметкиЭПИзCades(Подпись, СсылкаМД);
	Макет.Параметры.Заполнить(Параметры_);
	Возврат Макет;
КонецФункции

Процедура ВывестиРазделительЭП(Результат, РазделительЭП, Счетчик, КоличествоПодписей)
	Если Счетчик < КоличествоПодписей Тогда
		Результат.Вывести(РазделительЭП);
	КонецЕсли;
КонецПроцедуры

Функция ЭлементСодержитОтметкуЭП(Элемент)
	Если Элемент.Свойства().Получить("signatureText") = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	ЭлементПодпись_ = Элемент.signatureText;
	Если ЭлементПодпись_.Свойства().Получить("thumbnail") = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	ТекстОтметки_ = ПолучитьТекст(ПолучитьЗначениеПоПути(Элемент, "signatureText/thumbnail"));
	Возврат СтрНайти(ТекстОтметки_, Символы.Таб + Символы.Таб) > 0;
КонецФункции

// Процедура - копирует параметры страницы из макета в результирующий документ.
//
// Параметры:
//  Результат	 - ТабличныйДокумент - Настраиваемый табличный документ.
//  Макет		 - ТабличныйДокумент	 - Документ, из которого считываются параметры страницы.
//
Процедура НастроитьПараметрыСтраницыИзМакета(Результат, Макет) Экспорт	
	СписокПараметров_ = Новый Структура("АвтоМасштаб, ДвусторонняяПечать, МасштабПечати, ОриентацияСтраницы, 
	| ПолеСверху, ПолеСлева, ПолеСнизу, ПолеСправа, РазмерКолонтитулаСверху, РазмерКолонтитулаСнизу, 
	| РазмерСтраницы, ЧередованиеРасположенияСтраниц, ЧерноБелаяПечать, ЭкземпляровНаСтранице");
	Для Каждого Параметр_ Из СписокПараметров_ Цикл
		Результат[Параметр_.Ключ] = Макет[Параметр_.Ключ];
	КонецЦикла;
	
	СписокПараметров_ = Новый Структура("ВертикальноеПоложение, Выводить, НачальнаяСтраница, ТекстВЦентре, ТекстСлева, ТекстСправа, Шрифт");
	Для Каждого Параметр_ Из СписокПараметров_ Цикл
		Результат.ВерхнийКолонтитул[Параметр_.Ключ] = Макет.ВерхнийКолонтитул[Параметр_.Ключ];
		Результат.НижнийКолонтитул[Параметр_.Ключ] = Макет.НижнийКолонтитул[Параметр_.Ключ];
	КонецЦикла;
КонецПроцедуры

// Процедура - копирует параметры страницы из настроек пользователя.
//
// Параметры:
//  Результат	 - ТабличныйДокумент - Настраиваемый табличный документ.
//  Визуализатор		 - СправочникСсылка.Визуализатор	 - Визуализатор, для которого сохранены настройки.
//
Процедура НастроитьПараметрыСтраницыИзНастроекПользователя(Результат, УИДНастроек) Экспорт	
	СписокПараметров_ = Новый Структура("АвтоМасштаб, МасштабПечати, 
	| ПолеСверху, ПолеСлева, ПолеСнизу, ПолеСправа, РазмерКолонтитулаСверху, РазмерКолонтитулаСнизу, 
	| РазмерСтраницы, ЧерноБелаяПечать, ЭкземпляровНаСтранице");
	Для Каждого Параметр_ Из СписокПараметров_ Цикл
		Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, Параметр_.Ключ + "_");
		Если Настройка_ <>  Неопределено Тогда
			Результат[Параметр_.Ключ] = Настройка_;
		КонецЕсли;
	КонецЦикла;
	
	Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, "ЧередованиеРасположенияСтраниц_");
	Если Настройка_ <>  Неопределено Тогда
		Чередование_ = ЧередованиеРасположенияСтраниц.НеИспользовать;
		Если Настройка_ = "Зеркально сверху" Тогда
			Чередование_ = ЧередованиеРасположенияСтраниц.ЗеркальноСверху;
		ИначеЕсли Настройка_ = "Зеркально слева" Тогда
			Чередование_ = ЧередованиеРасположенияСтраниц.ЗеркальноСлева;
		КонецЕсли;
		Результат["ЧередованиеРасположенияСтраниц"] = Чередование_;	
	КонецЕсли;
	
	Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, "ДвусторонняяПечать_");
	Если Настройка_ <>  Неопределено Тогда
		Двусторонняя_ = ТипДвустороннейПечати.Нет;
		Если Настройка_ = "Переворот вверх" Тогда
			Двусторонняя_ = ТипДвустороннейПечати.ПереворотВверх;
		ИначеЕсли Настройка_ = "Переворот влево" Тогда
			Двусторонняя_ = ТипДвустороннейПечати.ПереворотВлево;
		КонецЕсли;
		Результат["ДвусторонняяПечать"] = Двусторонняя_;
	КонецЕсли;
	
	Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, "ОриентацияСтраницы_");
	Если Настройка_ <>  Неопределено Тогда
		Ориентация_ = ОриентацияСтраницы.Портрет;
		Если Настройка_ = "Ландшафт" Тогда
			Ориентация_ = ОриентацияСтраницы.Ландшафт;
		КонецЕсли;
		Результат["ОриентацияСтраницы"] = Ориентация_;
	КонецЕсли;
	
	СписокПараметров_ = Новый Структура("ВертикальноеПоложение, Выводить, НачальнаяСтраница, ТекстВЦентре, ТекстСлева, ТекстСправа, Шрифт");
	Для Каждого Параметр_ Из СписокПараметров_ Цикл
		Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, "ВерхнийКолонтитул" + Параметр_.Ключ);
		Если Настройка_ <>  Неопределено Тогда
			Результат.ВерхнийКолонтитул[Параметр_.Ключ] = Настройка_;
		КонецЕсли;
		
		Настройка_ = ОбщегоНазначения.ХранилищеНастроекДанныхФормЗагрузить(УИДНастроек, "НижнийКолонтитул" + Параметр_.Ключ);
		Если Настройка_ <>  Неопределено Тогда
			Результат.НижнийКолонтитул[Параметр_.Ключ] = Настройка_;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция ЗначениеСвойстваЕслиСтруктураОпределена(Структура, ИмяСвойста)
	Если Структура = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Результат_ = Неопределено;
	Структура.Свойство(ИмяСвойста, Результат_);
	Возврат Результат_;
КонецФункции

Процедура ЗаполнитьКодыСекций(Документ, КодыСекций, ШаблонМедицинскогоДокументаСсылка, ПрефиксИерархии = "") Экспорт 
	СтруктураСправочникаСекции_ = Справочники.СправочникиФНСИ.ПолучитьСтруктуруКодированныхПолейПоСинониму("3QO26R99FR");
	МассивOID_ =  СтруктураСправочникаСекции_.МассивОИД;
	
	// Заполняем по code/code
	МассивИдентификаторов_ = Новый Массив();
	ИдентификаторыСекций_ = Новый Соответствие();
	ЗаполнитьКодыСекцийРекурсивно(Документ, КодыСекций, МассивИдентификаторов_, ИдентификаторыСекций_, ПрефиксИерархии);

	// Заполняем по атрибуту id
	Если МассивИдентификаторов_.Количество() > 0 Тогда
		Запрос_ = Новый Запрос(
			"ВЫБРАТЬ
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.АтрибутCode,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.codeSystem,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.codeSystemName,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.ID
			|ИЗ
			|	Справочник.СтруктураСекцийМД.СписокВозможныхИдентификаторов КАК СтруктураСекцийМДСписокВозможныхИдентификаторов
			|ГДЕ
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.ID В(&МассивID)
			|	И НЕ СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.АтрибутCode = """""
		);
		Запрос_.УстановитьПараметр("МассивID", МассивИдентификаторов_);
		
		ВыборкаСекций_ = Запрос_.Выполнить().Выгрузить();
		Для Каждого Идентификатор_ Из МассивИдентификаторов_ Цикл
			Строка_ = ВыборкаСекций_.Найти(Идентификатор_, "ID");
			Если Строка_ <> Неопределено Тогда
				Объект_ = ИдентификаторыСекций_.Получить(Идентификатор_);
				Если Объект_ <> Неопределено Тогда
					Код_ = Строка_.Получить(0);
					КодСистем_ = Строка_.Получить(1);
					КодыСекций.Вставить(
						Объект_.Секция ,
						Новый Структура(
							"Иерархия,КодСекции,codeSystem,КодОбласти,ВключатьВВизуализацию,КодыИсключаемыхПолей",
							Объект_.Иерархия,
							Код_,
							КодСистем_,
							КодОбластиПоКодуСекции(Код_),
							Неопределено,
							Неопределено
						)
					);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	// Заполняем СекцияМДСсылка
	СписокКодовСекций_ = Новый Массив();
	Для Каждого ЭлементКодыСекций_ Из КодыСекций Цикл
		СписокКодовСекций_.Добавить(ЭлементКодыСекций_.Значение.КодСекции);
	КонецЦикла;

	Запрос_ = Новый Запрос(
		"ВЫБРАТЬ
		|	СтруктураСекцийМД.Ссылка КАК Ссылка,
		|	СтруктураСекцийМД.АтрибутCode КАК Код,
		|	СтруктураСекцийМД.codeSystem КАК codeSystem,
		|	ЕСТЬNULL(СекцииМДШаблоновМедицинскихДокументов.ВключатьВВизуализацию, СтруктураСекцийМД.ВключатьВВизуализацию) КАК ВключатьВВизуализацию,
		|	СекцииМДШаблоновМедицинскихДокументов.КодируемоеПоле КАК КодируемоеПоле,
		|	КодируемыеПоляCDAДокументов.КодМинздрава КАК КодируемоеПолеКод
		|ИЗ
		|	Справочник.СтруктураСекцийМД КАК СтруктураСекцийМД
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СекцииМДШаблоновМедицинскихДокументов КАК СекцииМДШаблоновМедицинскихДокументов
		|			ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КодируемыеПоляCDAДокументов КАК КодируемыеПоляCDAДокументов
		|			ПО СекцииМДШаблоновМедицинскихДокументов.КодируемоеПоле = КодируемыеПоляCDAДокументов.Ссылка
		|		ПО (СекцииМДШаблоновМедицинскихДокументов.СекцияМД = СтруктураСекцийМД.Ссылка)
		|			И (СекцииМДШаблоновМедицинскихДокументов.ШаблонМедицинскогоДокумента = &ШаблонМедицинскогоДокумента)
		|ГДЕ
		|	СтруктураСекцийМД.АтрибутCode В(&СписокКодовСекций)
		|ИТОГИ ПО
		|	Ссылка"
	);
	Запрос_.УстановитьПараметр("СписокКодовСекций", СписокКодовСекций_);
	Запрос_.УстановитьПараметр("ШаблонМедицинскогоДокумента", ШаблонМедицинскогоДокументаСсылка);
	ВыборкаСекций_ = Запрос_.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);

	Пока ВыборкаСекций_.Следующий() Цикл
		Для Каждого ЭлементКодыСекций_ Из КодыСекций Цикл
			Если ВыборкаСекций_.Код = ЭлементКодыСекций_.Значение.КодСекции 
				И (МассивOID_.Найти(ВыборкаСекций_.codeSystem) <> Неопределено И МассивOID_.Найти(ЭлементКодыСекций_.Значение.codeSystem) <> Неопределено 
				ИЛИ ВыборкаСекций_.codeSystem = ЭлементКодыСекций_.Значение.codeSystem)
			Тогда
				ВыборкаПолей_ = ВыборкаСекций_.Выбрать();
				КодыИсключаемыхПолей_ = Новый Массив();
				ЕстьУсеченныеКодируемыеПоля_ = Ложь;
				Пока ВыборкаПолей_.Следующий() Цикл
					Если Не ЗначениеЗаполнено(ВыборкаПолей_.КодируемоеПоле) Тогда
						ЭлементКодыСекций_.Значение.ВключатьВВизуализацию = ВыборкаПолей_.ВключатьВВизуализацию;
					Иначе
						// Есть значения для отдельных полей
						Если ВыборкаПолей_.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Полный") Тогда
							КодыИсключаемыхПолей_.Добавить(ВыборкаПолей_.КодируемоеПолеКод);
						ИначеЕсли ВыборкаПолей_.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный") Тогда
							ЕстьУсеченныеКодируемыеПоля_ = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				Если ЕстьУсеченныеКодируемыеПоля_ Тогда
					ЭлементКодыСекций_.Значение.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный");
				КонецЕсли;
				ЭлементКодыСекций_.Значение.Вставить("КодыИсключаемыхПолей", КодыИсключаемыхПолей_);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьКодыСекцийРекурсивно(Документ, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии = "")
	Если ТипЗнч(Документ) = Тип("СписокXDTO") Тогда
		Для Счетчик_ = 0 По Документ.Количество() - 1 Цикл
			Данные_ = Документ.ПолучитьXDTO(Счетчик_);
			Данные_ = ПолучитьЗначениеПоПути(Данные_, "section");
			ЗаполнитьКодыСекции(Данные_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии+Строка(Счетчик_+1)+".");
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Документ) = Тип("ОбъектXDTO") Тогда
		Данные_ = ПолучитьЗначениеПоПути(Документ, "section");
		ЗаполнитьКодыСекции(Данные_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии);
	КонецЕсли;	
КонецПроцедуры

Процедура ЗаполнитьКодыСекции(Секция, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии)
	Код_ = ПолучитьКодСекции(Секция);
	КодСистем_ = ПолучитьКодСистем(Секция);
	Если Код_ <> Неопределено Тогда
		КодыСекций.Вставить(
			Секция, 
			Новый Структура(
				"Иерархия,КодСекции,codeSystem,КодОбласти,ВключатьВВизуализацию",
				ПрефиксИерархии,
				Код_,
				КодСистем_,
				КодОбластиПоКодуСекции(Код_),
				Неопределено
			)
		);
	Иначе
		Ид_ = ПолучитьЗначениеПоПути(Секция, "id");
		Если Ид_ <> Неопределено Тогда
			МассивИдентификаторов.Добавить(Ид_);
			//Ид_ = СтрЗаменить(Ид_, " ", "");
			//Ид_ = СтрЗаменить(Ид_, "-", "");
			
			ИдентификаторыСекций.Вставить(Ид_, Новый Структура("Секция, Иерархия", Секция, ПрефиксИерархии));
			
		КонецЕсли;
	КонецЕсли;
	
	// проверка вложеных секций
	СвойстваХДТО_ = Секция.Свойства();
	ВложеныйКомпонент_ = СвойстваХДТО_.Получить("component");
	Если ВложеныйКомпонент_ <> Неопределено Тогда
		ВложеныйКомпонент_ = Секция.component;
		Если ТипЗнч(ВложеныйКомпонент_) = Тип("СписокXDTO") Тогда
			Для Счетчик_ = 0 По ВложеныйКомпонент_.Количество() - 1 Цикл
				ВложеннаяСекция_ = ВложеныйКомпонент_.ПолучитьXDTO(Счетчик_);
				ЗаполнитьКодыСекцийРекурсивно(ВложеннаяСекция_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии + Строка(Счетчик_ + 1)+".");
				
			КонецЦикла;
		ИначеЕсли ТипЗнч(ВложеныйКомпонент_) = Тип("ОбъектXDTO") Тогда
			ЗаполнитьКодыСекцийРекурсивно(ВложеныйКомпонент_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии+"1.");
		КонецЕсли;
		Возврат;
	КонецЕсли;
КонецПроцедуры

Процедура ЗаполнитьКодыСекцийDOM(Компоненты, КодыСекций, ШаблонМедицинскогоДокументаСсылка, ПрефиксИерархии = "") Экспорт 
	СтруктураСправочникаСекции_ = Справочники.СправочникиФНСИ.ПолучитьСтруктуруКодированныхПолейПоСинониму("3QO26R99FR");
	МассивOID_ =  СтруктураСправочникаСекции_.МассивОИД;
	
	// Заполняем по code/code
	МассивИдентификаторов_ = Новый Массив();
	ИдентификаторыСекций_ = Новый Соответствие();
	ЗаполнитьКодыСекцийРекурсивноDOM(Компоненты, КодыСекций, МассивИдентификаторов_, ИдентификаторыСекций_, ПрефиксИерархии);

	// Заполняем по атрибуту id
	Если МассивИдентификаторов_.Количество() > 0 Тогда
		Запрос_ = Новый Запрос(
			"ВЫБРАТЬ
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.АтрибутCode,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.codeSystem,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.codeSystemName,
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.ID
			|ИЗ
			|	Справочник.СтруктураСекцийМД.СписокВозможныхИдентификаторов КАК СтруктураСекцийМДСписокВозможныхИдентификаторов
			|ГДЕ
			|	СтруктураСекцийМДСписокВозможныхИдентификаторов.ID В(&МассивID)
			|	И НЕ СтруктураСекцийМДСписокВозможныхИдентификаторов.Ссылка.АтрибутCode = """""
		);
		Запрос_.УстановитьПараметр("МассивID", МассивИдентификаторов_);
		
		ВыборкаСекций_ = Запрос_.Выполнить().Выгрузить();
		Для Каждого Идентификатор_ Из МассивИдентификаторов_ Цикл
			Строка_ = ВыборкаСекций_.Найти(Идентификатор_, "ID");
			Если Строка_ <> Неопределено Тогда
				Объект_ = ИдентификаторыСекций_.Получить(Идентификатор_);
				Если Объект_ <> Неопределено Тогда
					Код_ = Строка_.Получить(0);
					КодСистем_ = Строка_.Получить(1);
					КодыСекций.Вставить(
						Объект_.Секция ,
						Новый Структура(
							"Иерархия,КодСекции,codeSystem,КодОбласти,ВключатьВВизуализацию,КодыИсключаемыхПолей",
							Объект_.Иерархия,
							Код_,
							КодСистем_,
							КодОбластиПоКодуСекции(Код_),
							Неопределено,
							Неопределено
						)
					);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	// Заполняем СекцияМДСсылка
	СписокКодовСекций_ = Новый Массив();
	Для Каждого ЭлементКодыСекций_ Из КодыСекций Цикл
		СписокКодовСекций_.Добавить(ЭлементКодыСекций_.Значение.КодСекции);
	КонецЦикла;

	Запрос_ = Новый Запрос(
		"ВЫБРАТЬ
		|	СтруктураСекцийМД.Ссылка КАК Ссылка,
		|	СтруктураСекцийМД.АтрибутCode КАК Код,
		|	СтруктураСекцийМД.codeSystem КАК codeSystem,
		|	ЕСТЬNULL(СекцииМДШаблоновМедицинскихДокументов.ВключатьВВизуализацию, СтруктураСекцийМД.ВключатьВВизуализацию) КАК ВключатьВВизуализацию,
		|	СекцииМДШаблоновМедицинскихДокументов.КодируемоеПоле КАК КодируемоеПоле,
		|	КодируемыеПоляCDAДокументов.КодМинздрава КАК КодируемоеПолеКод
		|ИЗ
		|	Справочник.СтруктураСекцийМД КАК СтруктураСекцийМД
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СекцииМДШаблоновМедицинскихДокументов КАК СекцииМДШаблоновМедицинскихДокументов
		|			ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КодируемыеПоляCDAДокументов КАК КодируемыеПоляCDAДокументов
		|			ПО СекцииМДШаблоновМедицинскихДокументов.КодируемоеПоле = КодируемыеПоляCDAДокументов.Ссылка
		|		ПО (СекцииМДШаблоновМедицинскихДокументов.СекцияМД = СтруктураСекцийМД.Ссылка)
		|			И (СекцииМДШаблоновМедицинскихДокументов.ШаблонМедицинскогоДокумента = &ШаблонМедицинскогоДокумента)
		|ГДЕ
		|	СтруктураСекцийМД.АтрибутCode В(&СписокКодовСекций)
		|ИТОГИ ПО
		|	Ссылка"
	);
	Запрос_.УстановитьПараметр("СписокКодовСекций", СписокКодовСекций_);
	Запрос_.УстановитьПараметр("ШаблонМедицинскогоДокумента", ШаблонМедицинскогоДокументаСсылка);
	ВыборкаСекций_ = Запрос_.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);

	Пока ВыборкаСекций_.Следующий() Цикл
		Для Каждого ЭлементКодыСекций_ Из КодыСекций Цикл
			Если ВыборкаСекций_.Код = ЭлементКодыСекций_.Значение.КодСекции 
				И (МассивOID_.Найти(ВыборкаСекций_.codeSystem) <> Неопределено И МассивOID_.Найти(ЭлементКодыСекций_.Значение.codeSystem) <> Неопределено 
				ИЛИ ВыборкаСекций_.codeSystem = ЭлементКодыСекций_.Значение.codeSystem)
			Тогда
				ВыборкаПолей_ = ВыборкаСекций_.Выбрать();
				КодыИсключаемыхПолей_ = Новый Массив();
				ЕстьУсеченныеКодируемыеПоля_ = Ложь;
				Пока ВыборкаПолей_.Следующий() Цикл
					Если Не ЗначениеЗаполнено(ВыборкаПолей_.КодируемоеПоле) Тогда
						ЭлементКодыСекций_.Значение.ВключатьВВизуализацию = ВыборкаПолей_.ВключатьВВизуализацию;
					Иначе
						// Есть значения для отдельных полей
						Если ВыборкаПолей_.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Полный") Тогда
							КодыИсключаемыхПолей_.Добавить(ВыборкаПолей_.КодируемоеПолеКод);
						ИначеЕсли ВыборкаПолей_.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный") Тогда
							ЕстьУсеченныеКодируемыеПоля_ = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				Если ЕстьУсеченныеКодируемыеПоля_ Тогда
					ЭлементКодыСекций_.Значение.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный");
				КонецЕсли;
				ЭлементКодыСекций_.Значение.Вставить("КодыИсключаемыхПолей", КодыИсключаемыхПолей_);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьКодыСекцийРекурсивноDOM(Компоненты, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии = "")
	Компонент_ = Компоненты.ПолучитьСледующий();
	Счетчик_ = 0;
	Пока Компонент_ <> Неопределено Цикл
		Данные_ = Компонент_.ПолучитьЭлементыПоИмени("section")[0];
		ЗаполнитьКодыСекцииDOM(Данные_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии+Строка(Счетчик_+1)+".");
		Счетчик_ = Счетчик_ + 1;
		Компонент_ = Компоненты.ПолучитьСледующий();
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьКодыСекцииDOM(Секция, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии)
	Код_ = ВыполнитьЗапросXPath(Секция, "h:code/@code", ТипРезультатаDOMXPath.Строка);
	КодСистем_ = ВыполнитьЗапросXPath(Секция, "h:code/@codeSystem", ТипРезультатаDOMXPath.Строка);
	Если Код_ <> Неопределено Тогда
		КодыСекций.Вставить(
			Секция, 
			Новый Структура(
				"Иерархия,КодСекции,codeSystem,КодОбласти,ВключатьВВизуализацию",
				ПрефиксИерархии,
				Код_,
				КодСистем_,
				КодОбластиПоКодуСекции(Код_),
				Неопределено
			)
		);
	Иначе
		Ид_ = Секция.ПолучитьАтрибут("id");
		Если Ид_ <> Неопределено Тогда
			МассивИдентификаторов.Добавить(Ид_);
			ИдентификаторыСекций.Вставить(Ид_, Новый Структура("Секция, Иерархия", Секция, ПрефиксИерархии));
			
		КонецЕсли;
	КонецЕсли;
	
	ВложеныеСекции_ = ВыполнитьЗапросXPath(Секция, "h:component", ТипРезультатаDOMXPath.УпорядоченныйИтераторУзлов);
	ЗаполнитьКодыСекцийРекурсивноDOM(ВложеныеСекции_, КодыСекций, МассивИдентификаторов, ИдентификаторыСекций, ПрефиксИерархии);
КонецПроцедуры

// Функция получает область макета согласно заданным приоритетам.
//
// Параметры:
//  Макет				 - ТабличныйДокумент	 -  Макет, из которого выбирается область.
//  Элементы			 - Строка, Массив строк	 -  Один элемент или массив приоритетных элементов 
//                                                  (поиск идет последовательно, если область найдена, 
//                                                  то возвращается значение)
//  Секция				 - Строка	 -  Область, в которой выполняется поиск элемента
//  ВертикальнаяОбласть	 - Строка	 - 	Область, которую нужно вернуть из выбранной области.
// Возвращаемое значение:
//  ТабличныйДокумент -  Документ, содержащий найденую область.
Функция ПолучитьОбластьМакета(Макет, Элементы, Секция=Неопределено, ВертикальнаяОбласть=Неопределено)
	МассивСекций_ = Новый Массив();
	Если Секция <> Неопределено и Секция <> "CDA" Тогда
		МассивСекций_.Добавить(Секция);
	КонецЕсли;
	МассивСекций_.Добавить("CDA");
	
	Если ТипЗнч(Элементы) = Тип("Строка") Тогда
		Элементы_ = Новый Массив();
		Элементы_.Добавить(Элементы);
		Если Не Элементы = "img" Тогда
			Элементы_.Добавить("default");
		КонецЕсли;
	Иначе
		Элементы_ = Элементы;
	КонецЕсли;	
	
	ОбластиСекции_ = Макет.Области;
	Для Каждого Секция_ Из МассивСекций_ Цикл
		// Если в макете нет такой области, то переходим к следующей
		Префикс_ = "";
		ИмяСекции_ = Секция_;
		Если Секция_ <> "CDA" Тогда
			ИмяСекции_ = "CDA_" + Секция_;
			Префикс_ = Секция_ + "_";
		КонецЕсли;
		Если ОбластиСекции_.Найти(ИмяСекции_) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого Элемент_ Из Элементы_ Цикл
			ИмяОбласти_  = Префикс_  + Элемент_;
			Область_ = ОбластиСекции_.Найти(ИмяОбласти_);
			Если Область_ <> Неопределено Тогда 
				Результат_ = Макет.ПолучитьОбласть(ИмяОбласти_);
				Если ВертикальнаяОбласть <> Неопределено Тогда
					Результат_ = Результат_.ПолучитьОбласть(ВертикальнаяОбласть);
				КонецЕсли;
				Возврат Результат_;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

// Функция возвращает объект или значение от указанного узла по пути.
//
// Параметры:
//  ТекущийУзел	 - ОбъектXDTO	 - начальный объект.
//  Путь		 - Строка	 - последовательность наследников
// Возвращаемое значение:
//  ОбъектXDTO, Строка - результирующий узел (строка) или Неопределено.
Функция ПолучитьЗначениеПоПути(ТекущийУзел, Путь)  Экспорт
	Если ТекущийУзел = Неопределено ИЛИ ТипЗнч(ТекущийУзел) <> Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Чтобы избавиться от исключений, попробуем разложить путь по символу "/" и,
	// если остаются только идентификаторы, пройтись по ним, как по свойствам.
	ЧастиПути_ = СтрРазделить(Путь, "/");
	ТолькоИдентификаторы_ = ЗначениеЗаполнено(Путь);
	Для Каждого Идентификатор_ Из ЧастиПути_ Цикл
		Если Не Истина = ЭтоИдентификатор(Идентификатор_) Тогда
			ТолькоИдентификаторы_ = Ложь;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Истина = ТолькоИдентификаторы_ Тогда
		// Если при обходе встретятся списки, то нужно будет к ним возвращаться.
		// Заведем для этого стек.
		СтекОбъектов_ = Новый Массив(ЧастиПути_.Количество() + 1);
		СтекИндексов_ = Новый Массив(ЧастиПути_.Количество() + 1);
		СтекОбъектов_[0] = ТекущийУзел;
		СтекИндексов_[0] = 0;
		Глубина_ = 0;
		Пока Глубина_ >= 0 Цикл
			ОбъектXDTO_ = СтекОбъектов_[Глубина_];
			Если Глубина_ = ЧастиПути_.Количество() Тогда
				// Поможем сборщику мусора.
				СтекОбъектов_.Очистить();
				// Платформа выдает ошибку, если получился список XDTO. Сделаем так же.
				Если ТипЗнч(ОбъектXDTO_) = Тип("СписокXDTO") Тогда
					Возврат Неопределено;
				КонецЕсли;
				Возврат ОбъектXDTO_;
			КонецЕсли;
			Идентификатор_ = ЧастиПути_[Глубина_];
			Если ТипЗнч(ОбъектXDTO_) = Тип("ОбъектXDTO") Тогда
				Если Ложь
					Или СтекИндексов_[Глубина_] > 0
					Или Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектXDTO_, Идентификатор_)
				Тогда
					Глубина_ = Глубина_ - 1;
					Продолжить;
				КонецЕсли;
				СтекИндексов_[Глубина_] = 1;
				Глубина_ = Глубина_ + 1;
				СтекИндексов_[Глубина_] = 0;
				СтекОбъектов_[Глубина_] = ОбъектXDTO_[Идентификатор_];
			ИначеЕсли ТипЗнч(ОбъектXDTO_) = Тип("СписокXDTO") Тогда
				Индекс_ = СтекИндексов_[Глубина_];
				Если Ложь
					Или Индекс_ >= ОбъектXDTO_.Количество()
					Или Не ТипЗнч(ОбъектXDTO_[Индекс_]) = Тип("ОбъектXDTO")
					Или Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектXDTO_[Индекс_], Идентификатор_)
				Тогда
					Глубина_ = Глубина_ - 1;
					Продолжить;
				КонецЕсли;
				СтекИндексов_[Глубина_] = Индекс_ + 1;
				Глубина_ = Глубина_ + 1;
				СтекИндексов_[Глубина_] = 0;
				СтекОбъектов_[Глубина_] = ОбъектXDTO_[Индекс_][Идентификатор_];
			Иначе
				Глубина_ = Глубина_ - 1;
				Продолжить;
			КонецЕсли;
		КонецЦикла;
		// Поможем сборщику мусора.
		СтекОбъектов_.Очистить();
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		Результат_ = ТекущийУзел.Получить(Путь);
		Возврат Результат_;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
КонецФункции

Функция ВыбратьЗаполненноеЗначениеПоПутям(ТекущийУзел, МассивПутей)
	Для Каждого Путь_ Из МассивПутей Цикл
		Значение_ = ПолучитьЗначениеПоПути(ТекущийУзел, Путь_);
		Если Значение_ <> Неопределено Тогда
			Возврат Значение_;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

//// Функция возвращает объект или значение по пути.
////
//// Параметры:
////  ТекущийУзел	 - ОбъектXDTO	 - начальный объект.
////  МассивУзлов	 - 	Массив строк - массив, содержащий последовательность узлов
//// Возвращаемое значение:
////  ОбъектXDTO, Строка - результирующий узел (строка) или Неопределено.
//Функция ПолучитьЗначениеПоПутиРекурсивно(ТекущийУзел, МассивУзлов)
//	Если МассивУзлов.Количество() = 0
//		Тогда Возврат ТекущийУзел;
//	КонецЕсли;
//	СвойстваТекущегоУзла_ = ТекущийУзел.Свойства();
//	
//	СледующийУзел_ = СвойстваТекущегоУзла_.Получить(МассивУзлов[0]);
//	Если СледующийУзел_ = Неопределено Тогда
//		Возврат Неопределено;
//	КонецЕсли;
//	Если СледующийУзел_.ВерхняяГраница = 1 Тогда
//		СледующийУзел_ = ТекущийУзел.Получить(МассивУзлов[0]);
//		МассивУзлов.Удалить(0);
//		
//	Иначе
//		СписокУзлов_ = ТекущийУзел.ПолучитьСписок(МассивУзлов[0]);
//		МассивУзлов.Удалить(0);
//		Для Каждого Узел_ Из СписокУзлов_ Цикл
//			Следующий_ = ПолучитьЗначениеПоПутиРекурсивно(Узел_, МассивУзлов);	
//			Если Следующий_ <> Неопределено Тогда
//				Возврат Следующий_;
//			КонецЕсли;
//		КонецЦикла;
//		Возврат Следующий_;
//	КонецЕсли;
//	
//	
//	Возврат ПолучитьЗначениеПоПутиРекурсивно(СледующийУзел_, МассивУзлов);	
//КонецФункции

// Процедура добавляет заполненную область в результирующий документ.
//
// Параметры:
//  Документ			 - ТабличныйДокумент	 - документ, в который осуществляется вывод.
//  ИмяСекции	 - Строка	 -  идентификатор области (секции)
//  Область	 - 	ОбъектXDTO -  объект, который содержит секцию
//  Макет	- ТабличныйДокумент	 - документ, в котором содержится оформление документа
Процедура ЗаполнитьОбласть(Документ, ИмяСекции, Область, Макет, ПолныйДокумент = Истина, ДокументDOM, ВизуализаторОбработка, СтандартныйВизуализатор, КодыСекций)

	// Проверка следует ли включать область в усеченный документ
	Если НЕ ПолныйДокумент Тогда
		ДобавитьОбластьВДокумент_ = Ложь;
		Если ВизуализаторОбработка <> Неопределено Или СтандартныйВизуализатор <> Неопределено Тогда
			Попытка
				ДобавитьОбластьВДокумент_ = ВизуализаторОбработка.ВключатьВУсеченныйДокумент(Область);
			Исключение
				ДобавитьОбластьВДокумент_ = СтандартныйВизуализатор.ВключатьВУсеченныйДокумент(Область);
			КонецПопытки;
		Иначе
			ДобавитьОбластьВДокумент_ = Неопределено;
		КонецЕсли;
		
		Если ДобавитьОбластьВДокумент_ = Неопределено Тогда
			ВключатьВВизуализацию_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций.Получить(Область), "ВключатьВВизуализацию");
			ДобавитьОбластьВДокумент_ = (ВключатьВВизуализацию_ = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный"));
		КонецЕсли;
		Если НЕ ДобавитьОбластьВДокумент_ Тогда 
			Возврат;
		Иначе
			КодыИсключаемыхПолей_ = ЗначениеСвойстваЕслиСтруктураОпределена(КодыСекций.Получить(Область), "КодыИсключаемыхПолей");
		КонецЕсли;
	Иначе
		КодыИсключаемыхПолей_ = Неопределено;
	КонецЕсли;


	Док_ = Новый ТабличныйДокумент();
	
	СвойстваХДТО_ = Область.Свойства();
	Заголовок_ = СвойстваХДТО_.Получить("title");
	Если Заголовок_ <> Неопределено Тогда
		МакетЗаголовка_ = ПолучитьОбластьМакета(Макет, "title", ИмяСекции);
		МакетЗаголовка_.Параметры.строка = ПолучитьТекст(Область.title);
		Док_.Вывести(МакетЗаголовка_);
	КонецЕсли;
	
	Текст_ = СвойстваХДТО_.Получить("text");
	Если Текст_ <> Неопределено Тогда
		ОбластьТекст = Область.text;
		Если ТипЗнч(ОбластьТекст) = Тип("Строка") Тогда
			ВывестиАбзац(Док_, ИмяСекции, ОбластьТекст, Макет, , ДокументDOM);
		ИначеЕсли ТипЗнч(ОбластьТекст) = Тип("ОбъектXDTO") Тогда
			ПоследовательностьХДТООбъекта = ОбластьТекст.Последовательность();
			Если ПоследовательностьХДТООбъекта.Количество() = 1 Тогда
				Если ПоследовательностьХДТООбъекта.ПолучитьСвойство(0) =  Неопределено Тогда 
					Строка = ПоследовательностьХДТООбъекта.ПолучитьТекст(0);
					ВывестиАбзац(Док_, ИмяСекции, Строка, Макет, ,ДокументDOM);
				Иначе
					ВывестиПоследовательностьXDTO(ПоследовательностьХДТООбъекта, Док_, ИмяСекции, Макет,,, Область, ДокументDOM, КодыИсключаемыхПолей_);
				КонецЕсли;
			Иначе 	
				ВывестиПоследовательностьXDTO(ПоследовательностьХДТООбъекта, Док_, ИмяСекции, Макет,,, Область, ДокументDOM, КодыИсключаемыхПолей_);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Документ.Вывести(Док_);
	
	// Заполнение вложеных секций.
	ВложеныйКомпонент_ = СвойстваХДТО_.Получить("component");
	Если ВложеныйКомпонент_ <> Неопределено Тогда
		ВложеныйКомпонент_ = Область.component;
		Если ТипЗнч(ВложеныйКомпонент_) = Тип("СписокXDTO") Тогда
			Для Счетчик_ = 0 По ВложеныйКомпонент_.Количество() - 1 Цикл
				ВложеннаяСекция_ = ВложеныйКомпонент_.ПолучитьXDTO(Счетчик_).section;
				ЗаполнитьОбласть(
					Документ, 
					ИмяСекции, 
					ВложеннаяСекция_, 
					Макет, 
					ПолныйДокумент, 
					ДокументDOM, 
					ВизуализаторОбработка, 
					СтандартныйВизуализатор, 
					КодыСекций
				);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ВложеныйКомпонент_) = Тип("ОбъектXDTO") Тогда
			ВложеннаяСекция_ = ВложеныйКомпонент_.section;
			ЗаполнитьОбласть(
				Документ, 
				ИмяСекции, 
				ВложеннаяСекция_, 
				Макет, 
				ПолныйДокумент, 
				ДокументDOM, 
				ВизуализаторОбработка, 
				СтандартныйВизуализатор, 
				КодыСекций
			);
		КонецЕсли;
		Возврат;
	КонецЕсли;
КонецПроцедуры

// Функция возвращает строку с ФИО.
//
// Параметры:
//  ОбъектИмя	 - 	ОбъектXDTO, Строка - объект, в котором записано имя.
// Возвращаемое значение:
//  Строка - ФИО
Функция ПолучитьИмя(ОбъектИмя, ИспользоватьПрефикс = Истина, ИспользоватьСуффикс = Истина)
	Если ОбъектИмя = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ТипЗнч(ОбъектИмя) = Тип("ЭлементDOM") Тогда
		Если ОбъектИмя = Неопределено Тогда
			Возврат "";
		КонецЕсли;
		Если ТипЗнч(ОбъектИмя) = Тип("Строка") Тогда
			Возврат ОбъектИмя;
		КонецЕсли;
		
		Результат_ = "";
		Если ИспользоватьПрефикс Тогда
			Префикс_ = НайтиЭлемент(ОбъектИмя, "prefix");
			Если Префикс_ <> Неопределено Тогда
				Результат_ = Результат_ + СокрЛП(Префикс_.ТекстовоеСодержимое) + " ";
			КонецЕсли;
		КонецЕсли;
		
		Фамилия_ = НайтиЭлемент(ОбъектИмя, "family");
		Если Фамилия_ <> Неопределено Тогда
			Результат_ = Результат_ + СокрЛП(Фамилия_.ТекстовоеСодержимое) + " ";
		КонецЕсли;
		
		Имя_ = НайтиЭлемент(ОбъектИмя, "given");
		Если Имя_ <> Неопределено Тогда
			Результат_ = Результат_ + СокрЛП(Имя_.ТекстовоеСодержимое) + " ";
		КонецЕсли;
		
		Отчество_ = НайтиЭлемент(ОбъектИмя, "suffix");
		Если Отчество_ <> Неопределено Тогда
			Результат_ = Результат_ + СокрЛП(Отчество_.ТекстовоеСодержимое) + " ";
		КонецЕсли;
		Возврат Результат_;
	КонецЕсли;
	Если ТипЗнч(ОбъектИмя) = Тип("Строка") Тогда
		Возврат ОбъектИмя;
	КонецЕсли;
	СвойстваОбъекта_ = ОбъектИмя.Свойства();
	Имя_ = "";
	Если ИспользоватьПрефикс Тогда
		ДополнитьИмя(Имя_, ОбъектИмя, СвойстваОбъекта_, "prefix");
	КонецЕсли;
	ДополнитьИмя(Имя_, ОбъектИмя, СвойстваОбъекта_, "family");
	ДополнитьИмя(Имя_, ОбъектИмя, СвойстваОбъекта_, "given");
	ДополнитьИмя(Имя_, ОбъектИмя, СвойстваОбъекта_, "suffix");
	ДополнитьИмя(Имя_, ОбъектИмя, СвойстваОбъекта_, "Patronymic");
	
	Возврат Имя_;
КонецФункции

Функция ПолучитьАдрес(Объект)
	Результат_ = "";
	Адрес_ = ПолучитьЗначениеПоПути(Объект, "streetAddressLine");
	АдресПредставление_ = "";
	Если ТипЗнч(Адрес_) = Тип("Строка") Тогда
		АдресПредставление_ = Адрес_;
	КонецЕсли;
	Индекс_ = ПолучитьЗначениеПоПути(Объект, "postalCode");
	Если ТипЗнч(Индекс_) = Тип("Строка") И ЗначениеЗаполнено(Индекс_) И СтрНайти(АдресПредставление_, Индекс_) = 0 Тогда
		Результат_ = СтрШаблон("%1, ", Индекс_);
	КонецЕсли;
	Результат_ = Результат_ + АдресПредставление_;
	Возврат Результат_;
КонецФункции

Процедура ДополнитьИмя(Имя, ОбъектИмя, СвойстваОбъекта, Свойство)
	Если СвойстваОбъекта.Получить(Свойство) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ТипЗнч(ОбъектИмя[Свойство]) = Тип("Строка") Тогда
		Имя = Имя + ОбъектИмя[Свойство] + " ";
		Возврат;
	КонецЕсли;
	Если ТипЗнч(ОбъектИмя[Свойство]) = Тип("СписокXDTO") Тогда
		Для Каждого Элемент_ Из ОбъектИмя[Свойство] Цикл
			Если ТипЗнч(Элемент_) = Тип("Строка") Тогда
				Имя = Имя + Элемент_ + " ";
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	Если ТипЗнч(ОбъектИмя[Свойство]) = Тип("ОбъектXDTO") Тогда
		ЗаписьJSON_ = Новый ЗаписьJSON;
		Параметры_ = Новый ПараметрыЗаписиJSON(, Символы.Таб);
		ЗаписьJSON_.УстановитьСтроку(Параметры_);
		Попытка
			ФабрикаXDTO.ЗаписатьJSON(ЗаписьJSON_, ОбъектИмя[Свойство], НазначениеТипаXML.Явное);
		Исключение
			Сообщить(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		Строка_ = ЗаписьJSON_.Закрыть();
		ЧтениеJSON_ = Новый ЧтениеJSON();
		ЧтениеJSON_.УстановитьСтроку(Строка_);
		Пока ЧтениеJSON_.Прочитать() Цикл	
			Если Истина
				И ЧтениеJSON_.ТипТекущегоЗначения = ТипЗначенияJSON.ИмяСвойства 
				И ЧтениеJSON_.ТекущееЗначение = "#value"
			Тогда
				ЧтениеJSON_.Прочитать();
				Если ЧтениеJSON_.ТипТекущегоЗначения = ТипЗначенияJSON.Строка Тогда
					Имя = Имя + ЧтениеJSON_.ТекущееЗначение + " ";
				КонецЕсли;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ЧтениеJSON_.Закрыть();
	КонецЕсли;
КонецПроцедуры

// Функция возвращает отформатированную дату.
//
// Параметры:
//  Строка	 - Строка	 - строка с датой.
// Возвращаемое значение:
// Строка  - отформатированная дата.
Функция ПолучитьДату(Строка)
	Если Строка = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	Возврат Сред(Строка, 7, 2) + "." +  Сред(Строка, 5, 2) + "." + Сред(Строка, 1, 4);
КонецФункции

// Функция возвращает отформатированную дату.
//
// Параметры:
//  Строка	 - Строка	 - строка с датой.
// Возвращаемое значение:
// Строка  - отформатированное время (если задано в строке)
Функция ПолучитьВремя(Строка, ВыводитьСекунды = Ложь)
	Если СтрДлина(Строка) >12 Тогда
		Время_ = СтрШаблон("%1:%2", Сред(Строка, 9, 2), Сред(Строка, 11, 2));
		Если ВыводитьСекунды И СтрДлина(Строка) > 13 Тогда
			Время_ = СтрШаблон("%1:%2", Время_, Сред(Строка, 13, 2));
		КонецЕсли;
		Возврат Время_;
	КонецЕсли;
	Возврат "";
КонецФункции

// Функция возвращает текст, который находится внутри элемента и его потомков без переводов строк.
//
// Параметры:
//  Объект	 - ОбъектXDTO	 - объект, из которого извлекается текст.
// Возвращаемое значение:
//  Строка - полученный текст без переводов строк.
Функция ПолучитьТекст(Объект, ВыполнятьПереносАбзаца = Истина, ИсключитьЭлементы = Неопределено) Экспорт
	Если ИсключитьЭлементы = Неопределено Тогда
		ИсключитьЭлементы = Новый Массив;
	КонецЕсли;
	Если ТипЗнч(Объект) <> Тип("Строка") Тогда
		Текст_ = ПолучитьТекстРекурсивно(Объект, ВыполнятьПереносАбзаца, ИсключитьЭлементы);
	Иначе
		Текст_ = Объект;
	КонецЕсли;
	МассивПодстрок_ = СтрРазделить(Текст_, Символы.ПС, Ложь);
	МассивРезультат_ = Новый Массив();
	Для Счетчик_ = 0 По МассивПодстрок_.ВГраница() Цикл
		МассивПодстрок_[Счетчик_] = СтроковыеФункцииКлиентСервер.УдалитьПовторяющиесяСимволы(МассивПодстрок_[Счетчик_], " ");
		МассивПодстрок_[Счетчик_] = СтроковыеФункцииКлиентСервер.УдалитьПовторяющиесяСимволы(МассивПодстрок_[Счетчик_], Символы.Таб);
		Если МассивПодстрок_[Счетчик_] <> "" Тогда
			МассивРезультат_.Добавить(МассивПодстрок_[Счетчик_]);
		КонецЕсли;
	КонецЦикла;
	Текст_ = СтрСоединить(МассивРезультат_, " ");
	Текст_ = СтрЗаменить(Текст_, "<br>", Символы.ПС);
	Текст_ = СтрЗаменить(Текст_, "<br/>", Символы.ПС);
	Текст_ = СтрЗаменить(Текст_, "<br />", Символы.ПС);
	Возврат Текст_;
КонецФункции

// Функция рекурсивно обходит содержимое XDTO-объекте и возвращает текст, который находится внутри него.
//
// Параметры:
//  Объект	 - ОбъектXDTO	 - объект, из которого извлекается текст.
// Возвращаемое значение:
//  Строка - полученный текст 
Функция ПолучитьТекстРекурсивно(Объект, ВыполнятьПереносАбзаца = Истина, ИсключитьЭлементы = Неопределено)
	Если ИсключитьЭлементы = Неопределено Тогда
		ИсключитьЭлементы = Новый Массив;
	КонецЕсли;
	Текст = "";
	Если ТипЗнч(Объект)=Тип("Строка") Тогда
		Возврат Текст + Объект;
	ИначеЕсли ТипЗнч(Объект) = Тип("ОбъектXDTO") Тогда
		Потомки_ = Объект.Последовательность();
		Для Счетчик_ = 0 По Потомки_.Количество() - 1 Цикл
			Свойство_ = Потомки_.ПолучитьСвойство(Счетчик_);
			Если Свойство_ = Неопределено Тогда
				Текст = Текст + Потомки_.ПолучитьТекст(Счетчик_);
			ИначеЕсли ТипЗнч(Свойство_) = Тип("СвойствоXDTO") Тогда
				Если ИсключитьЭлементы.Найти(Свойство_.Имя) <> Неопределено Тогда
					Продолжить;
				ИначеЕсли Свойство_.Имя = "br" Тогда
					Текст = Текст + "<br/>";
				ИначеЕсли Свойство_.Имя = "paragraph" Тогда
					Текст = Текст + ПолучитьТекстРекурсивно(Потомки_.ПолучитьЗначение(Счетчик_));
					Если ВыполнятьПереносАбзаца Тогда
						Текст = Текст + "<br/>";
					КонецЕсли;
				ИначеЕсли Свойство_.Имя = "list" Тогда
					Текст = Текст + (?(ПустаяСтрока(Текст), "",  "<br/>")) + ПолучитьТекстСписка(Потомки_.ПолучитьЗначение(Счетчик_));
				ИначеЕсли Свойство_.Имя = "caption"	Тогда
					Текст = Текст + ПолучитьТекстРекурсивно(Потомки_.ПолучитьЗначение(Счетчик_)) + "<br/>";
				Иначе
					ТекстПотомка_ = ПолучитьТекстРекурсивно(Потомки_.ПолучитьЗначение(Счетчик_), ВыполнятьПереносАбзаца);
					Текст = Текст + ТекстПотомка_;
					Если Свойство_.Имя = "content" И Не ЗначениеЗаполнено(ТекстПотомка_) Тогда
						Текст = Текст + " ";
					КонецЕсли;
					
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		Возврат Текст;
	КонецЕсли;
	
КонецФункции

// Процедура выводит в табличный документ последовательность элементов CDA-документа.
//
// Параметры:
//  Последовательность	 - ПоследовательностьXDTO - последовательность объектовXDTO, которые нужно вывести.
//  Документ			 - ТабличныйДокумент	 - документ, в который осуществляется вывод 
//  ИмяСекции			 - Строка	 - название секции, в которую осуществляется вывод
//  Макет				 - ТабличныйДокумент	 - документ, в котором содержится оформление документа.
//  Текст				 - Строка	 -  строка, в которую "накапливается" текст, расположеный непосредственно в элементе text
//  Глубина				 - Число	 -  глубина вложенности, нужна для "накопления" текста, который находится непосредственно в элементе text
Процедура ВывестиПоследовательностьXDTO(Последовательность, Документ, ИмяСекции, Макет, Текст="", Глубина = 0, Область = Неопределено, ДокументDOM, КодыИсключаемыхПолей = Неопределено)
	Для Счетчик=0 По Последовательность.Количество() - 1 Цикл
		Свойство_ = Последовательность.ПолучитьСвойство(Счетчик);
		Если Свойство_ =  Неопределено Тогда 
			Строка_ = Последовательность.ПолучитьТекст(Счетчик);
			Текст = Текст + Строка_ + " ";
		ИначеЕсли Свойство_.Имя = "br" Тогда
			Текст = Текст + "<br/>";
		ИначеЕсли Свойство_.Имя = "paragraph" Тогда
			Если Текст <> "" Тогда
				ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
				Текст = "";
			КонецЕсли;
			Параграф_ = Последовательность.ПолучитьЗначение(Счетчик);
			Строка_ = ПолучитьТекст(Параграф_);
			ВывестиАбзац(Документ, ИмяСекции, Параграф_, Макет, Параграф_, ДокументDOM);	
		ИначеЕсли ТипЗнч(Последовательность.ПолучитьЗначение(Счетчик)) = Тип("Строка") Тогда
			Строка_ = ПолучитьТекст(Последовательность.ПолучитьЗначение(Счетчик));
			Текст = Текст + Строка_;		
		ИначеЕсли Свойство_.Имя = "table" Тогда
			Если Текст <> "" Тогда
				ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
				Текст = "";
			КонецЕсли;
			ВывестиТаблицу(Документ, ИмяСекции, Последовательность.ПолучитьЗначениеXDTO(Счетчик), Макет, КодыИсключаемыхПолей);
		ИначеЕсли Свойство_.Имя = "list" Тогда
			Если Текст <> "" Тогда
				ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
				Текст = "";
			КонецЕсли;
			ВывестиСписок(Документ, ИмяСекции, Последовательность.ПолучитьЗначениеXDTO(Счетчик), Макет);
		ИначеЕсли Свойство_.Имя = "renderMultiMedia" Тогда
			Если Текст <> "" Тогда
				ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
				Текст = "";
			КонецЕсли;
			ВывестиИзображение(Документ, ИмяСекции, Последовательность.ПолучитьЗначениеXDTO(Счетчик), Макет, ДокументDOM);
		ИначеЕсли Свойство_.Имя = "linkHtml" Тогда
			Если Текст <> "" Тогда
				ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
				Текст = "";
			КонецЕсли;
			ВывестиСсылку(Документ, ИмяСекции, Последовательность.ПолучитьЗначениеXDTO(Счетчик), Макет);	
			
		Иначе
			
			Область_ = Последовательность.ПолучитьЗначение(Счетчик).Последовательность();
			ВывестиПоследовательностьXDTO(Область_, Документ, ИмяСекции, Макет, Текст, Глубина + 1, Область, ДокументDOM);	
		КонецЕсли;
	КонецЦикла;
	Если Текст <> "" и Глубина = 0 Тогда
		ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, , ДокументDOM);
		Текст = "";
	КонецЕсли;
КонецПроцедуры

Процедура ВывестиИзображение(Документ, ИмяСекции, Изображение, Макет, ДокументDOM)
	ОбластьИзображения_ = ПолучитьОбластьМакета(Макет, "img", ИмяСекции);
	ОбластьИзображения_ = ВывестиИзображениеВОбласть(ОбластьИзображения_, Изображение, Макет, ДокументDOM);
	Если ОбластьИзображения_ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Документ.Вывести(ОбластьИзображения_);
КонецПроцедуры

Функция ВывестиИзображениеВОбласть(ОбластьИзображения, Изображение, Макет, ДокументDOM, ПервоеИзображение = Истина)
	Идентификатор_ = Изображение.referencedObject;
	
	РазыменовательПИ = ДокументDOM.СоздатьРазыменовательПИ();
	
	ОписаниеИзображения_ = ДокументDOM.ВычислитьВыражениеXPath("//*[@ID='"+Идентификатор_+"']/*[local-name()='value']",ДокументDOM,РазыменовательПИ, ТипРезультатаDOMXPath.Строка).ПолучитьСледующий();
	
	Если ОписаниеИзображения_ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ДДанные_ = Неопределено;
	ПредставлениеКартинки_ = ОписаниеИзображения_.Атрибуты.ПолучитьИменованныйЭлемент("representation");
	Если Не ПредставлениеКартинки_ = Неопределено И ПредставлениеКартинки_.Значение = "B64" Тогда
		ДанныеИзобр_ = ДокументDOM.ВычислитьВыражениеXPath(".",ОписаниеИзображения_,РазыменовательПИ, ТипРезультатаDOMXPath.Строка).ПолучитьСледующий().ТекстовоеСодержимое;	
		ДДанные_ = Base64Значение(ДанныеИзобр_);
	Иначе
		Если СтрДлина(Идентификатор_) = 36 Тогда
			ДДанные_ = ПолучитьИзВременногоХранилища("e1cib/tempstorage/" + Идентификатор_);
		ИначеЕсли СтрДлина(Идентификатор_) = 32 Тогда

			Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
				// Если нет подсистемы работы с файлами, то и ссылок картинки в файлах быть не может.
				Ссылка_ = ОписаниеИзображения_.ПолучитьЭлементыПоИмени ("reference");
				Если Ссылка_.Количество() > 0 Тогда
					ФайлСсылка_ = ПолучитьОбъектПоНавигационнойСсылке(Ссылка_[0].ПолучитьУзелАтрибута("value").Значение);
					Если ФайлСсылка_ = Неопределено Тогда
						ХранилищеКартинки_ = ПолучитьОбъектПоНавигационнойСсылке("e1cib/data/РегистрСведений.ДвоичныеДанныеФайлов.ДвоичныеДанныеФайла?Файл="+Идентификатор_);
						ДДанные_ = ХранилищеКартинки_.Получить();
					Иначе
						МодульРаботаСФайламиСлужебныйВызовСервера_ = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
						ДДанные_ = МодульРаботаСФайламиСлужебныйВызовСервера_.ДанныеФайлаИДвоичныеДанные(ФайлСсылка_).ДвоичныеДанные;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
	    КонецЕсли;
	КонецЕсли;
	Если ДДанные_ = Неопределено ИЛИ ОбластьИзображения.Рисунки.Количество() = 0 Тогда 
		Возврат Неопределено;
	КонецЕсли;
	
	Рис_ = ОбластьИзображения.Рисунки.Получить(0);
	Если ПервоеИзображение Тогда
		Рис_.Имя = Идентификатор_;
		Рис_.Картинка = Новый Картинка(ДДанные_);
		// в макете высота строки задается в пунктах, 1пт = 0,3528 мм.
		Рис_.Высота = Окр(ОбластьИзображения.Области.img.ВысотаСтроки * 0.3528);
	Иначе
		НовыйРисунок_ = ОбластьИзображения.Рисунки.Добавить(ТипРисункаТабличногоДокумента.Картинка);
		НовыйРисунок_.Картинка = Новый Картинка(ДДанные_);
		НовыйРисунок_.Высота = Рис_.Высота;
		НовыйРисунок_.Ширина = Рис_.Ширина;
		НовыйРисунок_.Лево = Рис_.Ширина * (ОбластьИзображения.Рисунки.Количество() - 1);
		НовыйРисунок_.Верх = Рис_.Верх;
		НовыйРисунок_.Линия = Рис_.Линия;
		НовыйРисунок_.РазмерКартинки = Рис_.РазмерКартинки;	
	КонецЕсли;
	
	Возврат ОбластьИзображения;
КонецФункции

// Процедура выводит список в документ согласно заданному оформлению.
//
// Параметры:
//  Документ	 - ТабличныйДокумент - документ, в который осуществляется вывод.
//  ИмяСекции	 - Строка	 - секция, в которую нужно поместить список
//  Список		 - ОбъектXDTO	 - объект, содержащий список
//  Макет		 - ТабличныйДокумент	 - документ, в котором содержится оформление
Процедура ВывестиСписок(Документ, ИмяСекции, Список, Макет)
	ВывестиЗаголовок(Документ, ИмяСекции, Список, Макет);
	Нумерованный_ = ПолучитьЗначениеПоПути(Список, "listType") = "ordered";
	ЭлементыСписка_ = Список.Последовательность();
	ОформлениеСписка_ = Новый Соответствие();
	НастроитьОформлениеЭлемента(Список, ОформлениеСписка_);
	Номер_ = 1;
	Для Счет_ = 0 По ЭлементыСписка_.Количество() - 1 Цикл
		Если ЭлементыСписка_.ПолучитьСвойство(Счет_).Имя = "item" Тогда
			Элемент_ = ЭлементыСписка_.ПолучитьЗначение(Счет_);
			Текст_ = ?(Нумерованный_, "" + Номер_ + ". ", Символ(8226) + " ") + ПолучитьТекст(Элемент_, Ложь) + "<br/>";
			Текст_ = СтрЗаменить(Текст_, "<br>", Символы.ПС);
			Текст_ = СтрЗаменить(Текст_, "<br/>", Символы.ПС);
			Текст_ = СтрЗаменить(Текст_, "<br />", Символы.ПС);
			ОбластьЭлементаСписка_ = ПолучитьОбластьМакета(Макет, "item", ИмяСекции);
			ОбластьЭлементаСписка_.Параметры.Строка = Текст_;
			Если ТипЗнч(Элемент_) = Тип("ОбъектXDTO") Тогда
				ОформлениеЭлемента_ = Новый Соответствие();
				НастроитьОформлениеЭлемента(Элемент_, ОформлениеЭлемента_);
				ОформлениеЭлемента_ = ПолучитьОбъединениеСоответствий(ОформлениеСписка_, ОформлениеЭлемента_);
				Если Элемент_.Свойства().Получить("content") <> Неопределено Тогда
					ПересечениеОформленияПотомков_ = ПолучитьОбщееОформлениеПотомков(Элемент_);
					ОформлениеЭлемента_ = ПолучитьОбъединениеСоответствий(ОформлениеЭлемента_, ПересечениеОформленияПотомков_);
				КонецЕсли;
				
				//
				//Если Элемент_ .Свойства().Получить("content") <> Неопределено Тогда
				//	Если ТипЗнч(Элемент_.content) = Тип("ОбъектXDTO") Тогда
				//		НастроитьОформлениеЭлемента(Элемент_.content, Оформление_);
				//	ИначеЕсли ТипЗнч(Элемент_.content) = Тип("СписокXDTO") Тогда
				//		НастроитьОформлениеЭлемента(Элемент_.content[0], Оформление_);
				//	КонецЕсли;
				//КонецЕсли;
				ОформитьОбласть(ОбластьЭлементаСписка_.Области.Получить(0), ОформлениеЭлемента_);
			КонецЕсли;
			Документ.Вывести(ОбластьЭлементаСписка_);
			Номер_ = Номер_ + 1;
		КонецЕсли;
	КонецЦикла;
	Если СтрНайти(НРег(ПолучитьЗначениеПоПути(Список, "styleCode")), "pagebreakafter") > 0 Тогда
		Документ.ВывестиГоризонтальныйРазделительСтраниц();
	КонецЕсли;

КонецПроцедуры

Функция ПолучитьТекстСписка(Список)
	ЭлементыСписка_ = Список.Последовательность();
	ЗаголовокСписка_ = ПолучитьЗначениеПоПути(Список, "caption");		
	Текст_ = "";
	Нумерованный_ = ПолучитьЗначениеПоПути(Список, "listType") = "ordered";
	Если ЗаголовокСписка_ <> Неопределено Тогда
		Текст_ = Текст_ + ПолучитьТекст(ЗаголовокСписка_) + ":<br/>";
	КонецЕсли;
	Номер_ = 1;
	Для Счет_ = 0 По ЭлементыСписка_.Количество() - 1 Цикл
		Если ЭлементыСписка_.ПолучитьСвойство(Счет_).Имя = "item" Тогда
			Элемент_ = ЭлементыСписка_.ПолучитьЗначение(Счет_);
			Текст_ = Текст_ + ?(Нумерованный_, "" + Номер_ + ". ", Символ(8226) + " ") + ПолучитьТекст(Элемент_) + "<br/>";
			Номер_ = Номер_ + 1;
		КонецЕсли;
	КонецЦикла;
	Возврат Текст_;
КонецФункции

Процедура НастроитьОформлениеЭлемента(Элемент, Оформление, ОформлениеРодителя = Неопределено, НаследоватьГраницы = Ложь)
	Если ОформлениеРодителя <> Неопределено Тогда
		Для Каждого Эл_ Из ОформлениеРодителя Цикл
			Если Не НаследоватьГраницы И (Эл_.Ключ = "lrule" ИЛИ Эл_.Ключ = "rrule"
				ИЛИ Эл_.Ключ = "toprule" ИЛИ Эл_.Ключ = "botrule") Тогда
				Продолжить;
			КонецЕсли;
			Оформление.Вставить(Эл_.Ключ,Эл_.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Рамка_ = ПолучитьЗначениеПоПути(Элемент, "border");
	Если Рамка_ <> Неопределено и Число(Рамка_) <> 0 Тогда
		ШиринаРамки_ = Число(Рамка_);
		Оформление.Вставить("lrule", ШиринаРамки_);
		Оформление.Вставить("rrule", ШиринаРамки_);
		Оформление.Вставить("toprule", ШиринаРамки_);
		Оформление.Вставить("botrule", ШиринаРамки_);
	КонецЕсли;
	
	Стиль_ = ПолучитьЗначениеПоПути(Элемент, "styleCode");
	Если Стиль_ <> Неопределено и Стиль_ <> "" Тогда
		Стиль_ = НРег(Стиль_);
		ЭлементыОформления_ = СтрРазделить(Стиль_, " ");
		Для Каждого Эл_ Из ЭлементыОформления_ Цикл
			Если СтрНайти(Эл_, ":#") > 0 Тогда
				Знач_ = СтрРазделить(Эл_, ":#", Ложь); 
				Оформление.Вставить(Знач_[0],Знач_[1]);
			ИначеЕсли СтрНайти(Эл_, ":") > 0 Тогда
				Знач_ = СтрРазделить(Эл_, ":", Ложь);
				Оформление.Вставить(Знач_[0],Знач_[1]);
			Иначе
				Оформление.Вставить(Эл_, "");
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ГорВыравнивание_ = ПолучитьЗначениеПоПути(Элемент, "align");
	Если ГорВыравнивание_ <> Неопределено Тогда
		Оформление.Вставить("align", НРег(ГорВыравнивание_));
	КонецЕсли;
	
	ВертВыравнивание_ = ПолучитьЗначениеПоПути(Элемент, "valign");
	Если ВертВыравнивание_ <> Неопределено Тогда
		Оформление.Вставить("valign", НРег(ВертВыравнивание_));
	КонецЕсли;
	
	Полужирный_ = ПолучитьЗначениеПоПути(Элемент, "bold");
	Если Полужирный_ <> Неопределено Тогда
		Оформление.Вставить("bold");
	КонецЕсли;
КонецПроцедуры

Функция ПолучитьОбщееОформлениеПотомков(Элемент)
	Возврат ПолучитьОбщееОформлениеПотомковРекурсивно(Элемент, Новый Соответствие(), Ложь);
КонецФункции

Функция ПолучитьОбщееОформлениеПотомковРекурсивно(Элемент, ОформлениеДочернихЭлементов, ПервоначальноеОформлениеЗаполнено = Истина)
	Если Истина 
		И ПервоначальноеОформлениеЗаполнено 
		И ОформлениеДочернихЭлементов.Количество() = 0 
	Тогда
		Возврат ОформлениеДочернихЭлементов;
	КонецЕсли;
	
	Последовательность_ = Элемент.Последовательность();
	Для Счетчик_ = 0 По Последовательность_.Количество() - 1 Цикл
		Если Последовательность_.ПолучитьСвойство(Счетчик_) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ДочернийЭлемент_ = Последовательность_.ПолучитьЗначение(Счетчик_);
		ТекстДочернегоЭлемента_ = ПолучитьТекст(ДочернийЭлемент_);
		Если ПустаяСтрока(ТекстДочернегоЭлемента_) Тогда
			Продолжить;
		КонецЕсли;
		Если ПервоначальноеОформлениеЗаполнено Тогда
			ОформлениеЭлемента_ = Новый Соответствие;
			НастроитьОформлениеЭлемента(ДочернийЭлемент_, ОформлениеЭлемента_);
			Если ОформлениеЭлемента_.Количество() = 0 Тогда
				Возврат ОформлениеЭлемента_;
			КонецЕсли;
			ОформлениеЭлемента_ = ПолучитьОбщееОформлениеПотомковРекурсивно(ДочернийЭлемент_, ОформлениеЭлемента_);
			ОформлениеДочернихЭлементов = ПолучитьПересечениеСоответствий(ОформлениеДочернихЭлементов, ОформлениеЭлемента_);
		Иначе
			НастроитьОформлениеЭлемента(ДочернийЭлемент_, ОформлениеДочернихЭлементов);
			ПервоначальноеОформлениеЗаполнено = Истина;
		КонецЕсли;
		
		Если ОформлениеДочернихЭлементов.Количество() = 0 Тогда
			Возврат ОформлениеДочернихЭлементов;
		КонецЕсли;		
	КонецЦикла;
	Возврат ОформлениеДочернихЭлементов;
КонецФункции

Функция ПолучитьПересечениеСоответствий(Знач Соотвествие1, Знач Соответствие2)
	Результат_ = Соотвествие1;
	Источник_ = Соответствие2;
	Если Результат_.Количество() > Источник_.Количество() Тогда
		Результат_ = Соответствие2;
		Источник_ = Соотвествие1;
	КонецЕсли;
	
	Для Каждого Элемент_ Из Результат_ Цикл
		Если Источник_.Получить(Элемент_.Ключ) = Неопределено Тогда
			Результат_.Удалить(Элемент_.Ключ);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат_;
КонецФункции

Функция ПолучитьОбъединениеСоответствий(Знач Соответствие1, Знач Соответствие2)
	Результат_ = Соответствие1;
	Источник_ = Соответствие2;
	Для Каждого Элемент_ Из Источник_ Цикл
		Если Результат_.Получить(Элемент_.Ключ) = Неопределено Тогда
			Результат_.Вставить(Элемент_.Ключ, Элемент_.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат_;
КонецФункции

// Процедура выводит таблицу согласно заданному оформлению.
//
// Параметры:
//  Документ	- ТабличныйДокумент	 - документ, в который осуществляется вывод.
//  ИмяСекции	- Строка	 - 
//  Элемент	 	- ОбъектXDTO	 - 	объект, содержащий заголовок
//  Макет		- ТабличныйДокумент	 - документ, в котором содержится оформление документа.
Процедура ВывестиЗаголовок(Документ, ИмяСекции, Элемент, Макет, ОформлениеРодителя = Неопределено)
	ЗаголовокЭлемента_ = ПолучитьЗначениеПоПути(Элемент, "caption");		
	Если ЗаголовокЭлемента_ <> Неопределено Тогда
		ОбластьЗаголовка_ = ПолучитьОбластьМакета(Макет, "caption", ИмяСекции);
		Текст_ = ПолучитьТекст(ЗаголовокЭлемента_);
		Если ЗначениеЗаполнено(Текст_) Тогда
			ОбластьЗаголовка_.Параметры.Строка = Текст_;
			ОформлениеЗаголовка_ = Новый Соответствие();
			НастроитьОформлениеЭлемента(ЗаголовокЭлемента_, ОформлениеЗаголовка_, ОформлениеРодителя);
			ОформитьОбласть(ОбластьЗаголовка_.Области.Получить(0), ОформлениеЗаголовка_);
			Документ.Вывести(ОбластьЗаголовка_);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Процедура выводит таблицу согласно заданному оформлению.
//
// Параметры:
//  Документ	- ТабличныйДокумент	 - документ, в который осуществляется вывод.
//  ИмяСекции	- Строка	 - 
//  Таблица	 	- ОбъектXDTO	 - 	объект, содержащий таблицу
//  Макет		- ТабличныйДокумент	 - документ, в котором содержится оформление документа.
Процедура ВывестиТаблицу(Документ, ИмяСекции, Таблица, Макет, КодыИсключаемыхПолей = Неопределено)
	НоваяТаблица_ = Новый ТабличныйДокумент();
	
	СвойстваТаблицы_ = Таблица.Свойства();
	ЭлементыТаблицы_ = Таблица.Последовательность();
	
	
	Оформление_ = Новый Соответствие();
	НастроитьОформлениеЭлемента(Таблица, Оформление_);
	
	ПриоритетЭлементовТела_ = Новый Массив();
	ПриоритетЭлементовТела_.Добавить("td");
	ПриоритетЭлементовТела_.Добавить("tr");
	ПриоритетЭлементовТела_.Добавить("tbody");
	ПриоритетЭлементовТела_.Добавить("table");
	ПриоритетЭлементовТела_.Добавить("default");
	
	
	ВывестиЗаголовок(Документ, ИмяСекции, Таблица, Макет, Оформление_);
	
	ОбластьШапкиТаблицы_ = ПолучитьОбластьМакета(Макет, "thead", ИмяСекции, "R1C1");
	ОбластьТелаТаблицы_ = ПолучитьОбластьМакета(Макет, ПриоритетЭлементовТела_, ИмяСекции, "R1C1");
	ОбластьПодвалаТаблицы_ = ПолучитьОбластьМакета(Макет, "tfoot", ИмяСекции, "R1C1");
	ОбластьТН_ = ПолучитьОбластьМакета(Макет, "th", ИмяСекции, "R1C1");
	
	НачальныеШириныКолонок_ = Новый Массив();
	
	МассивОбъединеняемыхОбластей_ = Новый Массив();
	МассивТекущихКолСпан_ = Новый Массив();
	МассивТекущихРоуСпан_ = Новый Массив();
	
	Если Не СвойстваТаблицы_.Получить("col") = Неопределено Тогда
		КолонкаТаблицы_ = Таблица.col;
		Если ТипЗнч(КолонкаТаблицы_) = Тип("ОбъектXDTO") Тогда
			ШиринаКолонки_ = ПолучитьЗначениеПоПути(КолонкаТаблицы_, "width");
			НачальныеШириныКолонок_.Добавить(ШиринаКолонки_);
		Иначе
			Для каждого ЭлементКолонка_ Из КолонкаТаблицы_ Цикл
				ШиринаКолонки_ = ПолучитьЗначениеПоПути(ЭлементКолонка_, "width");
			НачальныеШириныКолонок_.Добавить(ШиринаКолонки_);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
		
	// В CDA-документе области thead, tfoot и tbody могут идти непоследовательно, но отображать их нужно в порядке 
	// thead, {tbody|tr}, tfoot, поэтому обрабатываем отдельно все варианты.
	Если Не СвойстваТаблицы_.Получить("thead") = Неопределено Тогда
		ШапкаТаблицы_ = Таблица.thead;
		Если ТипЗнч(ШапкаТаблицы_) = Тип("ОбъектXDTO") Тогда
			ВывестиОбластьТаблицы(НоваяТаблица_, ШапкаТаблицы_, ОбластьШапкиТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_);
		Иначе
			Для каждого ЭлементШапка_ Из ШапкаТаблицы_ Цикл
				ВывестиОбластьТаблицы(НоваяТаблица_, ЭлементШапка_, ОбластьШапкиТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Для Счетчик_ = 0 По ЭлементыТаблицы_.Количество() - 1 Цикл
		Элемент_ = ЭлементыТаблицы_.ПолучитьЗначение(Счетчик_);
		ИмяЭлемента_ = ЭлементыТаблицы_.ПолучитьСвойство(Счетчик_).Имя;
		Если ИмяЭлемента_ = "tr" Тогда
			ВывестиСтрокуТаблицы(НоваяТаблица_, ЭлементыТаблицы_.ПолучитьЗначение(Счетчик_), ОбластьТелаТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_, КодыИсключаемыхПолей);
		ИначеЕсли ИмяЭлемента_ = "tbody" Тогда
			ВывестиОбластьТаблицы(НоваяТаблица_, Элемент_, ОбластьТелаТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_, КодыИсключаемыхПолей);
		КонецЕсли;
	КонецЦикла;
	
	
	Если Не СвойстваТаблицы_.Получить("tfoot") = Неопределено Тогда
		ПодвалТаблицы_ = Таблица.tfoot;
		Если ТипЗнч(ПодвалТаблицы_) = Тип("ОбъектXDTO") Тогда
			ВывестиОбластьТаблицы(НоваяТаблица_, ПодвалТаблицы_, ОбластьПодвалаТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_);
		Иначе
			Для каждого ЭлементПодвал_ Из ПодвалТаблицы_ Цикл
				ВывестиОбластьТаблицы(НоваяТаблица_, ЭлементПодвал_, ОбластьПодвалаТаблицы_, ОбластьТН_, Оформление_, МассивОбъединеняемыхОбластей_, МассивТекущихКолСпан_, МассивТекущихРоуСпан_);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	ШиринаТаблицы_ = Неопределено;
	Если НачальныеШириныКолонок_.Количество() = 0 И Оформление_.Получить("width") <> Неопределено Тогда
		ШиринаТаблицы_ = Оформление_.Получить("width");
	КонецЕсли;
	
	ЗаданнаяШиринаТаблицы_ = СвойстваТаблицы_.Получить("width");
	Если ЗаданнаяШиринаТаблицы_ <> Неопределено Тогда
		ЗаданнаяШиринаТаблицыВПроцентах_ = ПолучитьЗначениеПоПути(Таблица, "width");
		Если Прав(ЗаданнаяШиринаТаблицыВПроцентах_, 1) = "%" Тогда
			ЗаданнаяШиринаТаблицыВПроцентах_ = Число(Лев(ЗаданнаяШиринаТаблицыВПроцентах_, СтрДлина(ЗаданнаяШиринаТаблицыВПроцентах_) - 1));
		Иначе
			ЗаданнаяШиринаТаблицыВПроцентах_ = Неопределено;
		КонецЕсли;
	КонецЕсли;
	РасчетШириныКолонок(НоваяТаблица_, Макет, НачальныеШириныКолонок_, ЗаданнаяШиринаТаблицыВПроцентах_);
	Если МассивОбъединеняемыхОбластей_.Количество() > 0 Тогда
		ВыполнитьОбъединениеЯчеек(НоваяТаблица_, МассивОбъединеняемыхОбластей_);
	КонецЕсли;
	Документ.Вывести(НоваяТаблица_);
	Стиль_ = ПолучитьЗначениеПоПути(Таблица, "styleCode");
	Если Стиль_ = Неопределено ИЛИ Не СтрНайти(НРег(Стиль_), "noindent") Тогда
		Документ.Вывести(Макет.ПолучитьОбласть("Разделитель"));
	КонецЕсли;
КонецПроцедуры

// Процедура выводит область таблицы согласно заданному оформлению.
//
// Параметры:
//  Документ		 - ТабличныйДокумент	 - документ, в который осуществляется вывод.
//  ОбластьТаблицы	 - ОбъектXDTO	 - 	объект, содержащий область таблицы (thead, tbody, tfoot)
//  Область			 - ТабличныйДокумент	 - документ, в котором содержится оформление области.
Процедура ВывестиОбластьТаблицы(Документ, ОбластьТаблицы, Область, ОбластьТН, ОформлениеРодителя, МассивОбъединеняемыхОбластей, МассивТекущихКолСпан, МассивТекущихРоуСпан, КодыИсключаемыхПолей = Неопределено)
	Оформление = Новый Соответствие();
	НастроитьОформлениеЭлемента(ОбластьТаблицы, Оформление, ОформлениеРодителя, Истина);
	
	Если ОбластьТаблицы.Свойства().Получить("tr") = Неопределено Тогда
		Возврат;
	КонецЕсли;
	СтрокиОбласти = ОбластьТаблицы.tr;
	Если ТипЗнч(СтрокиОбласти) = Тип("СписокXDTO") Тогда
		Для Каждого Строка_ из СтрокиОбласти Цикл
			ВывестиСтрокуТаблицы(Документ, Строка_, Область, ОбластьТН, Оформление, МассивОбъединеняемыхОбластей, МассивТекущихКолСпан, МассивТекущихРоуСпан, КодыИсключаемыхПолей);
		КонецЦикла;
	ИначеЕсли ТипЗнч(СтрокиОбласти) = Тип("ОбъектXDTO") Тогда
		ВывестиСтрокуТаблицы(Документ, СтрокиОбласти, Область, ОбластьТН, Оформление, МассивОбъединеняемыхОбластей, МассивТекущихКолСпан, МассивТекущихРоуСпан, КодыИсключаемыхПолей);
	КонецЕсли;
КонецПроцедуры

// Процедура выводит строку таблицы согласно заданному оформлению.
//
// Параметры:
//  Документ					 - ТабличныйДокумент - документ, в который осуществляется вывод.
//  Строка						 - ОбъектXDTO		 - объект, содержащий строку таблицы.
//  Область						 - ТабличныйДокумент - документ, в котором содержится оформление ячейки.
//  ОформлениеРодителя			 - Структура		 - структура, содержащая информацию об оформлении родительского объекта.
//  МассивОбъединеняемыхОбластей - Массив			 - массив областей, которые будут объединены после вывода всей таблицы.
//  МассивТекущихКолСпан		 - Массив			 - массив текущих объединений по столбцам.
//  МассивТекущихРоуСпан		 - Массив			 - массив текущих объединений по строкам.
//
Процедура ВывестиСтрокуТаблицы(Документ, Строка, ОбластьТД, ОбластьТН, ОформлениеРодителя, МассивОбъединеняемыхОбластей, МассивТекущихКолСпан, МассивТекущихРоуСпан, КодыИсключаемыхПолей = Неопределено)
	Если ЛОЖЬ = ПроверитьВыводКодируемыхПолейСекции(Строка, КодыИсключаемыхПолей) Тогда
		Возврат;
	КонецЕсли;
	НоваяСтрокаТаблицы_ = Новый ТабличныйДокумент();
	ЯчейкиСтроки_ = Строка.Последовательность();
	
	МассивСледующихРоуСпан = Новый Массив();
	
	ОформлениеСтроки_ = Новый Соответствие();
	НастроитьОформлениеЭлемента(Строка, ОформлениеСтроки_, ОформлениеРодителя, Истина);
	
	Если МассивТекущихКолСпан.Количество() = 0 Тогда
		Для Счетчик_ = 0 По ЯчейкиСтроки_.Количество() - 1 Цикл
			Если ЯчейкиСтроки_.ПолучитьСвойство(Счетчик_).Имя = "td" ИЛИ ЯчейкиСтроки_.ПолучитьСвойство(Счетчик_).Имя = "th" Тогда	
				КолСпан_ = ПолучитьЗначениеПоПути(ЯчейкиСтроки_.ПолучитьЗначение(Счетчик_), "colspan");
				РоуСпан_ = ПолучитьЗначениеПоПути(ЯчейкиСтроки_.ПолучитьЗначение(Счетчик_), "rowspan");
				
				КолСпан_ = ?(КолСпан_ = Неопределено, 1, Число(КолСпан_));
				РоуСпан_ = ?(РоуСпан_ = Неопределено ИЛИ РоуСпан_ = 1, 1, Число(РоуСпан_) + 1);
				
				Если КолСпан_ > 1 ИЛИ РоуСпан_ > 1 Тогда
					МассивОбъединеняемыхОбластей.Добавить(
					Новый Структура("Верх,Лево,Высота,Ширина",Документ.ВысотаТаблицы, МассивТекущихКолСпан.Количество()+1, ?(РоуСпан_ = 1, 1, РоуСпан_ - 1), КолСпан_));
				КонецЕсли;
				
				МассивТекущихКолСпан.Добавить(КолСпан_);
				МассивТекущихРоуСпан.Добавить(1);
				МассивСледующихРоуСпан.Добавить(РоуСпан_);
				
				Если КолСпан_ > 1 Тогда		
					Для Счет_ = 2 По КолСпан_ Цикл
						МассивТекущихКолСпан.Добавить(0);
						МассивТекущихРоуСпан.Добавить(1);
						МассивСледующихРоуСпан.Добавить(РоуСпан_);
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Иначе
		СчетчикЯчеек_ = 0;
		Для Счетчик_ = 0 По МассивТекущихКолСпан.ВГраница() Цикл
			Если МассивТекущихРоуСпан[Счетчик_] = 1 Тогда
				Если СчетчикЯчеек_ < ЯчейкиСтроки_.Количество() Тогда
					Если ЯчейкиСтроки_.ПолучитьСвойство(СчетчикЯчеек_).Имя = "td" ИЛИ ЯчейкиСтроки_.ПолучитьСвойство(СчетчикЯчеек_).Имя = "th" Тогда	
						КолСпан_ = ПолучитьЗначениеПоПути(ЯчейкиСтроки_.ПолучитьЗначение(СчетчикЯчеек_), "colspan");
						РоуСпан_ = ПолучитьЗначениеПоПути(ЯчейкиСтроки_.ПолучитьЗначение(СчетчикЯчеек_), "rowspan");
						
						КолСпан_ = ?(КолСпан_ = Неопределено, 1, Число(КолСпан_));
						РоуСпан_ = ?(РоуСпан_ = Неопределено ИЛИ РоуСпан_ = 1, 1, Число(РоуСпан_) + 1);
						
						Если КолСпан_ > 1 ИЛИ РоуСпан_ > 1 Тогда
							МассивОбъединеняемыхОбластей.Добавить(
							Новый Структура("Верх,Лево,Высота,Ширина",Документ.ВысотаТаблицы, Счетчик_ + 1, ?(РоуСпан_ = 1, 1, РоуСпан_ - 1), КолСпан_));
						КонецЕсли;
						
						МассивТекущихКолСпан[Счетчик_] = КолСпан_;
						МассивСледующихРоуСпан.Вставить(Счетчик_, РоуСпан_);
						
						Если КолСпан_ > 1 Тогда		
							Для ДопСчетчик_ = 1 По КолСпан_ - 1 Цикл
								Счетчик_ = Счетчик_ + 1;
								Если Счетчик_ < МассивТекущихКолСпан.Количество() Тогда
									МассивТекущихКолСпан[Счетчик_] = 0;
									МассивСледующихРоуСпан.Вставить(Счетчик_ , РоуСпан_);						
								КонецЕсли;
							КонецЦикла;
						КонецЕсли;
						
						СчетчикЯчеек_ = СчетчикЯчеек_ + 1;
					КонецЕсли;
				КонецЕсли;
			Иначе
				МассивСледующихРоуСпан.Вставить(Счетчик_, МассивТекущихРоуСпан[Счетчик_]);
			КонецЕсли;			
		КонецЦикла;
	КонецЕсли;
	
	Счетчик_ = 0;
	Для Счет_ = 0 По МассивТекущихКолСпан.Количество() - 1 Цикл
		Если МассивТекущихКолСпан[Счет_] = 0 Тогда
			НоваяСтрокаТаблицы_.Присоединить(ОбластьТД);
		Иначе 
			Если Счетчик_ < ЯчейкиСтроки_.Количество() Тогда
				ИмяЭлемента_ = ЯчейкиСтроки_.ПолучитьСвойство(Счетчик_).Имя;
				Если ЯчейкиСтроки_.ПолучитьСвойство(Счетчик_).Имя = "td" ИЛИ ЯчейкиСтроки_.ПолучитьСвойство(Счетчик_).Имя = "th" Тогда	
					Ячейка_ = ЯчейкиСтроки_.ПолучитьЗначение(Счетчик_);
					Если ИмяЭлемента_ = "td" Тогда
						ШаблонЯчейки_ = ЗначениеИзСтрокиВнутр(ЗначениеВСтрокуВнутр(ОбластьТД)); 
					Иначе
						ШаблонЯчейки_ = ЗначениеИзСтрокиВнутр(ЗначениеВСтрокуВнутр(ОбластьТН)); 
					КонецЕсли;
					ОбластьШаблона_ = ШаблонЯчейки_.Область("R1C1");
					
					
					Оформление = Новый Соответствие();
					НастроитьОформлениеЭлемента(Ячейка_, Оформление, ОформлениеСтроки_, Истина);
					
					ЗначениеЯчейки_ = СокрЛП(ПолучитьТекст(Ячейка_));
					Если ТипЗнч(Ячейка_) <> Тип("Строка") И Ячейка_.Последовательность().Количество() = 1 И Ячейка_.Свойства().Получить("content") <> Неопределено И ТипЗнч(Ячейка_.content) = Тип("ОбъектXDTO") Тогда
						НастроитьОформлениеЭлемента(Ячейка_.content, Оформление, Оформление, Истина);	
					КонецЕсли;
					ОформитьОбласть(ОбластьШаблона_, Оформление);
					
					ШаблонЯчейки_.Параметры.Строка = ЗначениеЯчейки_;
					НоваяСтрокаТаблицы_.Присоединить(ШаблонЯчейки_);
					
				КонецЕсли;
			КонецЕсли;
			Счетчик_ = Счетчик_ + 1;	
		КонецЕсли;
	КонецЦикла;
	
	Для Счет_ = 0 По МассивТекущихКолСпан.Количество() - 1 Цикл
		Если Счет_ < МассивСледующихРоуСпан.Количество() Тогда 
			Если МассивСледующихРоуСпан[Счет_] = 1 Тогда 
				МассивТекущихКолСпан[Счет_]  = 1;
				МассивТекущихРоуСпан[Счет_] = 1;
			Иначе
				МассивТекущихКолСпан[Счет_]  = 0;
				МассивТекущихРоуСпан[Счет_] = МассивСледующихРоуСпан[Счет_] - 1;
			КонецЕсли;
		Иначе
			МассивТекущихКолСпан[Счет_]  = 1;
			МассивТекущихРоуСпан[Счет_] = 1;
		КонецЕсли;
	КонецЦикла;
	
	Документ.Вывести(НоваяСтрокаТаблицы_);
	Если СтрНайти(НРег(ПолучитьЗначениеПоПути(Строка, "styleCode")), "pagebreakafter") > 0 Тогда
		Документ.ВывестиГоризонтальныйРазделительСтраниц();
	КонецЕсли;

КонецПроцедуры

// Процедура - Оформить область.
//
// Параметры:
//  Область		 - ОбластьЯчеекТабличногоДокумента	 - оформляемая область.
//  Оформление	 - Структура	 - структура, содержащая информацию об оформлении области.
//
Процедура ОформитьОбласть(Область, Оформление)
	Если Оформление.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если Область.Шрифт = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЛинияГраницы_ = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
	
	ШрифтЖирный_ = Область.Шрифт.Жирный;
	ШрифтНаклонный_ = Область.Шрифт.Наклонный;
	ШрифтПодчеркивание_ = Область.Шрифт.Подчеркивание;
	КоэффициентРазмерШрифта_ = 1;
	
	
	Для каждого Элемент_ Из Оформление Цикл
		Если Элемент_.Ключ = "lrule" Тогда
			Область.ГраницаСлева = ЛинияГраницы_;
		КонецЕсли;
		Если Элемент_.Ключ = "rrule" Тогда
			Область.ГраницаСправа = ЛинияГраницы_;
		КонецЕсли;
		Если Элемент_.Ключ = "toprule" Тогда
			Область.ГраницаСверху = ЛинияГраницы_;
		КонецЕсли;
		Если Элемент_.Ключ = "botrule" Тогда
			Область.ГраницаСнизу = ЛинияГраницы_;
		КонецЕсли;
		
		Если Элемент_.Ключ = "align" Тогда
			УстановитьГоризонтальноеВыравнивание(Область, Элемент_.Значение);
		КонецЕсли;
		
		Если Элемент_.Ключ = "valign" Тогда
			УстановитьВертикальноеВыравнивание(Область, Элемент_.Значение);
		КонецЕсли;
		
		Если Элемент_.Ключ = "bold" Тогда
			ШрифтЖирный_ = Истина;
		КонецЕсли;
		
		Если Элемент_.Ключ = "italics" Тогда
			ШрифтНаклонный_ = Истина;
		КонецЕсли;
		
		Если Элемент_.Ключ = "underline" Тогда
			ШрифтПодчеркивание_ = Истина;
		КонецЕсли;
		
		Если Элемент_.Ключ = "fontsize" Тогда
			РазмерШрифта_ = СтрЗаменить(Элемент_.Значение, "%", "");
			Попытка
				КоэффициентРазмерШрифта_ = Число(РазмерШрифта_) / 100;
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		
		
	КонецЦикла;
	Шрифт_ = Новый Шрифт(Область.Шрифт.Имя, Область.Шрифт.Размер * КоэффициентРазмерШрифта_, ШрифтЖирный_, ШрифтНаклонный_, 
	ШрифтПодчеркивание_, Область.Шрифт.Зачеркивание, Область.Шрифт.Масштаб);
	Область.Шрифт = Шрифт_;
КонецПроцедуры

// Процедура - Выполняет объединение ячеек табличного документа с сохранением оформления исходных областей.
//
// Параметры:
//  Таблица						 - 	ТабличныйДокумент - документ, в котором выполняются объединения.
//  МассивОбъединеняемыхОбластей - 	Массив - массив структур, содержащий информацию об объединяемых областях.
//
Процедура ВыполнитьОбъединениеЯчеек(Таблица, МассивОбъединеняемыхОбластей)
	
	// сохранить оформление из Таблица.Область(Область_.Верх + 1, Область_.Лево, Область_.Верх +1, Область_.Лево)
	
	Для Каждого Область_ Из МассивОбъединеняемыхОбластей Цикл
		
		// Считываем оформление. 
		ПерваяЯчейка_ = Таблица.Область(Область_.Верх + 1, Область_.Лево, Область_.Верх +1, Область_.Лево);
		Оформление_ = Новый Структура("ВертикальноеПоложение,ГраницаСверху,ГраницаСлева,ГраницаСнизу,ГраницаСправа,ГоризонтальноеПоложение,Шрифт");
		Для Каждого ЭлементОформления_ Из Оформление_ Цикл
			Оформление_[ЭлементОформления_.Ключ] = ПерваяЯчейка_[ЭлементОформления_.Ключ];	
		КонецЦикла;
		
		// Объединяем ячейки и устанавливаем оформление полученной области.
		ОбъединяемаяОбласть_ = Таблица.Область(Область_.Верх + 1, Область_.Лево, Область_.Верх + Область_.Высота, Область_.Лево + Область_.Ширина - 1);
		ОбъединяемаяОбласть_.Объединить();
		Для Каждого ЭлементОформления_ Из Оформление_ Цикл
			ОбъединяемаяОбласть_[ЭлементОформления_.Ключ] = Оформление_[ЭлементОформления_.Ключ];	
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Функция УстановитьГоризонтальноеВыравнивание(Область, Выравнивание)
	Если Выравнивание = "left" Тогда
		Область.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево;
	ИначеЕсли Выравнивание = "right" Тогда
		Область.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
	ИначеЕсли Выравнивание = "center" Тогда
		Область.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
	ИначеЕсли Выравнивание = "justify" Тогда
		Область.ГоризонтальноеПоложение = ГоризонтальноеПоложение.ПоШирине;
	КонецЕсли;
КонецФункции

Функция УстановитьВертикальноеВыравнивание(Область, Выравнивание)
	Если Выравнивание = "top" Тогда
		Область.ВертикальноеПоложение  = ВертикальноеПоложение.Верх;
	ИначеЕсли Выравнивание = "middle" Тогда
		Область.ВертикальноеПоложение  = ВертикальноеПоложение.Центр;
	ИначеЕсли Выравнивание = "bottom" Тогда
		Область.ВертикальноеПоложение  = ВертикальноеПоложение.Низ;
	КонецЕсли;
КонецФункции

// Процедура выводит абзац в документ согласно заданному оформлению.
//
// Параметры:
//  Документ	 - ТабличныйДокумент - документ, в который осуществляется вывод.
//  ИмяСекции	 - Строка	 - секция, в которую нужно поместить текст
//  Текст		 - Строка	 -  выводимая строка
//  Макет		 - ТабличныйДокумент	 - документ, в котором содержится оформление абзаца
Процедура ВывестиАбзац(Документ, ИмяСекции, Текст, Макет, ЭлементПараграф = Неопределено, ДокументDOM)
	Оформление_ = Новый Соответствие();
	Если ЭлементПараграф <> Неопределено И ТипЗнч(ЭлементПараграф) = Тип("ОбъектXDTO") Тогда
		НастроитьОформлениеЭлемента(ЭлементПараграф, Оформление_);
		Если ЭлементПараграф.Свойства().Получить("content") <> Неопределено Тогда
			ПересечениеОформленияПотомков_ = ПолучитьОбщееОформлениеПотомков(ЭлементПараграф);
			Оформление_ = ПолучитьОбъединениеСоответствий(Оформление_, ПересечениеОформленияПотомков_);
		КонецЕсли;
	КонецЕсли;
	
	ВывестиЗаголовок(Документ, ИмяСекции, Текст, Макет, Оформление_);
	Текст_ = ПолучитьТекст(Текст, , АлгоритмыДляКоллекций.СоздатьМассив("caption"));
	
	ОбластьАбзаца_ = ПолучитьОбластьМакета(Макет, "paragraph", ИмяСекции);
	Если ОбластьАбзаца_ <> Неопределено И СокрЛП(Текст_) <> "" Тогда 
		ОбластьАбзаца_.Параметры.Строка = Текст_;
		ОформитьОбласть(ОбластьАбзаца_.Области.Получить(0), Оформление_);
		Документ.Вывести(ОбластьАбзаца_);
	КонецЕсли;	
	ВывестиИзображенияВЭлемент(Документ, ИмяСекции, Макет, Текст, ДокументDOM);
	Если СтрНайти(НРег(ПолучитьЗначениеПоПути(ЭлементПараграф, "styleCode")), "pagebreakafter") > 0 Тогда
		Документ.ВывестиГоризонтальныйРазделительСтраниц();
	КонецЕсли;
КонецПроцедуры

Процедура ВывестиИзображенияВЭлемент(Документ, ИмяСекции, Макет, Элемент, ДокументDOM)
	Если Не ТипЗнч(Элемент) = Тип("ОбъектXDTO") Тогда
		Возврат;
	КонецЕсли;
	
	Потомки_ = Элемент.Последовательность();
	ПервоеИзображениеВАбзаце_ = Истина;
	ОбластьИзображения_ = ПолучитьОбластьМакета(Макет, "img", ИмяСекции);
	Если ОбластьИзображения_.Рисунки.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	ВыводитьИзображения_ = Ложь;
	Рис_ = ОбластьИзображения_.Рисунки.Получить(0);
	ШиринаИзображенияВСекции_ = Рис_.Ширина;
	МаксимальнаяШиринаСтраницыВМм_ = Макет.ШиринаСтраницы - Макет.ПолеСлева - Макет.ПолеСправа - 13;
	ШиринаИзображенийВСтроке_ = 0;
	Для Счетчик_ = 0 По Потомки_.Количество() - 1 Цикл
		Свойство_ = Потомки_.ПолучитьСвойство(Счетчик_);
		Если Свойство_ = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если Свойство_.Имя = "renderMultiMedia" Тогда
			ВыводитьИзображения_ = Истина;
			Изображение_ = Потомки_.ПолучитьЗначение(Счетчик_);
			ШиринаИзображенийВСтроке_ = ШиринаИзображенийВСтроке_ + ШиринаИзображенияВСекции_;
			Если ШиринаИзображенийВСтроке_ > МаксимальнаяШиринаСтраницыВМм_ Тогда
				Документ.Вывести(ОбластьИзображения_);
				ПервоеИзображениеВАбзаце_ = Истина;
				ШиринаИзображенийВСтроке_ = ШиринаИзображенияВСекции_;
				ОбластьИзображения_ = ПолучитьОбластьМакета(Макет, "img", ИмяСекции);;
				ОбластьИзображения_ = ВывестиИзображениеВОбласть(ОбластьИзображения_, Изображение_, Макет, ДокументDOM, ПервоеИзображениеВАбзаце_);
				ПервоеИзображениеВАбзаце_ = Ложь;
			Иначе
				ОбластьИзображения_ = ВывестиИзображениеВОбласть(ОбластьИзображения_, Изображение_, Макет, ДокументDOM, ПервоеИзображениеВАбзаце_);
				ПервоеИзображениеВАбзаце_ = ПервоеИзображениеВАбзаце_ И Ложь;
			КонецЕсли;
		КонецЕсли;	
	КонецЦикла;
	Если ВыводитьИзображения_ И Не ОбластьИзображения_ = Неопределено Тогда
		Документ.Вывести(ОбластьИзображения_);
	КонецЕсли;
КонецПроцедуры

// Процедура выводит абзац в документ согласно заданному оформлению.
//
// Параметры:
//  Документ	 - ТабличныйДокумент - документ, в который осуществляется вывод.
//  ИмяСекции	 - Строка	 - секция, в которую нужно поместить текст
//  Текст		 - Строка	 -  выводимая строка
//  Макет		 - ТабличныйДокумент	 - документ, в котором содержится оформление абзаца
Процедура ВывестиСсылку(Документ, ИмяСекции, Элемент, Макет)
	Текст_ = ПолучитьТекст(Элемент);
	ОбластьСсылки_ = ПолучитьОбластьМакета(Макет, "linkHtml", ИмяСекции);
	Если ОбластьСсылки_ <> Неопределено И СокрЛП(Текст_) <> "" Тогда
		Расширение_ = "";
		
		Хреф_ = ПолучитьЗначениеПоПути(Элемент, "href");
		Если ЗначениеЗаполнено(Хреф_) Тогда
			МассивДляОпределенияРасширения_ = СтрРазделить(Хреф_, ".");
			Если МассивДляОпределенияРасширения_.Количество() > 0 Тогда
				Расширение_ = МассивДляОпределенияРасширения_[МассивДляОпределенияРасширения_.ВГраница()];
			КонецЕсли;
		КонецЕсли;
		Ид_ = ПолучитьЗначениеПоПути(Элемент, "id");
		
		ОбластьСсылки_.Параметры.Строка = Текст_;
		ПараметрыРасшифровки_ = Новый Структура;
		ПараметрыРасшифровки_.Вставить("НавСсылка", Хреф_);
		СвойстваФайла = Новый Структура;
		СвойстваФайла.Вставить("ИмяФайла",Текст_);
		СвойстваФайла.Вставить("Расширение",Расширение_);
		ПараметрыРасшифровки_.Вставить("СвойстваФайла",СвойстваФайла);

		Попытка
			ОбластьСсылки_.Параметры.Расшифровка = ПараметрыРасшифровки_;
		Исключение
		КонецПопытки;
		Документ.Вывести(ОбластьСсылки_);
	КонецЕсли;
КонецПроцедуры

// Функция возвращает массив структур с данными из CDA-документа
//
// Параметры:
//  ТелоДокумента	 - Строка - CDA-документ.
// Возвращаемое значение:
//  Массив XDTO-объектов - каждый элемент содержит данные об отдельном документе.
Функция ПолучитьДанныеИзCDA(ТелоДокумента) Экспорт 
	МассивСекций_ = Новый Массив;
	МассивДокументов_ = Новый Массив;
	
	Попытка 
		Чтение_ = Новый ЧтениеXML;
		Чтение_.УстановитьСтроку(ТелоДокумента);
		Объект_ = ФабрикаXDTO.ПрочитатьXML(Чтение_);
	Исключение
		Текст_ = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Сообщить(Текст_);

		Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
			МодульСообщенияПользователю_ = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
			МодульСообщенияПользователю_.Показать("Общие_НеУдалосьПрочитатьТелоДокумента");
		Иначе
			Сообщить("Не удалось прочитать тело документа.");
		КонецЕсли;

		Возврат МассивДокументов_;
	КонецПопытки;
	
	СвойстваОбъекта_ = Объект_.Свойства();
	Если СвойстваОбъекта_.Получить("document") <> Неопределено ИЛИ  СвойстваОбъекта_.Получить("group") <> Неопределено Тогда
		Документы_ = Объект_.Последовательность();
		Для Счетчик = 0 По Документы_.Количество() - 1 Цикл
			Если Документы_.ПолучитьСвойство(Счетчик).Имя = "document" Тогда 
				Документ_ = Документы_.ПолучитьЗначение(Счетчик);
				МассивДокументов_.Добавить(Документ_);
			ИначеЕсли Документы_.ПолучитьСвойство(Счетчик).Имя = "group" Тогда
				Группа_ = Документы_.ПолучитьЗначение(Счетчик).Последовательность();
				Для ВлСчетчик_ = 0 По Группа_.Количество() - 1 Цикл
					Если Группа_.ПолучитьСвойство(ВлСчетчик_).Имя = "document" Тогда
						Документ_ = Группа_.ПолучитьЗначение(ВлСчетчик_);
						МассивДокументов_.Добавить(Документ_);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	Иначе
		МассивДокументов_.Добавить(Объект_);
	КонецЕсли;
	
	
	Возврат МассивДокументов_;
КонецФункции

Функция ПолучитьКодСекции(Секция) Экспорт
	Если Секция = Неопределено ИЛИ ТипЗнч(Секция) <> Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	code = ПолучитьЗначениеПоПути(Секция, "code/code");
	
	Возврат code;
КонецФункции

Функция ПолучитьКодСистем(Секция)
	Если Секция = Неопределено ИЛИ ТипЗнч(Секция) <> Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	codeSystem = ПолучитьЗначениеПоПути(Секция, "code/codeSystem");
	
	Возврат codeSystem;
КонецФункции

Функция КодОбластиПоКодуСекции(КодСекции)
	Результат_ = КодСекции;
	КодПервогоСимвола_ = КодСимвола(Результат_, 1);
	Если КодПервогоСимвола_ >= КодСимвола("0") И КодПервогоСимвола_ <= КодСимвола("9")  Тогда
		Результат_ = "p_" + Результат_;
	КонецЕсли;
	Результат_ = СтрЗаменить(Результат_, " ", "");
	Результат_ = СтрЗаменить(Результат_, "-", "");
	Возврат НРег(Результат_);
КонецФункции

// Функция: СортироватьОбластиМакета
//    Сортирует коллекцию областей макета по реквизиту Верх.
//
// Параметры:
//  Области	 - КоллекцияОбластейТабличногоДокумента - Коллекция областей макета.
// Возвращаемое значение:
// Массив областей ячеек табличного документа  - Отсортированный  массив областей.
//    
Функция СортироватьОбластиМакета(Области)
	Результат = Новый Массив;
	
	Данные = Новый Соответствие;
	Ключи = Новый СписокЗначений;
	
	Для Каждого Область Из Области Цикл
		МассивОбластей = Данные.Получить(Область.Верх);
		Если МассивОбластей = Неопределено Тогда
			МассивОбластей = Новый Массив;
			Данные.Вставить(Область.Верх,МассивОбластей);
			Ключи.Добавить(Область.Верх);
		КонецЕсли;
		МассивОбластей.Добавить(Область);
	КонецЦикла;
	
	Ключи.СортироватьПоЗначению();
	
	Для Каждого Ключ Из Ключи Цикл
		Элемент = Данные.Получить(Ключ.Значение);
		Для Каждого Область Из Элемент Цикл
			Результат.Добавить(Область);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Процедура расчета ширин колонок табличного документа, в который был выведен результат построителем отчета.
//
// Параметры:
//  ТабличныйДокумент	 - 	ТабличныйДокумент -  исходный документ.
Процедура РасчетШириныКолонок(ТабличныйДокумент, Макет, НачальныеШириныКолонок, ЗаданнаяШиринаТаблицыВПроцентах)
	
	Перем МаксимальноеКоличествоСтрок;
	Перем КонечнаяСтрока, НачальнаяСтрока, ТекущаяКолонка, ТекущаяСтрока, НачалоДанных;
	Перем ОбластьШапки, ОбластьПодвала;
	Перем ШиринаКолонки, ТекстЯчейки, НомерСтрокиТекста;
	Перем КоличествоУровнейГруппировокСтрок, Отступ;
	Перем ШириныКолонок;
	Перем МаксимальнаяШиринаТаблицы;
	
	МаксимальноеКоличествоСтрок = 50;
	ШириныКолонок = Новый Массив;
	МинимальныеШириныКолонок = Новый Массив;
	
	КоличествоУровнейГруппировокСтрок = ТабличныйДокумент.КоличествоУровнейГруппировокСтрок();
	
	НачальнаяСтрока = 0;
	НачалоДанных = 0;
	
	ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаТаблицы");
	Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		НачальнаяСтрока = ОбластьШапки.Верх;
		НачалоДанных = ОбластьШапки.Низ + 1;
	Иначе
		ОбластьШапки = ТабличныйДокумент.Области.Найти("ШапкаСтрок");
		Если ТипЗнч(ОбластьШапки) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			НачальнаяСтрока = ОбластьШапки.Верх;
			НачалоДанных = ОбластьШапки.Низ + 1;
		КонецЕсли;
	КонецЕсли;
	
	ОбластьПодвала = ТабличныйДокумент.Области.Найти("Подвал");
	Если ТипЗнч(ОбластьПодвала) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
		КонечнаяСтрока = ОбластьПодвала.Верх - 1;
		Если КонечнаяСтрока - НачальнаяСтрока > МаксимальноеКоличествоСтрок Тогда
			КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
		КонецЕсли;
	Иначе 
		КонечнаяСтрока = НачальнаяСтрока + МаксимальноеКоличествоСтрок;
	КонецЕсли;
	
	КонечнаяСтрока = Мин(КонечнаяСтрока, ТабличныйДокумент.ВысотаТаблицы);
	
	Если Макет.ОриентацияСтраницы = ОриентацияСтраницы.Портрет Тогда
		МаксимальнаяШиринаТаблицыВМм = Макет.ШиринаСтраницы - Макет.ПолеСлева - Макет.ПолеСправа;
	Иначе
		МаксимальнаяШиринаТаблицыВМм = Макет.ВысотаСтраницы - Макет.ПолеСверху - Макет.ПолеСнизу - 13;
	КонецЕсли;
	// Приводим ширину из мм к "так называемым средним символам шрифта".
	// магическая константа 0.54 -- соответствие в 1 мм содержится 0.54 "так называемых средних символов шрифта".
	// 1 символ шрифта = 105 твипов, 1 твип = 1/1440 дюйма = 1/567 см.
	// см. http://yoksel.net.ru/%D0%91%D0%BB%D0%BE%D0%B3/2009/04/06/%D0%9D%D0%BE%D0%B2%D0%BE%D0%B5%D0%9F%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%BD%D0%B8%D0%B5%D0%A8%D0%B8%D1%80%D0%B8%D0%BD%D1%8B
	
	МаксимальнаяШиринаТаблицы = 0.54 * МаксимальнаяШиринаТаблицыВМм;
	
	ПараметрыРасчета = Новый Структура("НачальнаяСтрока,КонечнаяСтрока,КоличествоУровнейГруппировокСтрок,НачалоДанных",
	НачальнаяСтрока, КонечнаяСтрока, КоличествоУровнейГруппировокСтрок, НачалоДанных);
	
	ПересчитатьШирины = ТабличныйДокумент.ШиринаТаблицы <> НачальныеШириныКолонок.Количество();
	ШиринаТаблицы = 0;
	
	Если Не ПересчитатьШирины Тогда
		Для Каждого НачальноеЗначение Из НачальныеШириныКолонок Цикл
			Если Прав(НачальноеЗначение, 1) = "%" Тогда
				ШиринаКолонки = Лев(НачальноеЗначение, СтрДлина(НачальноеЗначение) - 1) / 100 * МаксимальнаяШиринаТаблицы;
			Иначе 
				ШиринаКолонки = НачальноеЗначение;
			КонецЕсли;
			ШириныКолонок.Добавить(ШиринаКолонки);
			ШиринаТаблицы = ШиринаТаблицы + ШиринаКолонки;
		КонецЦикла;
		
		// Установливаем отдельный формат для текущей таблицы.
		ТабличныйДокумент.Область(1, , ТабличныйДокумент.ВысотаТаблицы, ).СоздатьФорматСтрок();
		
		ПоправкаНаШиринуСтраницы = 1;
		Если ШиринаТаблицы > МаксимальнаяШиринаТаблицы Тогда
			ПоправкаНаШиринуСтраницы = МаксимальнаяШиринаТаблицы / ШиринаТаблицы;
		КонецЕсли;
		
		Если ПоправкаНаШиринуСтраницы <> 1 Тогда
			Для ТекущаяКолонка = 0 По ШириныКолонок.ВГраница() Цикл
				ШириныКолонок[ТекущаяКолонка] = ШириныКолонок[ТекущаяКолонка] * ПоправкаНаШиринуСтраницы;
			КонецЦикла;
		КонецЕсли;
		
		
	Иначе
		Для ТекущаяКолонка = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
			АвтоОтступ = 0;
			МинимальнаяШирина = 0;
			ВычислитьШиринуКолонки(ТабличныйДокумент, ТекущаяКолонка, ШириныКолонок, МинимальныеШириныКолонок, ПараметрыРасчета, ПересчитатьШирины);
		КонецЦикла;	
		
		Если ШириныКолонок.Количество() < ТабличныйДокумент.ШиринаТаблицы Тогда
			Для Счет = ШириныКолонок.Количество() По ТабличныйДокумент.ШиринаТаблицы - 1 Цикл
				ШириныКолонок.Добавить(0);
			КонецЦикла;
		КонецЕсли;

		
		Для Счетчик = МинимальныеШириныКолонок.Количество() По ШириныКолонок.ВГраница() Цикл
			МинимальныеШириныКолонок.Добавить(ШириныКолонок[Счетчик]);
		КонецЦикла;
		
		
		
		Для ТекущаяКолонка = 0 По Мин(ШириныКолонок.ВГраница(), ТабличныйДокумент.ШиринаТаблицы - 1) Цикл
			Если ШириныКолонок[ТекущаяКолонка] = Неопределено Тогда
				ШириныКолонок[ТекущаяКолонка] = 0;
			КонецЕсли;
			ШиринаТаблицы = ШиринаТаблицы + ШириныКолонок[ТекущаяКолонка] + 1;
		КонецЦикла;
		
		// Установливаем отдельный формат для текущей таблицы.
		ТабличныйДокумент.Область(1, , ТабличныйДокумент.ВысотаТаблицы, ).СоздатьФорматСтрок();
		
		ПоправкаНаШиринуСтраницы = 1;
		Если ШиринаТаблицы > МаксимальнаяШиринаТаблицы Тогда
			ПоправкаНаШиринуСтраницы = МаксимальнаяШиринаТаблицы / ШиринаТаблицы;
		ИначеЕсли ШиринаТаблицы < МаксимальнаяШиринаТаблицы И ЗаданнаяШиринаТаблицыВПроцентах <> Неопределено Тогда
			ПоправкаНаШиринуСтраницы = МаксимальнаяШиринаТаблицы / (ШиринаТаблицы - Мин(ШириныКолонок.ВГраница(), ТабличныйДокумент.ШиринаТаблицы - 1))  * ЗаданнаяШиринаТаблицыВПроцентах / 100;
		КонецЕсли;
		
		
		// Вычисление ширины колонок через вектор невязок
		ВекторНевязок = Новый Массив();
		СуммаПоложительныхНевязок = 0;
		СуммаОтрицательныхНевязок = 0;
		ПодгонятьШирину = Ложь;
		ЕстьРезерв = Ложь;
		ШиринаТаблицы = 0;
		
		Для ТекущаяКолонка = 0 По Мин(ШириныКолонок.ВГраница(), ТабличныйДокумент.ШиринаТаблицы - 1) Цикл
			Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
				ШириныКолонок[ТекущаяКолонка] = (ШириныКолонок[ТекущаяКолонка]) * ПоправкаНаШиринуСтраницы;
				ВекторНевязок.Вставить(ТекущаяКолонка, ШириныКолонок[ТекущаяКолонка] - МинимальныеШириныКолонок[ТекущаяКолонка]);
				Если ВекторНевязок[ТекущаяКолонка] < 0 Тогда
					СуммаОтрицательныхНевязок = СуммаОтрицательныхНевязок - ВекторНевязок[ТекущаяКолонка];
					ПодгонятьШирину = Истина;
				КонецЕсли;
				Если ВекторНевязок[ТекущаяКолонка] > 0 Тогда
					СуммаПоложительныхНевязок = СуммаПоложительныхНевязок + ВекторНевязок[ТекущаяКолонка];
					ЕстьРезерв = Истина;
				КонецЕсли;
				ШиринаТаблицы = ШиринаТаблицы + ШириныКолонок[ТекущаяКолонка]; 
			КонецЕсли;
		КонецЦикла;
		
		Резерв = МаксимальнаяШиринаТаблицы - ШиринаТаблицы;
		
		Если ПодгонятьШирину Тогда
			// Если ширина таблица меньше ширины макета, увеличиваем ширины колонок с отицательными невязками.
			Если Резерв > 0 Тогда
				НоваяСуммаОтрицательныхНевязок = 0;
				ПодгонятьШирину = Ложь;
				Для ТекущаяКолонка = 0 По ВекторНевязок.ВГраница() Цикл
					Если ВекторНевязок[ТекущаяКолонка] < 0 Тогда
						ШириныКолонок[ТекущаяКолонка] = ШириныКолонок[ТекущаяКолонка] - Мин(СуммаОтрицательныхНевязок, Резерв) * ВекторНевязок[ТекущаяКолонка] / СуммаОтрицательныхНевязок; 
						ВекторНевязок[ТекущаяКолонка] = ШириныКолонок[ТекущаяКолонка] - МинимальныеШириныКолонок[ТекущаяКолонка];
						Если ВекторНевязок[ТекущаяКолонка] < 0 Тогда
							НоваяСуммаОтрицательныхНевязок = НоваяСуммаОтрицательныхНевязок - ВекторНевязок[ТекущаяКолонка];
							ПодгонятьШирину = Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				СуммаОтрицательныхНевязок = НоваяСуммаОтрицательныхНевязок;
			КонецЕсли;
			
			
			// Если и после увеличения общей ширины остались "узкие" колонки, то пытаемся их увеличить за счет "широких".
			Если ПодгонятьШирину И ЕстьРезерв Тогда
				Для ТекущаяКолонка = 0 По ВекторНевязок.ВГраница() Цикл
					Если ВекторНевязок[ТекущаяКолонка] > 0 Тогда
						ШириныКолонок[ТекущаяКолонка] = ШириныКолонок[ТекущаяКолонка] - ВекторНевязок[ТекущаяКолонка] * (Мин(СуммаПоложительныхНевязок, СуммаОтрицательныхНевязок) / СуммаПоложительныхНевязок);
					Иначе
						ШириныКолонок[ТекущаяКолонка] = ШириныКолонок[ТекущаяКолонка] + ВекторНевязок[ТекущаяКолонка] * ( - Мин(СуммаПоложительныхНевязок, СуммаОтрицательныхНевязок) / СуммаОтрицательныхНевязок);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Для ТекущаяКолонка = 0 По Мин(ШириныКолонок.ВГраница(), ТабличныйДокумент.ШиринаТаблицы - 1) Цикл
		Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
			ТабличныйДокумент.Область(0, ТекущаяКолонка + 1, ТабличныйДокумент.ВысотаТаблицы, ТекущаяКолонка + 1).ШиринаКолонки = ШириныКолонок[ТекущаяКолонка];
		КонецЕсли;
	КонецЦикла;	
КонецПроцедуры

Процедура ВычислитьШиринуКолонки(ТабличныйДокумент, ТекущаяКолонка, ШириныКолонок, МинимальныеШириныКолонок, Параметры, ВычислятьШирины = Истина)
	МинимальнаяШирина = 0;
	ИтоговаяМинимальнаяШирина = 0;
	ПоправкаНаШрифт = 1;
	Для ТекущаяСтрока = Параметры.НачальнаяСтрока По Параметры.КонечнаяСтрока Цикл
		
		ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
		ТекстЯчейки = ОбластьЯчейки.Текст;
		
		Если ОбластьЯчейки.Шрифт <> Неопределено Тогда
			ПоправкаНаШрифт = ОбластьЯчейки.Шрифт.Масштаб / 100 * ОбластьЯчейки.Шрифт.Размер / 10 * 1.15;
			Если ОбластьЯчейки.Шрифт.Жирный Тогда
				ПоправкаНаШрифт = ПоправкаНаШрифт * 1.1;
			КонецЕсли;
			Если ОбластьЯчейки.Шрифт.Имя = "Arial" Тогда
				ПоправкаНаШрифт = ПоправкаНаШрифт * 1.15;
			КонецЕсли;
		КонецЕсли;
		
		Если ОбластьЯчейки.Лево = ТекущаяКолонка И ОбластьЯчейки.Верх = ТекущаяСтрока Тогда
			МинимальнаяШирина = Макс(МинимальнаяШирина, ПолучитьДлинуМаксимальнойЛексемы(ТекстЯчейки) * ПоправкаНаШрифт + ОбластьЯчейки.Отступ + 0.25);
		КонецЕсли;
		
		
		Если ВычислятьШирины Тогда
			
			ШиринаКолонки = 0;
			АвтоОтступ = 0;
			
			
			
			
			Если ОбластьЯчейки.Лево <> ТекущаяКолонка Или ОбластьЯчейки.Верх <> ТекущаяСтрока Тогда
				
				// Данная ячейка принадлежит объединенным ячейкам и не является начальной ячейкой.
				Продолжить;
				
			КонецЕсли;
			
			Если Параметры.КоличествоУровнейГруппировокСтрок > 0 И ТекущаяСтрока = Параметры.НачалоДанных Тогда
				АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
			КонецЕсли;
			
			Для НомерСтрокиТекста = 1 По СтрЧислоСтрок(ТекстЯчейки) Цикл
				
				ШиринаТекстаЯчейки = СтрДлина(СтрПолучитьСтроку(ТекстЯчейки, НомерСтрокиТекста));
				
				Если АвтоОтступ <> Неопределено И АвтоОтступ > 0 Тогда
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки + Параметры.КоличествоУровнейГруппировокСтрок * АвтоОтступ;
				КонецЕсли;
				
				ШиринаКолонки = Макс(ШиринаКолонки, ШиринаТекстаЯчейки * ПоправкаНаШрифт);
				
			КонецЦикла;
			
			//ШиринаКолонки = ШиринаКолонки;
			
			
			
			
			Если ШиринаКолонки <> 0 Тогда
				
				// Определим, сколько ячеек по ширине используется в области для текущей ячейки.
				КоличествоКолонок = ОбластьЯчейки.Право - ОбластьЯчейки.Лево;
				
				Если КоличествоКолонок = 0 Тогда
					ИтоговаяМинимальнаяШирина = МинимальнаяШирина;
				КонецЕсли;
				
				Для НомерКолонки = 0 По КоличествоКолонок Цикл
					
					Если ШириныКолонок.ВГраница() > ТекущаяКолонка - 1 + НомерКолонки Тогда
						
						Если ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = Неопределено Тогда
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = ШиринаКолонки / (КоличествоКолонок + 1);
						Иначе
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = 
							Макс(ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки], ШиринаКолонки / (КоличествоКолонок + 1));
						КонецЕсли;
					Иначе
						ШириныКолонок.Вставить(ТекущаяКолонка - 1 + НомерКолонки, ШиринаКолонки / (КоличествоКолонок + 1));
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	Если ИтоговаяМинимальнаяШирина = 0 Тогда
		ИтоговаяМинимальнаяШирина = МинимальнаяШирина;
	КонецЕсли;
	МинимальныеШириныКолонок.Добавить(ИтоговаяМинимальнаяШирина);
	
КонецПроцедуры

Функция ПолучитьДлинуМаксимальнойЛексемы(Текст)
	Лексемы_ = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(Текст, " @#");
	Макс_ = 0;
	Для Каждого Лексема_ Из Лексемы_ Цикл
		Если СтрДлина(Лексема_) > Макс_ Тогда
			Макс_ = СтрДлина(Лексема_);
		КонецЕсли;
	КонецЦикла;
	Возврат Макс_;
КонецФункции


// Функция заполняет заголовок документа данными из CDA-документа
//
// Параметры:
//  Область		 - 	ТабличныйДокумент - область шапки.
//  Документ	 - 	ОбъектXDTO - CDA-документ
//  ПараметрыОтображения	 - 	Структура - 
Функция ЗаголовокИзCDA(Область, Документ, ПараметрыОтображения = Неопределено) Экспорт
	Заголовок_ = "";
	СвойстваДокумента_ = Документ.Свойства();
	title = СвойстваДокумента_.Получить("title");
	Если title = Неопределено ИЛИ  ВизуализаторCDA.ПолучитьТекст(Документ.title) = "" Тогда
		Заголовок_ = "Протокол обследования";
	Иначе
		Заголовок_ =  ВизуализаторCDA.ПолучитьТекст(Документ.title);
	КонецЕсли;
	
	СтруктураПараметров_ = Новый Структура("Заголовок", Заголовок_);
	Область.Параметры.Заполнить(СтруктураПараметров_);
	Возврат Область;
КонецФункции


// Функция заполняет шапку документа данными из CDA-документа
//
// Параметры:
//  Область		 - 	ТабличныйДокумент - область шапки.
//  Документ	 - 	ОбъектXDTO - CDA-документ
//  ПараметрыОтображения	 - 	Структура - 
Функция ШапкаИзCDA(Область, Документ, ПараметрыОтображения = Неопределено) Экспорт
	
	Если ПараметрыОтображения <> Неопределено Тогда
		ВыводитьШапку_ = Неопределено;
		ПараметрыОтображения.Свойство("ВыводитьШапку", ВыводитьШапку_);
		Если ВыводитьШапку_ = Ложь Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	ДанныеПациента_ = ПолучитьЗначениеПоПути(Документ, "recordTarget/patientRole");
	ОбластьЗаполнена_ = ДанныеПациента_ <> Неопределено;
	СтруктураПараметров_ = Новый Структура();
	
	Если ОбластьЗаполнена_ Тогда
		НомерКарты_ = "";
		OIDОрганизации_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "providerOrganization/id/root");
		Если ЗначениеЗаполнено(OIDОрганизации_) Тогда
			Если Не ДанныеПациента_.Свойства().Получить("id")=Неопределено Тогда
				ИдентификаторыПациента_ = ДанныеПациента_.id;
				Если ТипЗнч(ИдентификаторыПациента_) = Тип("ОбъектXDTO") Тогда
					АтрибутRoot_ = ПолучитьЗначениеПоПути(ИдентификаторыПациента_, "root");
					АтрибутAAName_ = ПолучитьЗначениеПоПути(ИдентификаторыПациента_, "assigningAuthorityName");
					Если Лев(АтрибутRoot_, СтрДлина(OIDОрганизации_)) = OIDОрганизации_ И ЗначениеЗаполнено(АтрибутAAName_) Тогда
						НомерКарты_ = АтрибутAAName_;
					КонецЕсли;
						
				ИначеЕсли ТипЗнч(ИдентификаторыПациента_) = Тип("СписокXDTO") Тогда
					Для Каждого Ид_ Из ИдентификаторыПациента_ Цикл
						АтрибутRoot_ = ПолучитьЗначениеПоПути(Ид_, "root");
						АтрибутAAName_ = ПолучитьЗначениеПоПути(Ид_, "assigningAuthorityName");
						Если Лев(АтрибутRoot_, СтрДлина(OIDОрганизации_)) = OIDОрганизации_ И ЗначениеЗаполнено(АтрибутAAName_) Тогда
							НомерКарты_ = АтрибутAAName_;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(НомерКарты_) Тогда
			АтрибутRoot_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "id/root");
			Если СтрДлина(АтрибутRoot_) = 36 И СтрНайти(АтрибутRoot_, "-") > 0 Тогда 
				НомерКарты_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "id/extension");
			КонецЕсли;
		КонецЕсли;
		СтруктураПараметров_.Вставить("НомерКарты", НомерКарты_);
		
		Если Не ДанныеПациента_.Свойства().Получить("addr") = Неопределено Тогда
			Адреса_ = ДанныеПациента_.addr;
			АдресФактический_ = "";
			АдресРегистрации_ = "";
			Если ТипЗнч(Адреса_) = Тип("ОбъектXDTO") Тогда
				Адрес_ = Адреса_;
				КодТипаАдреса = ПолучитьЗначениеПоПути(Адрес_, "Type/code");
				Если ЗначениеЗаполнено(КодТипаАдреса) И КодТипаАдреса = "1" Тогда
						АдресРегистрации_ = ПолучитьАдрес(Адрес_);
					ИначеЕсли ЗначениеЗаполнено(КодТипаАдреса) И КодТипаАдреса = "3" Тогда
						АдресФактический_ = ПолучитьАдрес(Адрес_);
					КонецЕсли;
					
					ТипАдреса_ = ПолучитьЗначениеПоПути(Адрес_, "use");
					Если ЗначениеЗаполнено(ТипАдреса_) И Не ЗначениеЗаполнено(АдресРегистрации_) И ВРег(ТипАдреса_) = "H" Тогда
						АдресРегистрации_ = ПолучитьАдрес(Адрес_);
					ИначеЕсли ЗначениеЗаполнено(ТипАдреса_) И Не ЗначениеЗаполнено(АдресФактический_) И ВРег(ТипАдреса_) = "HP" Тогда
						АдресФактический_ = ПолучитьАдрес(Адрес_);
					КонецЕсли;
			ИначеЕсли ТипЗнч(Адреса_) = Тип("СписокXDTO") Тогда			
				Для Каждого Адрес_ Из Адреса_ Цикл
					КодТипаАдреса = ПолучитьЗначениеПоПути(Адрес_, "Type/code");
					Если ЗначениеЗаполнено(КодТипаАдреса) И КодТипаАдреса = "1" Тогда
						АдресРегистрации_ = ПолучитьАдрес(Адрес_);
					ИначеЕсли ЗначениеЗаполнено(КодТипаАдреса) И КодТипаАдреса = "3" Тогда
						АдресФактический_ = ПолучитьАдрес(Адрес_);
						Прервать;
					КонецЕсли;
					
					ТипАдреса_ = ПолучитьЗначениеПоПути(Адрес_, "use");
					Если ЗначениеЗаполнено(ТипАдреса_) И Не ЗначениеЗаполнено(АдресРегистрации_) И ВРег(ТипАдреса_) = "H" Тогда
						АдресРегистрации_ = ПолучитьАдрес(Адрес_);
					ИначеЕсли ЗначениеЗаполнено(ТипАдреса_) И Не ЗначениеЗаполнено(АдресФактический_) И ВРег(ТипАдреса_) = "HP" Тогда
						АдресФактический_ = ПолучитьАдрес(Адрес_);
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(АдресФактический_) Тогда
			СтруктураПараметров_.Вставить("Местожительство", АдресФактический_);
		ИначеЕсли ЗначениеЗаполнено(АдресРегистрации_) Тогда
			СтруктураПараметров_.Вставить("Местожительство", АдресРегистрации_);
		КонецЕсли;
		
		ДанныеПациента_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "patient");
		
		Пациент_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "name");
		СтруктураПараметров_.Вставить("Пациент", ПолучитьИмя(Пациент_)); 
		
		
		ДатаРождения_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "birthTime/value");
		СтруктураПараметров_.Вставить("ДатаРождения", ПолучитьДату(ДатаРождения_)); 
		
		Пол_ = ПолучитьЗначениеПоПути(ДанныеПациента_, "administrativeGenderCode/code");
		Пол_ = НРег(Пол_);
		Если Пол_ = "m" ИЛИ Пол_ = "1" Тогда
			Пол_ = "Мужской";
		ИначеЕсли Пол_ = "f"  ИЛИ Пол_ = "2" Тогда
			Пол_ = "Женский";
		Иначе
			Пол_ = "";
		КонецЕсли;
		СтруктураПараметров_.Вставить("Пол", Пол_); 
	КонецЕсли;
	
	
	Дата_ = ПолучитьЗначениеПоПути(Документ, "effectiveTime/value");
	
	Если Не Дата_ = Неопределено Тогда
		ОбластьЗаполнена_ = Истина;
		СтруктураПараметров_.Вставить("ДатаВыполнения", ПолучитьДату(Дата_ ));
		СтруктураПараметров_.Вставить("ВремяВыполнения", ПолучитьВремя(Дата_));
	КонецЕсли;
	
	Врач_ = ВыбратьЗаполненноеЗначениеПоПутям(
		Документ,
		АлгоритмыДляКоллекций.СоздатьМассив(
			"componentOf/encompassingEncounter/encounterParticipant/assignedEntity",
			"author/assignedAuthor",
			"responsibleParty/assignedEntity",
			"legalAuthenticator/assignedEntity"
		)
	);
	
	ВрачПредставление_ = "";
	Если Врач_ <> Неопределено Тогда
		ОбластьЗаполнена_ = Истина;
		ВрачПредставление_ = ПолучитьИмя(ПолучитьЗначениеПоПути(Врач_, "assignedPerson/name"));
		Должность_ = ПолучитьЗначениеПоПути(Врач_, "code/displayName");
		Если ЗначениеЗаполнено(Должность_) Тогда
			ВрачПредставление_ = СтрШаблон("%1, %2", Должность_, ВрачПредставление_);
		КонецЕсли;
	КонецЕсли;
	
	СтруктураПараметров_.Вставить("Врач", ВрачПредставление_);
	
	Организация_ = ВыбратьЗаполненноеЗначениеПоПутям(
		Документ, 
		АлгоритмыДляКоллекций.СоздатьМассив(
			"componentOf/encompassingEncounter/encounterParticipant/assignedEntity/representedOrganization",
			"author/assignedAuthor/representedOrganization",
			"responsibleParty/assignedEntity/representedOrganization",
			"legalAuthenticator/assignedEntity/representedOrganization"
		)
);
	
	Если Организация_ <> Неопределено Тогда
		ОбластьЗаполнена_ = Истина;
		НазваниеОрг_ = ПолучитьЗначениеПоПути(Организация_, "name");
		СтруктураПараметров_.Вставить("Организация", ПолучитьИмя(НазваниеОрг_));
		
		Телефон_ = ПолучитьЗначениеПоПути(Организация_, "telecom/value");
		СтруктураПараметров_.Вставить("Телефон", СокрЛП(СтрЗаменить(Телефон_,"tel:", "")));
		
		Адрес_ = ПолучитьЗначениеПоПути(Организация_, "addr");
		СтрАдрес_ = "";
		Если Не Адрес_ = Неопределено Тогда
			Индекс_ = ПолучитьЗначениеПоПути(Адрес_, "postalCode");
			Если ТипЗнч(Индекс_) = Тип("Строка") И Не Индекс_ = "" Тогда
				СтрАдрес_ = СтрАдрес_ + Индекс_ + ", ";
			КонецЕсли;
			
			Страна_ = ПолучитьЗначениеПоПути(Адрес_, "country");
			Если ТипЗнч(Страна_) = Тип("Строка") И Не Страна_ = "" Тогда
				СтрАдрес_ = СтрАдрес_ + Страна_ + ", ";
			КонецЕсли;
			
			Город_ = ПолучитьЗначениеПоПути(Адрес_, "city");
			Если ТипЗнч(Город_) = Тип("Строка") И Город_ = "" Тогда
				СтрАдрес_ = СтрАдрес_ + Город_ + ", ";
			КонецЕсли;
			
			Адр_ = ПолучитьЗначениеПоПути(Адрес_, "streetAddressLine");
			Если ТипЗнч(Адр_) = Тип("Строка") И Не Адр_ = "" Тогда
				Если ТипЗнч(Индекс_) = Тип("Строка") И Не Индекс_ = "" И СтрНайти(Адр_, Индекс_) <> 0 Тогда
					Адр_ = СокрЛП(СтрЗаменить(Адр_, Индекс_+",", ""));
				КонецЕсли;
				СтрАдрес_ = СтрАдрес_ + Адр_ + ", ";
			ИначеЕсли ТипЗнч(Адр_) = Тип("ОбъектXDTO") Тогда
				Если Адр_.Последовательность().Количество() > 0 Тогда
					СтрАдрес_ = СтрАдрес_ + Адр_.Последовательность().ПолучитьТекст(0) + ", ";
				КонецЕсли;
			КонецЕсли;
			
			Если СтрДлина(СтрАдрес_) > 0 Тогда
				СтрАдрес_ = Лев(СтрАдрес_, СтрДлина(СтрАдрес_) - 2);
			КонецЕсли;
			СтруктураПараметров_.Вставить("Адрес", СтрАдрес_);

			
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не Документ.Свойства().Получить("participant") = Неопределено Тогда
		Участники_ = Документ.participant;
	
		Если Участники_ <> Неопределено Тогда
			Если ТипЗнч(Участники_) = Тип("ОбъектXDTO") Тогда
				Если НРег(Участники_.typeCode) = "ref" Тогда
					ИмяНазначившего_ = ПолучитьИмя(ПолучитьЗначениеПоПути(Участники_, "associatedEntity/associatedPerson/name"), Истина);
					НазначившаяОрганизация_ = ПолучитьЗначениеПоПути(Участники_, "associatedEntity/scopingOrganization/name");
					СтрокаНазначивший_ = ИмяНазначившего_;
					Если ЗначениеЗаполнено(НазначившаяОрганизация_) Тогда
						СтрокаНазначивший_ = СтрШаблон("%1 (%2)", СтрокаНазначивший_, НазначившаяОрганизация_);
					КонецЕсли;
					СтруктураПараметров_.Вставить("Назначил", СтрокаНазначивший_);
					ОбластьЗаполнена_ = Истина;
				КонецЕсли;
			ИначеЕсли ТипЗнч(Участники_) = Тип("СписокXDTO") Тогда
				Для Каждого Участник_ Из Участники_ Цикл
					Если НРег(Участник_.typeCode) = "ref" Тогда
						ИмяНазначившего_ = ПолучитьИмя(ПолучитьЗначениеПоПути(Участник_, "associatedEntity/associatedPerson/name"), Ложь);
						СтруктураПараметров_.Вставить("Назначил", ИмяНазначившего_);
						ОбластьЗаполнена_ = Истина;
						Прервать;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;
	
	Если ОбластьЗаполнена_ Тогда
		Область.Параметры.Заполнить(СтруктураПараметров_);
		Возврат Область;
	Иначе 
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Процедура заполняет подвал документа
//
// Параметры:
//  Область		 - 	ТабличныйДокумент - область подвала.
//  Документ	 - 	ОбъектXDTO - CDA-документ
//  Параметры	 - 	Структура - 
Функция ПодвалИзCDA(Область, Документ, Параметры = Неопределено)  Экспорт
	Подпись_ = Неопределено;
	Дата_ = Неопределено;
	ВыводитьОбласть_ = Ложь;
	Результат_ = Новый ТабличныйДокумент;
	
	Если Параметры.ПодписанЭП Тогда
		Возврат Неопределено;
	КонецЕсли;			
					
	СвойстваДокумента_ = Документ.Свойства();
	
	Исполнители_ = ПолучитьЗначениеПоПути(Документ, "documentationOf/serviceEvent");
	Если Не Исполнители_ = Неопределено И
		Не Исполнители_.Свойства().Получить("performer") = Неопределено
	Тогда
		Если ТипЗнч(Исполнители_.performer) = Тип("ОбъектXDTO") Тогда
			ЗаполненнаяОбластьПодписи_ = ЗаполнитьПодпись(Область, Исполнители_.performer);
			Если Не ЗаполненнаяОбластьПодписи_ = Неопределено Тогда
				ВыводитьОбласть_ = Истина;
				Результат_.Вывести(ЗаполненнаяОбластьПодписи_);
			КонецЕсли;
		ИначеЕсли ТипЗнч("Исполнители_.performer") = Тип("СписокXDTO") Тогда
			Для Каждого Исполнитель_ Из Исполнители_.performer Цикл
				ЗаполненнаяОбластьПодписи_ = ЗаполнитьПодпись(Область, Исполнитель_);
				Если Не ЗаполненнаяОбластьПодписи_ = Неопределено Тогда
					ВыводитьОбласть_ = Истина;
					Результат_.Вывести(ЗаполненнаяОбластьПодписи_);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли Не Документ.Свойства().Получить("author") = Неопределено Тогда
		Автор_ = Документ["author"];
		Если ТипЗнч(Автор_) = Тип("СписокXDTO") Тогда
			Автор_ = Автор_.Получить(0);
		КонецЕсли;
		ЗаполненнаяОбластьПодписи_ = ЗаполнитьПодпись(Область, Автор_);
		Если Не ЗаполненнаяОбластьПодписи_ = Неопределено Тогда
			ВыводитьОбласть_ = Истина;
			Результат_.Вывести(ЗаполненнаяОбластьПодписи_);
		КонецЕсли;
	КонецЕсли;
	
	Если ВыводитьОбласть_ Тогда
		Возврат Результат_;
	КонецЕсли;
	
	Возврат Неопределено;	
КонецФункции

Функция ЗаполнитьОбластьПодписи(Область, Документ, СвойстваДокумента, ИмяЭлемента, ЭП, ВыводитьТолькоПервуюПодпись = Ложь)
	Результат_ = Новый ТабличныйДокумент;
	Если Не СвойстваДокумента.Получить(ИмяЭлемента) = Неопределено Тогда
		Authenticator_ = Документ[ИмяЭлемента];
		Если ТипЗнч(Authenticator_) = Тип("ОбъектXDTO") Тогда
			Если Не ЭлементСодержитОтметкуЭП(Authenticator_) И НЕ Authenticator_.Свойства().Получить("signatureText") = Неопределено Тогда
				ЗаполненнаяОбластьПодписи_ = ЗаполнитьПодпись(Область, Authenticator_);
				Если Не ЗаполненнаяОбластьПодписи_ = Неопределено Тогда
					Результат_.Вывести(ЗаполненнаяОбластьПодписи_);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Authenticator_) = Тип("СписокXDTO") Тогда
			Для Каждого Подписант_ Из Authenticator_ Цикл
				Если Не ЭлементСодержитОтметкуЭП(Подписант_)  И НЕ Подписант_.Свойства().Получить("signatureText") = Неопределено Тогда
					ЗаполненнаяОбластьПодписи_ = ЗаполнитьПодпись(Область, Подписант_);
					Если Не ЗаполненнаяОбластьПодписи_ = Неопределено Тогда
						Результат_.Вывести(ЗаполненнаяОбластьПодписи_);
						Если ВыводитьТолькоПервуюПодпись Тогда
							Прервать;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;	
	КонецЕсли;
	
	Если Результат_.ВысотаТаблицы = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат_;	
КонецФункции

Функция ЗаполнитьПодпись(Знач Область, Подписант)
	ВыводитьОбласть_ = Ложь;
	СтруктураПараметров_ = Новый Структура;
	Врач_ = ПолучитьЗначениеПоПути(Подписант, "assignedEntity/assignedPerson/name");
	
	Если Врач_ = Неопределено Тогда
		Врач_ = ПолучитьЗначениеПоПути(Подписант, "assignedAuthor/assignedPerson/name");
	КонецЕсли;
	
	Если Врач_ <> Неопределено Тогда
		Подпись_ = СокрЛП(ПолучитьИмя(Врач_));
		
		Организация_ = ПолучитьЗначениеПоПути(Подписант, "assignedEntity/representedOrganization/name");
		Если ТипЗнч(Организация_) = Тип("Строка") Тогда
			Подпись_ =  СтрШаблон("%1, %2", Подпись_, Организация_);
		КонецЕсли;
		
		
		Роль_ = ПолучитьЗначениеПоПути(Подписант, "functionCode/displayName");
		Если Не Роль_ = Неопределено И Не Роль_ = "" Тогда
			НазваниеПодписи_ = СтрШаблон("%1:", Роль_);
		Иначе
			НазваниеПодписи_ = "Подпись врача:";
		КонецЕсли;
		СтруктураПараметров_.Вставить("Подпись", Подпись_);
		СтруктураПараметров_.Вставить("НазваниеПодписи", НазваниеПодписи_);
		
		ВыводитьОбласть_ = Истина;
	КонецЕсли;
	
	Дата_ = ПолучитьЗначениеПоПути(Подписант, "time/value");
	
	Если Дата_ <> Неопределено Тогда
		СтруктураПараметров_.Вставить("Дата", СтрШаблон("%1 %2", ПолучитьДату(Дата_), ПолучитьВремя(Дата_, Истина)));
		ВыводитьОбласть_ = Истина;
	КонецЕсли;
	
	Если Не ВыводитьОбласть_ Тогда
		Возврат Неопределено;
	КонецЕсли;
	Область.Параметры.Заполнить(СтруктураПараметров_);
	Возврат Область;	
КонецФункции

// Процедура заполняет блок ЭлектроннаяПодпись документа
//
// Параметры:
//  Область		 - 	ТабличныйДокумент - область подвала.
//  Документ	 - 	ОбъектXDTO - CDA-документ
//  Параметры	 - 	Структура - 
Функция ЭлектроннаяПодписьИзCDA(Область, Документ, Параметры = Неопределено)  Экспорт
	Подпись_ = Неопределено;
	Дата_ = Неопределено;
	ВыводитьОбласть_ = Ложь;
	Результат_ = Новый ТабличныйДокумент;
	
	СвойстваДокумента_ = Документ.Свойства();
	
	ОбластьПодписи_ = ЗаполнитьОбластьПодписи(Область, Документ, СвойстваДокумента_, "authenticator", Истина);
	Если Не ОбластьПодписи_ = Неопределено Тогда
		Результат_.Вывести(ОбластьПодписи_);
	КонецЕсли;
	
	ОбластьПодписи_ = ЗаполнитьОбластьПодписи(Область, Документ, СвойстваДокумента_, "legalAuthenticator", Истина);
	Если Не ОбластьПодписи_ = Неопределено Тогда
		Результат_.Вывести(ОбластьПодписи_);
	КонецЕсли;
	
	Если Результат_.ВысотаТаблицы = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Результат_;	
КонецФункции

// Процедура заполняет блок ДокументГотов документа
//
// Параметры:
//  Область		 - 	ТабличныйДокумент - область документ готов.
//  Документ	 - 	ОбъектXDTO - CDA-документ
//  Параметры	 - 	Структура - 
Функция ДокументНеГотовИзCDA(Область, Документ, Параметры = Неопределено)  Экспорт
	Если Параметры <> Неопределено И Параметры.Свойство("ДокументГотов") И Не Параметры.ДокументГотов Тогда
		Возврат Область;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Функция ВключатьОбластьВВизуализацию проверяет нужно ли включать секцию в документ по коду секции, 
//    согласно регистру сведений СекцииМДШаблоновМедицинскихДокументов и справочнику СтруктураСекцийМД.
//
// Параметры:
//  СсылкаМД  - ДокументСсылка.МедицинскийДокумент - ссылка на документ, для которого считываются параметры отображения секции.
//  ПолныйДокумент  - Булево - флаг полный или усеченный документ.
//  КодСекции  - Строка - код отображаемой секции из справочника СтруктураСекцийМД.
//
// Возвращаемое значение:
//   Булево   - Истина --- секция будет отображаться в документе, Ложь --- не будет.
//
Функция ВключатьОбластьВВизуализацию(СсылкаМД, ПолныйДокумент, КодСекции) Экспорт
	Если ПолныйДокумент Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Метаданные.ОбщиеМодули.Найти("ПодсистемаМедицинаПоликлиника") <> Неопределено Тогда
		ШМД_ = Документы["МедицинскийДокумент"].ПолучитьШаблонМедицинскогоДокумента(СсылкаМД);
		Запрос_ = Новый Запрос(
			"ВЫБРАТЬ
			|	СтруктураСекцийМД.Ссылка КАК Ссылка,
			|	СтруктураСекцийМД.АтрибутCode КАК Код,
			|	ЕСТЬNULL(СекцииМДШаблоновМедицинскихДокументов.ВключатьВВизуализацию, СтруктураСекцийМД.ВключатьВВизуализацию) КАК ВключатьВВизуализацию
			|ИЗ
			|	Справочник.СтруктураСекцийМД КАК СтруктураСекцийМД
			|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.СекцииМДШаблоновМедицинскихДокументов КАК СекцииМДШаблоновМедицинскихДокументов
			|		ПО (СекцииМДШаблоновМедицинскихДокументов.СекцияМД = СтруктураСекцийМД.Ссылка)
			|			И (СекцииМДШаблоновМедицинскихДокументов.ШаблонМедицинскогоДокумента = &ШаблонМедицинскогоДокумента)
			|ГДЕ
			|	СтруктураСекцийМД.АтрибутCode =&КодСекции"
		);
		Запрос_.УстановитьПараметр("КодСекции", КодСекции);
		Запрос_.УстановитьПараметр("ШаблонМедицинскогоДокумента", ШМД_);
		Выборка_ = Запрос_.Выполнить().Выбрать();
		
		Пока Выборка_.Следующий() Цикл
			Возврат Выборка_.ВключатьВВизуализацию = ПредопределенноеЗначение("Перечисление.ВидыОтметкиПечати.Усеченный");
		КонецЦикла;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции


// Функции, предназначенные для преобразования CDA в текст.

// Функция - получеет из CDA структуру с заполненной иерархией секций и текстовое содержимое этих секций.
//
// Параметры:
//  CDA	 - Строка	 - CDA-документ.
// 
// Возвращаемое значение:
//  Соответствие - ключ .
//
Функция CDA2СтруктураСекций(CDA) Экспорт
	СтруктураСекций_ = Новый Соответствие;
	ВремФайл_ = ПолучитьИмяВременногоФайла("html");
	Текст_ = Новый ТекстовыйДокумент;
	Текст_.ДобавитьСтроку(CDA);
	Текст_.Записать(ВремФайл_);
	
	DOMПостроитель_ =  Новый ПостроительDOM() ; 
	ЧтениеXML_ = Новый ЧтениеXML;
	ЧтениеXML_.УстановитьСтроку(CDA);
	DOMДокумент_ = DOMПостроитель_.Прочитать(ЧтениеXML_);
	РазыменовательПИ_ = DOMДокумент_.СоздатьРазыменовательПИ(DOMДокумент_);	
	
	ТекстЗапросаXPath_ = "*[local-name()='title']";	
	Заголовок_ = ВыполнитьXPath(ТекстЗапросаXPath_, DOMДокумент_, РазыменовательПИ_);
	//Шапка_ = ВывестиШапку(DOMДокумент_, РазыменовательПИ_);
	ЭлементStructuredBody_ = DOMДокумент_.ЭлементДокумента.ПолучитьЭлементыПоИмени("structuredBody")[0];
	ЗаполнитьСтруктуруСекцийCDA(СтруктураСекций_, "", ЭлементStructuredBody_);
	// Добавить Шапку и Подвал
	Возврат СтруктураСекций_;
КонецФункции

Процедура ЗаполнитьСтруктуруСекцийCDA(СтруктураСекций, Префикс, ЭлементDOM)
	Для Каждого Компонент_ Из ЭлементDOM.ДочерниеУзлы Цикл
		Если Компонент_.ИмяУзла <> "component" Тогда
			Продолжить;
		КонецЕсли;
		ЭлементSection_ = НайтиЭлемент(Компонент_, "section");
		ЭлементCode_ = НайтиЭлемент(ЭлементSection_, "code");
		ЭлементText_ = НайтиЭлемент(ЭлементSection_, "text");
		ЭлементTitle_ = НайтиЭлемент(ЭлементSection_, "title");
		Код_ = "";
		ЗаголовокИсходный_ = "";
		Заголовок_ = "";
		
		Если ЭлементCode_ <> Неопределено Тогда
			Код_ = ЭлементCode_.ПолучитьАтрибут("code");
		КонецЕсли;
			
		Если ЭлементTitle_ <> Неопределено Тогда
			ЗаголовокИсходный_ = ЭлементTitle_.ТекстовоеСодержимое;
			Заголовок_ = СтрЗаменить(ЗаголовокИсходный_, " ", "_");
		КонецЕсли;
		
		КодСекции_ = СтрШаблон("%1_%2/", Код_, Заголовок_);
		
		Если ЭлементText_ <> Неопределено Тогда
			ТекстЭлемента_ = ПолучитьТекстовоеПредставлениеЭлементаDOM(ЭлементText_);
			СтруктураСекций.Вставить(Префикс + КодСекции_, АлгоритмыДляКоллекций.СоздатьМассив(ЗаголовокИсходный_, ТекстЭлемента_));	
		КонецЕсли;
		ЗаполнитьСтруктуруСекцийCDA(СтруктураСекций, Префикс + КодСекции_, ЭлементSection_);
	КонецЦикла;	
КонецПроцедуры

// Функция - Выполнить XPath
//
// Параметры:
//  ТекстЗапросаXPath	 - 	Строка - Текст запроса XPath. 
//  DOMДокумент			 - 	DOMДокумент - DOMДокумент.
//  РазыменовательПИ	 - 	 РазыменовательПространствИменDOM - разыменователь пространствИменDOM
// 
// Возвращаемое значение:
//  Строка - строка с текстовым представлением области, полученной по запросу XPath. 
//
Функция ВыполнитьXPath(ТекстЗапросаXPath, DOMДокумент, РазыменовательПИ) Экспорт
	Если НЕ ЗначениеЗаполнено(ТекстЗапросаXPath) Тогда
		Возврат Неопределено;
	КонецЕсли;

	XPathЗапрос_ = DOMДокумент.СоздатьВыражениеXPath(ТекстЗапросаXPath, РазыменовательПИ);
	РезультатЗапросаXPath_ = XPathЗапрос_.Вычислить(DOMДокумент);

	Результат_ = "";
	ЭлементDOM_ = РезультатЗапросаXPath_.ПолучитьСледующий();
	Пока ЭлементDOM_ <> Неопределено Цикл
		Результат_ = Результат_
			+ ?(ЗначениеЗаполнено(Результат_), Символы.ПС, "")
			+ ПолучитьTitleВсехРодительскихSection(ЭлементDOM_, "", "");
		ТекстЭлемента_ = ПолучитьТекстовоеПредставлениеЭлементаDOM(ЭлементDOM_);
		Если ЗначениеЗаполнено(ТекстЭлемента_) Тогда
			Результат_ = Результат_
			+ ?(ЗначениеЗаполнено(Результат_), Символы.ПС, "")
			+ ТекстЭлемента_
			;
		КонецЕсли;
		ЭлементDOM_ = РезультатЗапросаXPath_.ПолучитьСледующий();
	КонецЦикла;

	Возврат Результат_;
КонецФункции

// Функция - Получить текстовое представление элемента DOM
//
// Параметры:
//  ЭлементDOM	 - ЭлементDOM	 - элемент человекочитаемой части CDA.
// 
// Возвращаемое значение:
//  Строка - текстовое представление человекочитаемой части CDA.
//
Функция ПолучитьТекстовоеПредставлениеЭлементаDOM(ЭлементDOM) Экспорт 	
	Результат_ = "";
	ДочерниеУзлы_ = ЭлементDOM.ДочерниеУзлы;
	Для Каждого ДочернийУзел_ Из ДочерниеУзлы_ Цикл
		ИмяУзла_ = ДочернийУзел_.ИмяУзла;	
		Если ИмяУзла_ = "table" Тогда
			Если НайтиЭлемент(ДочернийУзел_, "caption") = Неопределено Тогда
				Текст_ = СчитатьТаблицуПострочно(ДочернийУзел_);
			Иначе
				Текст_ = РазобратьТаблицу(ДочернийУзел_);
			КонецЕсли;
		ИначеЕсли ИмяУзла_ = "list" Тогда
			Текст_ = ВывестиСписокВТекст(ДочернийУзел_);
		ИначеЕсли ИмяУзла_ = "renderMultiMedia" Тогда
			Текст_ = СокрЛП(ДочернийУзел_.ТекстовоеСодержимое);				
			Текст_ = Текст_ + " " + ДочернийУзел_.ПолучитьАтрибут("referencedObject");
		Иначе
			Текст_ = СокрЛП(ДочернийУзел_.ТекстовоеСодержимое);
		КонецЕсли;
		
		
		Если ЗначениеЗаполнено(Текст_) Тогда
			Результат_ = Результат_
			+ ?(ЗначениеЗаполнено(Результат_), Символы.ПС, "")
			+ Текст_
			;
		КонецЕсли;	
	КонецЦикла;
	Возврат Результат_;
КонецФункции

Функция РазобратьТаблицу(ЭлементDOM)
	МассивСтрок_ = Новый Массив;
	Результат_ = "";
	
	caption_ = НайтиЭлемент(ЭлементDOM, "caption");
	Если ЗначениеЗаполнено(caption_.ТекстовоеСодержимое) Тогда
		Результат_ = СокрЛП(caption_.ТекстовоеСодержимое) + Символы.ПС;
	КонецЕсли;

	
	tbody_ = НайтиЭлемент(ЭлементDOM, "tbody");
	Если tbody_ <> Неопределено
		И tbody_.ДочерниеУзлы.Количество() > 0
	Тогда
		
		
		thead_ = НайтиЭлемент(ЭлементDOM, "thead");
		
		Если thead_ <> Неопределено
			И thead_.ДочерниеУзлы.Количество() > 0
			И thead_.ДочерниеУзлы[0].ИмяУзла = "tr"
		Тогда
			// Есть шапка таблицы
			Для Каждого th_ Из thead_.ДочерниеУзлы[0].ДочерниеУзлы Цикл
				МассивСтрок_.Добавить(СокрЛП(th_.ТекстовоеСодержимое) + " -");
			КонецЦикла;
		КонецЕсли;
		
		Первый_ = Истина;
		Для Каждого tr_ Из tbody_.ДочерниеУзлы Цикл
			НомерСтолбца_ = 0;
			Для Каждого td_ Из tr_.ДочерниеУзлы Цикл
				Если МассивСтрок_.Количество() <= НомерСтолбца_ Тогда
					МассивСтрок_.Добавить(СокрЛП(td_.ТекстовоеСодержимое));
				Иначе
					МассивСтрок_[НомерСтолбца_] = МассивСтрок_[НомерСтолбца_] + ?(Первый_, " ", ", ") + СокрЛП(td_.ТекстовоеСодержимое);
				КонецЕсли;
				НомерСтолбца_ = НомерСтолбца_ + 1;
			КонецЦикла;
			Первый_ = Ложь;
		КонецЦикла;
		
		
		tfoot_ = НайтиЭлемент(ЭлементDOM, "tfoot");
		
		Если tfoot_ <> Неопределено
			И tfoot_.ДочерниеУзлы.Количество() > 0
			И tfoot_.ДочерниеУзлы[0].ИмяУзла = "tr"
		Тогда
			// Есть подвал таблицы
			НомерСтолбца_ = 0;
			Для Каждого td_ Из tfoot_.ДочерниеУзлы[0].ДочерниеУзлы Цикл
				МассивСтрок_[НомерСтолбца_] = МассивСтрок_[НомерСтолбца_] + " " + СокрЛП(td_.ТекстовоеСодержимое);
				НомерСтолбца_ = НомерСтолбца_ + 1;
			КонецЦикла;
		КонецЕсли;
		
		
		ТекстДок_ = Новый ТекстовыйДокумент;
		Для Каждого Строка_ Из МассивСтрок_ Цикл
			ТекстДок_.ДобавитьСтроку(Строка_);
		КонецЦикла;
		
		Результат_ = Результат_ + ТекстДок_.ПолучитьТекст();
		
		Возврат Результат_;
	КонецЕсли;
	
	Возврат ЭлементDOM.ТекстовоеСодержимое;
КонецФункции

Функция СчитатьТаблицуПострочно(Таблица)
	thead_ = НайтиЭлемент(Таблица, "thead");
	tbody_ = НайтиЭлемент(Таблица, "tbody");
	tfoot_ = НайтиЭлемент(Таблица, "tfoot");
	Если tbody_ = Неопределено Тогда
		tbody_ = Таблица;
	КонецЕсли;
	Результат_ = СчитатьОбластьТаблицыПострочно(thead_) 
		+ СчитатьОбластьТаблицыПострочно(tbody_) 
		+ СчитатьОбластьТаблицыПострочно(tfoot_);
	Возврат Результат_;
КонецФункции

Функция СчитатьОбластьТаблицыПострочно(ОбластьТаблицы)
	Результат_ = "";
	Если ОбластьТаблицы = Неопределено Тогда
		Возврат Результат_;
	КонецЕсли;
	
	Для Каждого tr_ Из ОбластьТаблицы.ДочерниеУзлы Цикл
		Если Не tr_.ИмяУзла = "tr" Тогда
			Продолжить;
		КонецЕсли;
		Строка_ = "";
		Для Каждого td_ Из tr_.ДочерниеУзлы Цикл
			Строка_ = Строка_ + " " + ПолучитьТекстовоеПредставлениеУзла(td_);
		КонецЦикла;
		Результат_ = Результат_ + Строка_ + Символы.ПС;
	КонецЦикла;
	Возврат Результат_;
КонецФункции

Функция ПолучитьТекстовоеПредставлениеУзла(Узел)
	Результат_ = "";
	Для Каждого Элемент_ Из Узел.ДочерниеУзлы Цикл
		ИмяЭлемента_ = Элемент_.ИмяУзла;
		Если ИмяЭлемента_ = "#text" ИЛИ ИмяЭлемента_ = "paragraph" ИЛИ ИмяЭлемента_ = "content" Тогда
			Результат_ = Результат_ + СокрЛП(Элемент_.ТекстовоеСодержимое);
		ИначеЕсли ИмяЭлемента_ = "list" Тогда
			Результат_ = Результат_ + ВывестиСписокВТекст(Элемент_);
		ИначеЕсли ИмяЭлемента_ = "br" Тогда
			Результат_ = Результат_ + Символы.ПС;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат_;
КонецФункции

Функция ВывестиСписокВТекст(Список)
	Результат_ = "";
	Тип_ = Список.ПолучитьАтрибут("listType");
	Нумерованый_ = Тип_ = "ordered";
	Счетчик_ = 1;
	Для Каждого Элемент_ Из Список.ДочерниеУзлы Цикл
		Результат_ = Результат_ 
		+ ?(ПустаяСтрока(Результат_), "",  Символы.ПС)
		+ ?(Нумерованый_, СтрШаблон("%1. ", Счетчик_),  "- ")
		+ СокрЛП(Элемент_.ТекстовоеСодержимое);
		Счетчик_ = Счетчик_ + 1;
	КонецЦикла;
	Возврат Результат_;
КонецФункции

Функция НайтиЭлемент(ЭлементDOM, ИмяДочернегоЭлемента)
	Если ЭлементDOM = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого Э_ Из ЭлементDOM.ДочерниеУзлы Цикл
		Если Э_.ИмяУзла = ИмяДочернегоЭлемента Тогда
			Возврат Э_;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

Функция ПолучитьTitleВсехРодительскихSection(ЭлементDOM, Префикс, Суффикс)
	Если ЭлементDOM = Неопределено Тогда
		Возврат "";
	КонецЕсли;

	Результат_ = "";
	Родитель_ = ЭлементDOM.РодительскийУзел;
	Пока Родитель_ <> Неопределено Цикл
		Если Родитель_.ИмяУзла <> "section" Тогда
			Родитель_ = Родитель_.РодительскийУзел;
			Продолжить;
		КонецЕсли;
		
		titles_ = Родитель_.ПолучитьЭлементыПоИмени("*", "title");
		Для Каждого title_ Из titles_ Цикл
			Если title_.РодительскийУзел <> Родитель_ Тогда
				Продолжить;
			КонецЕсли;

			Если ЗначениеЗаполнено(СокрЛП(title_.ТекстовоеСодержимое)) Тогда
				Результат_ = СтрШаблон("%1. %2", СокрЛП(title_.ТекстовоеСодержимое), Результат_);// + Символы.ПС;
			КонецЕсли;
		КонецЦикла;

		Родитель_ = Родитель_.РодительскийУзел;
	КонецЦикла;
	Если ЗначениеЗаполнено(Результат_) Тогда
		Результат_ = Лев(Результат_, СтрДлина(Результат_) - 2);
		Результат_ = СтрШаблон(Префикс + "%1" + Суффикс, Результат_);
	КонецЕсли;
	Возврат Результат_;
КонецФункции

Функция ПроверитьВыводКодируемыхПолейСекции(СтрокаТаблицы, КодыИсключаемыхПолей) 
	Если КодыИсключаемыхПолей = Неопределено ИЛИ 
		ТипЗнч(КодыИсключаемыхПолей) <> Тип("Массив") ИЛИ 
		КодыИсключаемыхПолей.Количество() = 0 Тогда 
		Возврат Истина;
	КонецЕсли;
	
	ИДСтроки_ = СтрокаТаблицы.Получить("ID");
	Если ИДСтроки_ = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	МассивИД_ = СтрРазделить(ИДСтроки_,".");
	Если МассивИД_.Количество() < 3 Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодПоля_ = СокрЛП(МассивИД_.Получить(2));
	Возврат (КодыИсключаемыхПолей.Найти(КодПоля_) = Неопределено);
КонецФункции

// Функция - Выполнить замену пространства имен на f88.
// Поскольку в платформе отсутствует возможность добавить в описание XDTO-объекта
// несколько свойств с одинаковым именем, но из различных пространстр имен, 
// то выполняем приведение к пространству имен f88.
//
// Параметры:
//  ТелоМД			 - Строка	 - Строка с CDA-документом.
//  ИсходноеПИ		 - Строк	 - адрес пространства имен, который нужно заменить на f88.
//  НаименованиеПИ	 - Строка	 - наименование пространства имен, который нужно заменить на f88.
// 
// Возвращаемое значение:
//  Строка - строка с CDA-документом, в котором выполнена замена ПИ на f88.
//
Функция ВыполнитьЗаменуПространстваИменНаF88(ТелоМД, URIПИ = "urn:hl7-ru:identity", НаименованиеПИ = "identity") Экспорт
	Результат_ = ВыполнитьЗаменуПространстваИмен(ТелоМД, URIПИ, НаименованиеПИ, "urn:f88", "f88");
	Результат_ = СтрЗаменить(Результат_, "xmlns:" + НаименованиеПИ + "=""" + URIПИ + """", "xmlns:" + НаименованиеПИ + "=""" + URIПИ + """ xmlns:f88=""urn:f88""");	
	Возврат Результат_;
КонецФункции

Функция ВыполнитьЗаменуПространстваИмен(ТелоМД, ИсходныйURIПИ, ИсходноеНаименованиеПИ, РезультирующийURIПИ, РезультирующееНаименованиеПИ)
	Элементы_ = АлгоритмыДляКоллекций.СоздатьМассив("IdentityDoc", "AuthorityDoc", "Ogrn");
	Результат_ = ТелоМД;
	Для Каждого  Элемент_ Из Элементы_ Цикл
		Результат_ = СтрЗаменить(
			Результат_, 
			"" + Элемент_ + " xmlns="""  + ИсходныйURIПИ + """", 
			"" + Элемент_ + " xmlns=""" + РезультирующийURIПИ + """"
		);
		Результат_ = СтрЗаменить(
			Результат_, 
			"" + Элемент_ + " xmlns="""  + ИсходныйURIПИ + """", 
			"" + Элемент_ + " xmlns='" + РезультирующийURIПИ + "'"
		);
		Результат_ = СтрЗаменить(
			Результат_, 
			"<"  + ИсходноеНаименованиеПИ + ":" + Элемент_,
			"<" + РезультирующееНаименованиеПИ + ":" + Элемент_
		);
		Результат_ = СтрЗаменить(
			Результат_, 
			"</"  + ИсходноеНаименованиеПИ + ":" + Элемент_,
			"</" + РезультирующееНаименованиеПИ + ":" + Элемент_
		);
	КонецЦикла;
	Возврат Результат_;
КонецФункции

// Функция - Получить параметры отметки ЭПИз cades
//
// Параметры:
//  Подпись					 - Структура	 - структура с данными подписи.
//  ИдентификаторДокумента	 - ДокументСсылка.МедицинскийДокумент	 - ссылка на подписанный медицинский документ.
// 
// Возвращаемое значение:
//  Структура - структура с параметрами подписи для отображения отметки ЭП.
//
Функция ПолучитьПараметрыОтметкиЭПИзCades(Подпись, ИдентификаторДокумента) 
	Параметры_ = Новый Структура;
	
	СертификатПодписи_ = Подпись.Сертификат.Получить();
	Если СертификатПодписи_ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	СертификатКриптографии_ = Новый СертификатКриптографии(СертификатПодписи_);
	
	СвойстваСубъекта_ = ЭлектроннаяПодпись.СвойстваСубъектаСертификата(СертификатКриптографии_);
	
	ВладелецСертификата_ = ""
		+ СвойстваСубъекта_.Фамилия + " "
		+ СвойстваСубъекта_.Имя + " "
		+ СвойстваСубъекта_.Отчество
	;
	Если ЗначениеЗаполнено(СвойстваСубъекта_.Должность) Тогда
		ВладелецСертификата_ = ВладелецСертификата_ + ", " + СвойстваСубъекта_.Должность;
	КонецЕсли;
	
	СвойстваСертификата_ = ЭлектроннаяПодпись.СвойстваСертификата(СертификатКриптографии_);
	ПериодДействия_ = СтрШаблон(
		НСтр("ru = 'с %1 по %2'"),
		Формат(СвойстваСертификата_.ДатаНачала,    "ДЛФ=DT"),
		Формат(СвойстваСертификата_.ДатаОкончания, "ДЛФ=DT")
	);
	
	Организация_ = ВизуализаторПереопределяемый.ПолучитьОрганизациюДокумента(ИдентификаторДокумента);
	НаименованиеОрганизации_ = "";
	
	Если ЗначениеЗаполнено(Организация_) Тогда
		НаименованиеОрганизации_ = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация_, "Наименование");
	КонецЕсли;

	Параметры_ = Новый Структура;
	Параметры_.Вставить("ДатаПодписи", Подпись.ДатаПодписи);
	Параметры_.Вставить("ВладелецСертификата", ВладелецСертификата_);
	Параметры_.Вставить("Организация", НаименованиеОрганизации_);
	Параметры_.Вставить("НомерСертификата", СертификатКриптографии_.СерийныйНомер); 
	Параметры_.Вставить("СрокДействия", ПериодДействия_);
	
	Возврат Параметры_;
КонецФункции

// Выполняет запрос XPath
//
// Параметры:
//   ЭлементDOM - ЭлементDOM - элемент, относительно контекста которого выполняется запрос
//   Запрос    - Строка - представление выражения XPath
//   ТипРезультата    - ТипРезультатаDOMXPath  - тип результата запроса
//   РазыменовательПИ    - РазыменовательПространствИменDOM  - разыименователь пространства имен
//   Префикс    - Строка  - префикс пространства имен
//
// Возврат:
//   Строка, Число, ЭлементDOM, РезультатXPath - результат выполнения запроса в зависимости от указанного типа результата.
//
Функция ВыполнитьЗапросXPath(ЭлементDOM, Запрос, ТипРезультата, РазыменовательПИ = Неопределено, Префикс = "h") 
	Если РазыменовательПИ = Неопределено Тогда
		Префикс = "h";
		СоответствиеПространств_ = Новый Соответствие;
		СоответствиеПространств_.Вставить(Префикс, ЭлементDOM.URIПространстваИмен);
		РазыменовательПИ = Новый РазыменовательПространствИменDOM(СоответствиеПространств_);
	КонецЕсли;
	ДокументDOM_ = ЭлементDOM.ДокументВладелец;
	Запрос_ = ДокументDOM_.ВычислитьВыражениеXPath(
		Запрос, 
		ЭлементDOM, 
		РазыменовательПИ, 
		ТипРезультата
	);	
	Если ТипРезультата = ТипРезультатаDOMXPath.Строка Тогда
		Результат_ = Запрос_.ПолучитьСледующий();
		Если Результат_ = Неопределено Тогда 
			Возврат Неопределено;
		ИначеЕсли ТипЗнч(Результат_) = Тип("АтрибутDOM") Тогда
			Возврат Результат_.ЗначениеУзла;
		ИначеЕсли ТипЗнч(Результат_) = Тип("ЭлементDOM") Тогда
			Возврат Результат_.ТекстовоеСодержимое; 
		КонецЕсли;
	ИначеЕсли ТипРезультата = ТипРезультатаDOMXPath.Число Тогда
		Если Запрос_ = Неопределено Тогда 
			Возврат Неопределено;
		КонецЕсли;
		Возврат Запрос_.ЧисловоеЗначение;
	ИначеЕсли ТипРезультата = ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел Тогда
		Возврат Запрос_.ПолучитьСледующий();
	КонецЕсли;
	Возврат Запрос_;
КонецФункции

////
 // Функция: ПолучитьОбъектПоНавигационнойСсылке
 //     Вовращает ссылку объекта справочника по навигационной ссылке,
 //   полученной функцией ПолучитьНавигационнуюСсылку.
 //
 // Параметры:
 //   НавигационнаяСсылка (Строка)
 //     Текст навигационной ссылки.
 //
 // Возврат: (СправочникСсылка.<ИмяСправочника>)
 //   Ссылка на объект справочника.
 ///
Функция ПолучитьОбъектПоНавигационнойСсылке(Знач НавигационнаяСсылка)
	// удаляем кавычки из навигационной ссылки, чтобы не мешали 
	НавигационнаяСсылка = СтрЗаменить(НавигационнаяСсылка, """", "");
	
	МассивПодстрок = СтрРазделить(НавигационнаяСсылка, ".", Ложь);
	Если Найти(МассивПодстрок[0], "Справочник") > 0 Тогда
		МассивПодстрок2 = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
			МассивПодстрок[МассивПодстрок.ВГраница()], "?ref="
		);
		ИдО = МассивПодстрок2[МассивПодстрок2.ВГраница()];
		УиДО = УИДИзФорматаНавигационнойСсылки(ИдО);
		Если МассивПодстрок2.Количество() = 1 Или СтрДлина(ИдО) <> 32 Или УиДО = Неопределено Тогда
		
			Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
				МодульСообщенияПользователю_ = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
				Текст_ = МодульСообщенияПользователю_.Получить("ШаблоныМедицинскихДокументов_НеУдалосьПолучитьСсылкуНаОбъектИзНавигационнойСсылки");
			Иначе
				Текст_ = "Не удалось из навигационной ссылки получит ссылку на объект.";
			КонецЕсли;

			ВызватьИсключение Текст_;
		КонецЕсли;
		
		
		Если МассивПодстрок.Количество() = 3 Тогда
			Возврат Справочники[МассивПодстрок[1]].ПолучитьСсылку(УиДО)[МассивПодстрок2[0]];
		ИначеЕсли МассивПодстрок.Количество() = 2 Тогда
			Возврат Справочники[МассивПодстрок2[0]].ПолучитьСсылку(УиДО);
		Иначе
		
			Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
				МодульСообщенияПользователю_ = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
				Текст_ = МодульСообщенияПользователю_.Получить("ШаблоныМедицинскихДокументов_НеправильныйВидНавигационнойСсылки");
			Иначе
				Текст_ = "Неправильный вид навигационной ссылки";
			КонецЕсли;

			ВызватьИсключение Текст_;

		КонецЕсли;
	ИначеЕсли Найти(МассивПодстрок[0], "РегистрСведений") > 0 
			И (МассивПодстрок[1]="ХранимыеФайлыВерсий" ИЛИ МассивПодстрок[1]="ДвоичныеДанныеФайлов") 
	Тогда
		МассивПодстрок2 = СтрРазделить(МассивПодстрок[МассивПодстрок.ВГраница()], "=", Ложь);
		ИдО = МассивПодстрок2[МассивПодстрок2.ВГраница()];
		УиДО = УИДИзФорматаНавигационнойСсылки(ИдО);
		Если МассивПодстрок2.Количество() = 1 Или СтрДлина(ИдО) <> 32 Или УиДО = Неопределено Тогда
			Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
				МодульСообщенияПользователю_ = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
				Текст_ = МодульСообщенияПользователю_.Получить("ШаблоныМедицинскихДокументов_НеУдалосьПолучитьСсылкуНаОбъектИзНавигационнойСсылки");
			Иначе
				Текст_ = "Не удалось из навигационной ссылки получит ссылку на объект.";
			КонецЕсли;

			ВызватьИсключение Текст_;
		КонецЕсли;
 
		СсылкаНаВерсиюФайла = Справочники["ВерсииФайлов"].ПолучитьСсылку(УиДО); 
		
		МенеджерЗаписи = РегистрыСведений["ДвоичныеДанныеФайлов"].СоздатьМенеджерЗаписи();
		МенеджерЗаписи.Файл = СсылкаНаВерсиюФайла;
		МенеджерЗаписи.Прочитать();
		Возврат МенеджерЗаписи.ДвоичныеДанныеФайла;
	КонецЕсли;
КонецФункции

////
 // Функция: ПолучитьУникальныйИдентификатор
 //     Получает уникальный идентификатор объекта, на который есть
 //   текстовая навигационная ссылка. Передается УИД длины 32 символа.
 //
 // Параметры:
 //   ИдО (Строка)
 //     Строка уникального идентификатора, получаемого функцией ПолучитьНавигационнуюСсылку.
 //
 // Возврат: (УникальныйИдентификатор)
 //   Идентификатор, полученный из этой ссылки.
 ///
Функция УИДИзФорматаНавигационнойСсылки(ИдО)
	// Преобразование идентификатора к виду XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	Если СтрДлина(ИдО) <> 32 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Новый УникальныйИдентификатор(
			Сред(ИдО, 25, 4) + Сред(ИдО, 29, 4) + "-" +
			Сред(ИдО, 21, 4) + "-" +
			Сред(ИдО, 17, 4) + "-" +
			Сред(ИдО, 1, 4) + "-" +
			Сред(ИдО, 5, 4) + Сред(ИдО, 9, 4) + Сред(ИдО, 13, 4)
	);
КонецФункции

// Заполняет области из CDA с помощью методов текущего модуля
//
// Параметры:
//  ИмяОбласти		 - Строка - Имя заполняемой области
//  ОбластьМакета	 - ТабличныйДокумент - Заполняемая область
//  Документ		 - ОбъектXDTO - CDA-документ
//  Параметры		 - Структура - Параметры
// 
// Возвращаемое значение:
//  Табличный документ - Заполненная область
Функция ЗаполнитьОбластьИзCDA(ИмяОбласти, ОбластьМакета, Документ, Параметры) 
	Результат_ = Неопределено;
	Если ИмяОбласти = "Шапка" Тогда
		Результат_ = ШапкаИзCDA(ОбластьМакета, Документ, Параметры);
	ИначеЕсли ИмяОбласти = "Заголовок" Тогда
		Результат_ = ЗаголовокИзCDA(ОбластьМакета, Документ, Параметры);
	ИначеЕсли ИмяОбласти = "Подвал" Тогда
		Результат_ = ПодвалИзCDA(ОбластьМакета, Документ, Параметры);
	ИначеЕсли ИмяОбласти = "ЭлектроннаяПодпись" Тогда
		Результат_ = ЭлектроннаяПодписьИзCDA(ОбластьМакета, Документ, Параметры);
	ИначеЕсли ИмяОбласти = "ДокументНеГотов" Тогда
		Результат_ = ДокументНеГотовИзCDA(ОбластьМакета, Документ, Параметры);
	КонецЕсли;

	Возврат Результат_;
КонецФункции

// Функция - Получить табличный документ из кеша
//
// Параметры:
//  СсылкаМД					 - ДокументСсылка.МедицинскийДокумент	 - ссылка на медицинский документ.
//  ФайлCDA						 - СправочникСсылка.Файлы	 - ссылка на файл CDA.
//  ИмпортируемыйВизуализатор	 - СправочникСсылка.Визуализатор - ссылка на визуализатор, которым должнен быть отображен документ.
//  ТелоДокумента				 - Строка	 - строка, содержащая тело документа.
//  ПолныйДокумент	 - 	Булево - признак отображения полного или усеченного документа.
//  ВыводитьШапку	 - 	Булево - признак отображения шапки документ.
//  OutМакет		 - ТабличныйДокумент	 - Макет визуализатора (выходной параметр)
// 
// Возвращаемое значение:
//  ТабличныйДокумент - полученный из кеша табличный документ, соответствующий заданным параметрам, 
//  Неопределено - для случаев, когда документ отсутствует в кеше.
//
Функция ПолучитьТабличныйДокументИзКеша(СсылкаМД, ФайлCDA, ИмпортируемыйВизуализатор, ТелоДокумента, ПолныйДокумент, ВыводитьШапку, OutМакет) Экспорт
	Результат_ = Неопределено;
	Если ИмпортируемыйВизуализатор = Неопределено И ЗначениеЗаполнено(СсылкаМД) Тогда
		ВизуализаторыДляМД_ = Справочники["ВизуализаторыМедицинскихДокументов"].ВизуализаторыДляШМД(Неопределено, СсылкаМД);
		Если ВизуализаторыДляМД_.Количество() = 0 Тогда
			ИмпортируемыйВизуализатор = Справочники["ВизуализаторыМедицинскихДокументов"].ТабличныйВизуализатор;
		Иначе
		    ИмпортируемыйВизуализатор = ВизуализаторыДляМД_[0];
		КонецЕсли;
		
		Если Справочники["ВизуализаторыМедицинскихДокументов"].ПолучитьТипВизуализатора(ИмпортируемыйВизуализатор) <> "epf" Тогда
			ИмпортируемыйВизуализатор = Справочники["ВизуализаторыМедицинскихДокументов"].ТабличныйВизуализатор;
		КонецЕсли;
	КонецЕсли;
	OutМакет = КешСеанса.ПолучитьЗначение("Справочники.ВизуализаторыМедицинскихДокументов.ВизуализаторМакет", ИмпортируемыйВизуализатор);
	
	Если ТелоДокумента = Неопределено И ЗначениеЗаполнено(СсылкаМД) И НЕ ЗначениеЗаполнено(ФайлCDA) Тогда
		Если Метаданные.ОбщиеМодули.Найти("ПодсистемаМедицинаПоликлиника") <> Неопределено Тогда
			ФайлCDA = Документы["МедицинскийДокумент"].ПолучитьCDAДокумент(СсылкаМД);
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ФайлCDA) И ЗначениеЗаполнено(ИмпортируемыйВизуализатор) Тогда
		Результат_ = ПолучитьТабличныйДокументИзКешаПоПараметрам(ФайлCDA, ИмпортируемыйВизуализатор, ПолныйДокумент, ВыводитьШапку);
	КонецЕсли;
	
	Возврат Результат_;
КонецФункции

Функция ПолучитьТабличныйДокументИзКешаПоПараметрам(ФайлCDA, Визуализатор, ПолныйДокумент, ВыводитьШапку) 
	Запрос_ = Новый Запрос;
	Запрос_.Текст = 
		"ВЫБРАТЬ
		|	ТабличныеДокументыCDA.ТабличныйДокумент КАК ТабличныйДокумент
		|ИЗ
		|	РегистрСведений.ТабличныеДокументыCDA КАК ТабличныеДокументыCDA
		|ГДЕ
		|	ТабличныеДокументыCDA.ТелоМедДокумента = &ТелоМедДокумента
		|	И ТабличныеДокументыCDA.Визуализатор = &Визуализатор
		|	И ТабличныеДокументыCDA.ПолныйДокумент = &ПолныйДокумент
		|	И ТабличныеДокументыCDA.ВыводитьШапку = &ВыводитьШапку";
	Запрос_.УстановитьПараметр("ТелоМедДокумента", ФайлCDA);
	Запрос_.УстановитьПараметр("Визуализатор", Визуализатор);
	Запрос_.УстановитьПараметр("ПолныйДокумент", ПолныйДокумент);
	Запрос_.УстановитьПараметр("ВыводитьШапку", ВыводитьШапку);
	РезультатЗапроса_ = Запрос_.Выполнить().Выгрузить();
	Если РезультатЗапроса_.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;	
	ТабДокФайл_ = РезультатЗапроса_[0].ТабличныйДокумент;
	Возврат ПрочитатьТабличныйДокументИзКеша(ТабДокФайл_);
КонецФункции

// Функция - Получить табличный документ из кеша
//
// Параметры:
//  ТабличныйДокументФайл	 - СправочникСсылка.МедицинскийДокументПрисоединенныеФайлы	 - ссылка на файл, содержащий mxl представление мед. документа.
// 
// Возвращаемое значение:
// ТабличныйДокумент	  -  табличный документ для мед. документа.
//
Функция ПрочитатьТабличныйДокументИзКеша(ТабличныйДокументФайл) Экспорт
	// Если нет подсистемы работы с файлами, то отсутствует кеширование табличных документов.
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		Возврат Неопределено;
	КонецЕсли;
	МодульРаботаСФайламиСлужебныйВызовСервера_ = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиСлужебныйВызовСервера");
	ДД_ = МодульРаботаСФайламиСлужебныйВызовСервера_.ДанныеФайлаИДвоичныеДанные(ТабличныйДокументФайл).ДвоичныеДанные;
	Поток_ = ДД_.ОткрытьПотокДляЧтения();
	ТабДок_ = Новый ТабличныйДокумент;
	ТабДок_.Прочитать(Поток_);
	Возврат ТабДок_;
КонецФункции

// Процедура - Записать табличный документ в кеш
//
// Параметры:
//  СсылкаМД		 - 	ДокументСсылка.МедицинскийДокумент - ссылка на медицинский документ.
//  ФайлCDA			 - 	СправочникСсылка.Файлы - ссылка на файл с CDA-документом.
//  Визуализатор	 - 	СправочникСсылка.Визуализатор - ссылка на визуализатор, которым должнен быть отображен документ.
//  ТабДок			 - 	ТабличныйДокумент - сформированный визуализатором табличный документ.
//  ПолныйДокумент	 - 	Булево - признак отображения полного или усеченного документа.
//  ВыводитьШапку	 - 	Булево - признак отображения шапки документ.
//
Процедура ЗаписатьТабличныйДокументВКеш(СсылкаМД, ФайлCDA, ИмпортируемыйВизуализатор, СтандартныйВизуализатор, ТабДок, ПолныйДокумент, ВыводитьШапку)
	УстановитьПривилегированныйРежим(Истина);
	// Если нет подсистемы работы с файлами, то запись в кеш не выполняется.
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаСФайлами") Тогда
		Возврат;
	КонецЕсли;
	ИспользуетсяСправочникМедицинскийДокументПрисоединенныеФайлы_ = Метаданные.Справочники.Найти("МедицинскийДокументПрисоединенныеФайлы") <> Неопределено;
	Если Не ИспользуетсяСправочникМедицинскийДокументПрисоединенныеФайлы_ Тогда
		Возврат;
	КонецЕсли;
		
	Если Не ЗначениеЗаполнено(СсылкаМД) ИЛИ Не ЗначениеЗаполнено(ФайлCDA) Тогда
		Возврат;
	КонецЕсли;
	Визуализатор_ = ВыбратьЗаполненное(ИмпортируемыйВизуализатор, СтандартныйВизуализатор);
	Если Не ЗначениеЗаполнено(Визуализатор_) Тогда
		Возврат;
	КонецЕсли;
	Поток_ = Новый ПотокВПамяти();
	ТабДок.Записать(Поток_, ТипФайлаТабличногоДокумента.MXL);
	ДД_ = Поток_.ЗакрытьИПолучитьДвоичныеДанные();
	Дополнение_ = "";
	Если ПолныйДокумент Тогда
		Дополнение_ = Дополнение_ + " полный";
	Иначе
		Дополнение_ = Дополнение_ + " усеченный";
	КонецЕсли;	
	Если ВыводитьШапку Тогда
		Дополнение_ = Дополнение_ + " с шапкой";
	Иначе
		Дополнение_ = Дополнение_ + " без шапки";
	КонецЕсли;
	
	РеквизитыФайла_ = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ФайлCDA, "Наименование,ВладелецФайла");
	МодульРаботаСФайламиКлиентСервер_ = ОбщегоНазначения.ОбщийМодуль("РаботаСФайламиКлиентСервер");
	СведенияОФайле_ = МодульРаботаСФайламиКлиентСервер_.СведенияОФайле("Файл");
	СведенияОФайле_.Вставить("ВладелецФайлов", СсылкаМД);
	СведенияОФайле_.Вставить("ИмяБезРасширения", РеквизитыФайла_.Наименование + Дополнение_);
	СведенияОФайле_.Вставить("РасширениеБезТочки", "mxl");
	СведенияОФайле_.Вставить("ВремяИзмененияУниверсальное", ТекущаяДатаСеанса());
	МодульРаботаСФайлами_ = ОбщегоНазначения.ОбщийМодуль("РаботаСФайлами");
	ФайлСсылка_ =  МодульРаботаСФайлами_.ДобавитьФайл(
		СведенияОФайле_, 
		ПоместитьВоВременноеХранилище(ДД_),,,
		Справочники["МедицинскийДокументПрисоединенныеФайлы"].ПолучитьСсылку()
	);		
	МенеджерЗаписи_ = РегистрыСведений["ТабличныеДокументыCDA"].СоздатьМенеджерЗаписи();
	МенеджерЗаписи_.ТелоМедДокумента = ФайлCDA;
	МенеджерЗаписи_.Визуализатор = Визуализатор_;
	МенеджерЗаписи_.ДатаФормирования = ТекущаяДатаСеанса();
	МенеджерЗаписи_.ТабличныйДокумент = ФайлСсылка_;
	МенеджерЗаписи_.ПолныйДокумент = ПолныйДокумент;
	МенеджерЗаписи_.ВыводитьШапку = ВыводитьШапку;
	МенеджерЗаписи_.Записать();
КонецПроцедуры

#КонецОбласти