#Область Защищенный_интерфейс

/// Получение структуры кешируемых значений.
//
// Возвращаемое значение:
//   Ответ - Структура -
//     Пустая структура.
///
Функция ПолучитьСтруктуруКешируемыхЗначений() Экспорт
	
	Возврат Новый Структура;
	
КонецФункции

Функция ПространстваИменВызовВрачаНаДом() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("hc", "http://www.rt-eu.ru/med/hc/");
	СтруктураПИ_.Вставить("er", "http://www.rt-eu.ru/med/er/");
	
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменГИП() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	//СтруктураПИ_.Вставить("ns4","urn:hl7-org:v3 ../../../../../../iemk-integration/iemk-integration-ws-api/src/main/resources/integration/schema/HL7V3/NE2008/multicacheschemas/PRPA_IN201301RU01.xsd");
	//СтруктураПИ_.Вставить("ns3","urn:ihe:iti:pixv3:2007");
	СтруктураПИ_.Вставить("ns1", "urn:hl7-org:v3");
	СтруктураПИ_.Вставить("ns_egisz", "http://egisz.rosminzdrav.ru");
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменДиспансеризация() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("ns5", "http://rosminzdrav.ru/fer/concentrator/updateBookingDetails");
	СтруктураПИ_.Вставить("ns4", "http://rosminzdrav.ru/fer/concentrator/dispensary/callback");
	СтруктураПИ_.Вставить("ns3", "http://rosminzdrav.ru/fer/concentrator/dispensary");
	СтруктураПИ_.Вставить("ns2", "http://rosminzdrav.ru/fer/concentrator/dispensary/commons");
	СтруктураПИ_.Вставить("ns1", "http://rosminzdrav.ru/fer/concentrator/booking/commons");
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменЗаписьНаПрием() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("er", "http://www.rt-eu.ru/med/er/");
	СтруктураПИ_.Вставить("er2", "http://www.rt-eu.ru/med/er/v2_0");
	
	Возврат СтруктураПИ_;
	
КонецФункции

// Пространства имен РЭМД.
Функция ПространстваИменРЭМД() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("ns2", "http://egisz.rosminzdrav.ru/iehr/emdr/service/");
	СтруктураПИ_.Вставить("ns3", "http://egisz.rosminzdrav.ru/iehr/emdr/callback/");
	// Обход ошибки платформы, если префикс в читаемой xml будет занят другим URI, то
	// выполняемый xpath с этим префиксом вернет пустое значение. Желательно использовать
	// оригинальные префиксы.
	СтруктураПИ_.Вставить("emdrns1", "http://egisz.rosminzdrav.ru");
	СтруктураПИ_.Вставить("emdrns2", "http://egisz.rosminzdrav.ru/iehr/emdr/service/");
	СтруктураПИ_.Вставить("emdrns3", "http://egisz.rosminzdrav.ru/iehr/emdr/callback/");
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменИЭМК() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("iemkns1", "urn:hl7-org:v3");
	СтруктураПИ_.Вставить("iemkns2", "urn:oasis:names:tc:ebxml-regrep:xsd:rs:3.0");
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменПрикреплениеОнлайн() Экспорт
	
	СтруктураПИ_ = Новый Структура;
	СтруктураПИ_.Вставить("ns1", "http://egisz.rosminzdrav.ru");
	Возврат СтруктураПИ_;
	
КонецФункции

Функция ПространстваИменСервисИдентификации()
	
	СоответствиеПИ_ = Новый Соответствие;
	СоответствиеПИ_.Вставить("SOAP-ENV", xmlns.soap());
	СоответствиеПИ_.Вставить("wsu", xmlns.wsu());
	СоответствиеПИ_.Вставить("wsa", xmlns.wsa());
	СоответствиеПИ_.Вставить("egisz", xmlns.egisz());
	
	Возврат СоответствиеПИ_;
	
КонецФункции

Функция РазыменовательПИВызовВрачаНаДом() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменВызовВрачаНаДом());
	
КонецФункции

Функция РазыменовательПИГИП() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменГИП());
	
КонецФункции

Функция РазыменовательПИДиспансеризация() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменДиспансеризация());
	
КонецФункции

Функция РазыменовательПИЗаписьНаПрием() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменЗаписьНаПрием());
	
КонецФункции

// Разыменователь пространства имен РЭМД.
Функция РазыменовательПИРЭМД() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменРЭМД());
	
КонецФункции

Функция РазыменовательПИSOAP(URIПространстваИменSOAP) Экспорт
	
	СоответствиеПИ_ = Новый Соответствие;
	Если ЗначениеЗаполнено(URIПространстваИменSOAP) Тогда
		СоответствиеПИ_.Вставить("soap", URIПространстваИменSOAP);
	Иначе 
		СоответствиеПИ_.Вставить("soap", xmlns.soap());
	КонецЕсли;
	СоответствиеПИ_.Вставить("wsa", xmlns.wsa());
	СоответствиеПИ_.Вставить("wsse", xmlns.wsse());
	СоответствиеПИ_.Вставить("wsu", xmlns.wsu());
	
	Возврат Новый РазыменовательПространствИменDOM(СоответствиеПИ_);
	
КонецФункции

Функция РазыменовательПИИЭМК() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменИЭМК());
	
КонецФункции

// Разыменователь пространства имен сервиса идентификации.
Функция РазыменовательПИСервисИдентификации() Экспорт
	
	Возврат СоздатьРазыменовательПИПоСтруктуре(ПространстваИменСервисИдентификации());
	
КонецФункции

Функция ПолучитьЧасовойПоясСтрокой() Экспорт
	
	// Сначала получим универсальную дату для того, чтобы при нахождении в одном часовом поясе
	// текущая дата оказалась не меньше, чем универсальная дата.
	УниверсальнаяДата_ = ТекущаяУниверсальнаяДата();
	// Получим текущую локальную дату
	ТекущаяДата_ = ТекущаяДата();
	// и разность между локальной и универсальной датой в секундах.
	СмещениеВСекундах_ = ТекущаяДата_ - УниверсальнаяДата_;
	
	// Следующая константа нам пригодится.
	ОднаМинута_ = 60;
	
	// Определим знак часового пояса, если разность отрицательна, то знак минус, иначе плюс.
	Знак_ = "+";
	Если СмещениеВСекундах_ < 0 Тогда
		Знак_ = "-";
		СмещениеВСекундах_ = -СмещениеВСекундах_ - ОднаМинута_;
	КонецЕсли;
	
	// Универсальная дата и локальная дата могли быть получены не в одну и ту же секунду,
	// поэтому нам нужно округлить смещение до какого-нибудь подходящего значения,
	// например, до одной минуты.
	СмещениеВСекундах_ = ОднаМинута_ * Цел(СмещениеВСекундах_ / ОднаМинута_);
	
	// Преобразуем смещение в дату.
	Смещение_ = МагическиеКонстанты.ПустаяДата() + СмещениеВСекундах_;
	
	// Теперь мы готовы сформировать представление смещения часового пояса.
	ЧасовойПояс_ = СтрШаблон(
		"%1%2",
		Знак_,
		Формат(Смещение_, "ДФ=HH:mm; ДП=")
	);
	
	Возврат ЧасовойПояс_;
	
	
КонецФункции

Функция ПолучитьМакетОписанияWSDL(ВнутреннееИмя, ПроверятьНаличиеПараметра = Истина) Экспорт
	
	// По внутреннему имени найдем общий макет описания WSDL и загрузим его.
	ИмяМакета_ = СтрШаблон("ФедеральныеВебСервисы%1ОписаниеWSDL", ВнутреннееИмя);
	ОписаниеWSDL_ = ПолучитьОбщийМакет(ИмяМакета_).ПолучитьТекст();
	
	// В описании WSDL есть один параметр, который нужно заменить на URL веб-сервиса.
	Если Истина = ПроверятьНаличиеПараметра И 0 = СтрНайти(ОписаниеWSDL_, "%1") Тогда
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			СтрШаблон("В макете %1 нет параметра.", ИмяМакета_)
		);
	КонецЕсли;
	
	Возврат ОписаниеWSDL_;
	
КонецФункции

Функция ПолучитьНаборСхемXML(ПространстваИменЧерезСимволПС) Экспорт
	
	МассивПространствИмен_ = СтрРазделить(ПространстваИменЧерезСимволПС, Символы.ПС, Ложь);
	НаборСхем_ = Новый НаборСхемXML;
	
	// Не используем цикл Для, поскольку размер массива может измениться из-за директив
	// <xs:import> в схемах.
	Индекс_ = 0;
	Пока Индекс_ < МассивПространствИмен_.Количество() Цикл
		ФедеральныеВебСервисыСервер.ДобавитьВНаборСхем(НаборСхем_, МассивПространствИмен_, Индекс_);
		Индекс_ = Индекс_ + 1;
	КонецЦикла;
	
	Возврат НаборСхем_;
	
КонецФункции

Функция ПолучитьТекстФайлаСоСхемой(ПространствоИмен) Экспорт
	
	Если Ложь
		Или ПространствоИмен = ПространстваИменВызовВрачаНаДом().hc
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ВызовВрачаНаДом", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменДиспансеризация().ns4
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ДиспансеризацияCallback", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменДиспансеризация().ns5
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ДиспансеризацияUpdate", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменДиспансеризация().ns3
		Или ПространствоИмен = ПространстваИменДиспансеризация().ns2
		Или ПространствоИмен = ПространстваИменДиспансеризация().ns1
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("Диспансеризация", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменЗаписьНаПрием().er
	Тогда
		МассивСтрокXMLСоСхемами_ = Новый Массив;
		МассивСтрокXMLСоСхемами_.Добавить(ПолучитьМакетОписанияWSDL("ЗаписьНаПрием", Ложь));
		МассивСтрокXMLСоСхемами_.Добавить(ПолучитьМакетОписанияWSDL("ЗаписьНаПриемUpdate", Ложь));
		МассивСтрокXMLСоСхемами_.Добавить(ПолучитьМакетОписанияWSDL("ВызовВрачаНаДомUpdate", Ложь));
		ОписаниеWSDL_ = СформироватьЕдинуюСхему(МассивСтрокXMLСоСхемами_, ПространствоИмен);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменЗаписьНаПрием().er2
	Тогда 
		МассивСтрокXMLСоСхемами_ = Новый Массив;
		МассивСтрокXMLСоСхемами_.Добавить(ПолучитьМакетОписанияWSDL("ЗаписьНаПрием2", Ложь));
		МассивСтрокXMLСоСхемами_.Добавить(ПолучитьМакетОписанияWSDL("ЗаписьНаПриемUpdate2", Ложь));
		ОписаниеWSDL_ = СформироватьЕдинуюСхему(МассивСтрокXMLСоСхемами_, ПространствоИмен);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменРЭМД().ns3
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("РЭМД", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменРЭМД().ns2
		Или ПространствоИмен = xmlns.wsu()
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("РЭМДService", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = ПространстваИменПрикреплениеОнлайн().ns1
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ПрикреплениеОнлайн", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = "urn:hl7-org:v3"
	Тогда
		ОписаниеWSDL_ = ПолучитьXMLСхемуHL7v3()
		
	ИначеЕсли Ложь
		Или ПространствоИмен = "http://vimis.rosminzdrav.ru/"
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ВИМИСService", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = "http://callback.mis.vimis.rosminzdrav.ru/"
	Тогда
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ВИМИС", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = "urn:ihe:iti:xds-b:2007"
	Тогда
		
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ИЭМК", Ложь);
		
	ИначеЕсли Ложь
		Или ПространствоИмен = "urn:oasis:names:tc:ebxml-regrep:xsd:rs:3.0"
	Тогда
		
		ОписаниеWSDL_ = ПолучитьМакетОписанияWSDL("ИЭМКCallback", Ложь);
		
	Иначе
		__ПРОВЕРКА__(Ложь, "6a07d7be-550e-11e8-bc8e-080027536468: " + ПространствоИмен);
	КонецЕсли;
	
	Возврат ОписаниеWSDL_;
	
КонецФункции

Функция СоздатьРазыменовательПИПоСтруктуре(СтруктураПИ)
	
	СоответствиеПИ_ = Новый Соответствие;
	
	Для Каждого КлючИЗначение_ Из СтруктураПИ Цикл
		СоответствиеПИ_.Вставить(КлючИЗначение_.Ключ, КлючИЗначение_.Значение);
	КонецЦикла;
	
	Возврат Новый РазыменовательПространствИменDOM(СоответствиеПИ_);
	
КонецФункции

Функция ПолучитьXMLСхемуHL7v3()
	
	// В этот массив будем складывать тексты схем без открывающего и закрывающего тегов
	// <xs:schema> и без тегов <xs:include>.
	МассивВнутренностейСхем_ = Новый Массив;
	
	// Сразу добавим открывающий тег <xs:schema> в массив.
	МассивВнутренностейСхем_.Добавить(
		"<xs:schema xmlns:xs=""http://www.w3.org/2001/XMLSchema"" xmlns:sch=""http://www.ascc.net/xml/schematron"" xmlns=""urn:hl7-org:v3"" elementFormDefault=""qualified"" targetNamespace=""urn:hl7-org:v3"">"
	);
	
	// Пробежимся по всем общим макетам.
	Для Каждого Макет_ Из Метаданные.ОбщиеМакеты Цикл
		
		// Оставим только те макеты, имена которых начинаются на "HL7v3_xsd_".
		Если Не СтрНачинаетсяС(Макет_.Имя, "HL7v3_xsd_") Тогда
			Продолжить;
		КонецЕсли;
		
		// Прочитаем содержимое макета со схемой в переменную ТекстСхемыXML_.
		ТекстСхемыXML_ = ПолучитьОбщийМакет(Макет_.Имя).ПолучитьТекст();
		
		// Найдем вхождение тега <xs:schema>.
		ПозНачала_ = СтрНайти(ТекстСхемыXML_, "<xs:schema ");
		ПозКонца_ = СтрНайти(ТекстСхемыXML_, ">", , ПозНачала_ + 1);
		
		__ПРОВЕРКА__(0 < ПозНачала_ И ПозНачала_ < ПозКонца_, "13b23d7c-ad0c-11e8-9041-080027536468: Изменился формат схем. Надо обновить алгоритм.");
		
		// Возьмем начало документа вплоть до конца открывающего тега <xs:schema>.
		ПодстрокаЗамены_ = Сред(ТекстСхемыXML_, 1, ПозКонца_);
		
		// Удалим открывающий и закрывающий теги <xs:schema>.
		ТекстСхемыXML_ = СтрЗаменить(ТекстСхемыXML_, ПодстрокаЗамены_, "");
		ТекстСхемыXML_ = СтрЗаменить(ТекстСхемыXML_, "</xs:schema>", "");
		
		// Теперь в цикле удалим теги <xs:include>.
		Пока Истина Цикл
			
			// Найдем начало тега <xs:include>.
			ПозНачала_ = СтрНайти(ТекстСхемыXML_, "<xs:include ");
			
			// Если тег не нашелся, заверщим цикл.
			Если 0 = ПозНачала_ Тогда
				Прервать;
			КонецЕсли;
			
			// Найдем окончание тега.
			ПозКонца_ = СтрНайти(ТекстСхемыXML_, ">", , ПозНачала_ + 1);
			
			// Вычленим удаляемый фрагмент
			ПодстрокаЗамены_ = Сред(ТекстСхемыXML_, ПозНачала_, ПозКонца_ - ПозНачала_ + 1);
			// и удалим его.
			ТекстСхемыXML_ = СтрЗаменить(ТекстСхемыXML_, ПодстрокаЗамены_, "");
			
			// Проверим, что в теге подгружается схема, которая есть в макетах.
			
			// Для этого вычленим из атрибута schemaLocation имя файла схемы XML.
			ПозНачала_ = СтрНайти(ПодстрокаЗамены_, "schemaLocation=""");
			ПозКонца_ = СтрНайти(ПодстрокаЗамены_, ".xsd""", , ПозНачала_ + 1);
			ПозСередины_ = СтрНайти(ПодстрокаЗамены_, "/", НаправлениеПоиска.СКонца, ПозКонца_ + 1);
			
			__ПРОВЕРКА__(0 < ПозНачала_ И ПозНачала_ < ПозСередины_ И ПозСередины_ < ПозКонца_, "7a67aebe-ad14-11e8-b27c-080027536468: Не найдено имя файла схемы в подстроке %1.", ПодстрокаЗамены_);
			
			// Собственно, вычленяем имя файла схемы.
			ИмяФайлаСхемы_ = Сред(ПодстрокаЗамены_, ПозСередины_ + 1, ПозКонца_ - ПозСередины_ - 1);
			
			// Из имени файла схемы получим имя общего макета.
			ИмяМакета_ = "HL7v3_xsd_" + СтрЗаменить(ИмяФайлаСхемы_, ".xsd", "");
			ИмяМакета_ = СтрЗаменить(ИмяМакета_, "-", "_");
			
			// Проверим, что такой макет есть среди общих макетов конфигурации.
			__ПРОВЕРКА__(Не Неопределено = Метаданные.ОбщиеМакеты.Найти(ИмяМакета_), "a056ac78-ad10-11e8-8bad-080027536468: Не найдена схема XML %1, на которую ссылается схема из общего макета %1.", ИмяФайлаСхемы_, Макет_.Имя);
			
		КонецЦикла;
		
		// Теперь добавим измененный текст схемы в массив.
		МассивВнутренностейСхем_.Добавить(ТекстСхемыXML_);
		
	КонецЦикла;
	
	// Добавим в массив закрывающий тег </xs:schema>.
	МассивВнутренностейСхем_.Добавить("</xs:schema>");
	
	// Соединим элементы массива в одну строку
	ОбъединеннаяСхемаXML_ = СтрСоединить(МассивВнутренностейСхем_, "");
	
	// и вернем её вызывающей функции.
	Возврат ОбъединеннаяСхемаXML_;
	
КонецФункции

Функция СформироватьЕдинуюСхему(МассивСтрокXMLСоСхемами, URIПространстваИмен)
	
	СтрокаXMLСоСхемами_ = СтрСоединить(МассивСтрокXMLСоСхемами, Символы.ПС);
	
	ПодстрокаПоиска_targetNamespace_ = СтрШаблон(
		"targetNamespace=""%1""",
		URIПространстваИмен
	);
	ПодстрокаПоиска_elementFormDefault_qualified_ = "elementFormDefault=""qualified""";
	ПодстрокаПоиска_schema_ = "schema";
	ДлинаСтроки_schema_ = СтрДлина(ПодстрокаПоиска_schema_);
	
	// Запомним все префиксы пространства имен http://www.w3.org/2001/XMLSchema.
	СоответствиеПрефиксовПИ_ = Новый Соответствие;
	МассивПолезныхАтрибутов_ = Новый Массив;
	МассивВнутренностейСхем_ = Новый Массив;
	
	НедопустимыеСимволыВПрефиксе_ = "<>""" + МагическиеКонстанты.ПробельныеСимволы();
	
	Поз_ = 1;
	
	Пока Истина Цикл
		
		// Найдем атрибут targetNamespace с указанным URI пространства имен.
		Поз_ = СтрНайти(СтрокаXMLСоСхемами_, ПодстрокаПоиска_targetNamespace_, , Поз_);
		
		// Если не нашли больше схему с таким targetNamespace, завершаем цикл.
		Если Поз_ = 0 Тогда
			Прервать;
		КонецЕсли;
		
		// Сразу перейдем к следующей позиции, чтобы можно было закончить цикл в любой момент.
		Поз_ = Поз_ + 1;
		
		// Найдем начало тега <schema>, то есть <xs:schema>.
		//                                      ^
		ПозНачала_ = СтрНайти(СтрокаXMLСоСхемами_, "<", НаправлениеПоиска.СКонца, Поз_);
		
		// У тега schema может не быть префикса пространства имен.
		НетПрефикса_ = (
			Сред(СтрокаXMLСоСхемами_, ПозНачала_ + 1, ДлинаСтроки_schema_) = ПодстрокаПоиска_schema_
		);
		
		Если НетПрефикса_ Тогда
			
			ПрефиксПИ_ = "";
			ЗакрывающийТег_ = "</schema>";
			ПозSchema_ = ПозНачала_ + 1;
			
		Иначе // Префикс есть, найдем его.
			
			// Найдем позицию завершения префикса пространства имен, то есть <xs:schema>.
			//                                                                   ^
			ПозSchema_ = СтрНайти(СтрокаXMLСоСхемами_, ":" + ПодстрокаПоиска_schema_, , ПозНачала_);
			
			// Если это не тег schema, тогда продолжим поиск.
			Если 0 = ПозSchema_ Или Не ПозSchema_ < Поз_ Тогда
				// Это был тег не sсhema.
				Продолжить;
			КонецЕсли;
			
			// Пропустим двоеточие.
			ПозSchema_ = ПозSchema_ + 1;
			
			ПрефиксПИ_ = Сред(СтрокаXMLСоСхемами_, ПозНачала_ + 1, ПозSchema_ - ПозНачала_ - 2);
			
			// Если в префиксе содержатся недопустимые символы, то мы опять ошиблись.
			Если Не 1 = СтрРазделить(ПрефиксПИ_, НедопустимыеСимволыВПрефиксе_).Количество() Тогда
				Продолжить;
			КонецЕсли;
			
			ЗакрывающийТег_ = СтрШаблон("</%1:schema>", ПрефиксПИ_);
			
		КонецЕсли;
		
		СоответствиеПрефиксовПИ_[ПрефиксПИ_] = Истина;
		
		// Найдем позицию конца открывающего тега <schema>, то есть <xs:schema ... >.
		//                                                                         ^
		ПозКонцаОткрывющегоТега_ = СтрНайти(СтрокаXMLСоСхемами_, ">", , Поз_);
		
		// Найдем позицию закрывающего тега.
		ПозЗакрывающегоТега_ = СтрНайти(СтрокаXMLСоСхемами_, ЗакрывающийТег_, , Поз_);
		
		// Выделим внутренность схемы.
		ВнутренностьСхемы_ = Сред(
			СтрокаXMLСоСхемами_,
			ПозКонцаОткрывющегоТега_ + 1,
			ПозЗакрывающегоТега_ - ПозКонцаОткрывющегоТега_ - 1
		);
		
		// Возьмем открывающий тег schema целиком.
		ОткрывающийТегЦеликом_ = Сред(
			СтрокаXMLСоСхемами_,
			ПозНачала_,
			ПозКонцаОткрывющегоТега_ - ПозНачала_ + 1
		);
		
		// Удалим из открывающего тега всё лишнее.
		ПолезныеАтрибутыОткрывающегоТега_ = Сред(
			СтрокаXMLСоСхемами_,
			ПозSchema_ + ДлинаСтроки_schema_,
			ПозКонцаОткрывющегоТега_ - ПозSchema_ - ДлинаСтроки_schema_
		);
		ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
			ПолезныеАтрибутыОткрывающегоТега_, 
			ПодстрокаПоиска_elementFormDefault_qualified_,
			""
		);
		// С атрибутами пока не заморачиваемся.
		ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
			ПолезныеАтрибутыОткрывающегоТега_, 
			"attributeFormDefault=""qualified""",
			""
		);
		ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
			ПолезныеАтрибутыОткрывающегоТега_, 
			ПодстрокаПоиска_targetNamespace_,
			""
		);
		ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
			ПолезныеАтрибутыОткрывающегоТега_, 
			"version=""1.0""",
			""
		);
		Если ЗначениеЗаполнено(ПрефиксПИ_) Тогда
			ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
				ПолезныеАтрибутыОткрывающегоТега_, 
				СтрШаблон("xmlns:%1=""http://www.w3.org/2001/XMLSchema""", ПрефиксПИ_),
				""
			);
		Иначе
			ПолезныеАтрибутыОткрывающегоТега_ = СтрЗаменить(
				ПолезныеАтрибутыОткрывающегоТега_, 
				"xmlns=""http://www.w3.org/2001/XMLSchema""",
				""
			);
		КонецЕсли;
		Если ЗначениеЗаполнено(ПолезныеАтрибутыОткрывающегоТега_) Тогда
			МассивПолезныхАтрибутов_.Добавить(ПолезныеАтрибутыОткрывающегоТега_);
		КонецЕсли;
		
		// Определим, присутствует ли в схеме атрибут elementFormDefault="qualified".
		elementFormDefault_qualified_ =
			Не 0 = СтрНайти(ОткрывающийТегЦеликом_, ПодстрокаПоиска_elementFormDefault_qualified_)
		;
		
		// Если в открывающем теге <xs:schema> присутствует атрибут elementFormDefault="qualified",
		// то элементам внутренностей схемы, не являщихся элементами верхнего уровня,
		// надо добавить атрибут form="qualified".
		Если Истина = elementFormDefault_qualified_ Тогда
			
			НачалоТега_element_ = "<element";
			Если ЗначениеЗаполнено(ПрефиксПИ_) Тогда
				НачалоТега_element_ = СтрШаблон("<%1:element", ПрефиксПИ_);
			КонецЕсли;
			
			ВнутренностьСхемы_ = СтрЗаменить(
				ВнутренностьСхемы_,
				НачалоТега_element_,
				НачалоТега_element_ + " form=""qualified"""
			);
			
		КонецЕсли;
		
		МассивВнутренностейСхем_.Добавить(ВнутренностьСхемы_);
		
	КонецЦикла;
	
	// Обработаем все префиксы пространства имен http://www.w3.org/2001/XMLSchema.
	МассивДекларацийПИ_ = Новый Массив;
	Для Каждого КлючИЗначение_ Из СоответствиеПрефиксовПИ_ Цикл
		ПрефиксПИ_ = КлючИЗначение_.Ключ;
		ДекларацияПИ_ = "xmlns=""http://www.w3.org/2001/XMLSchema""";
		Если ЗначениеЗаполнено(ПрефиксПИ_) Тогда
			ДекларацияПИ_ = СтрШаблон("xmlns:%1=""http://www.w3.org/2001/XMLSchema""", ПрефиксПИ_);
		КонецЕсли;
		МассивДекларацийПИ_.Добавить(ДекларацияПИ_);
	КонецЦикла;
	
	__ПРОВЕРКА__(МассивДекларацийПИ_.Количество() > 0, "959303bc-c855-11e8-a107-47660db8063c");
	
	ИмяТега_schema_ = "schema";
	Если ЗначениеЗаполнено(ПрефиксПИ_) Тогда
		ИмяТега_schema_ = СтрШаблон("%1:schema", ПрефиксПИ_);
	КонецЕсли;
	
	
	
	
	ШаблонСхемы_ =
		"<%1 %2 %3 xmlns:tns=""%4"" targetNamespace=""%4"">
		|%5
		|</%1>"
	;
	СформированнаяСхемаXML_ = СтрШаблон(
		ШаблонСхемы_,
		ИмяТега_schema_,
		СтрСоединить(МассивДекларацийПИ_, " "),
		СтрСоединить(МассивПолезныхАтрибутов_, " "),
		URIПространстваИмен,
		СтрСоединить(МассивВнутренностейСхем_, Символы.ПС)
	);
	
	БылиИзмененияВДОМе_ = Ложь;
	
	// Надо удалить атрибут form у тегов element верхнего уровня.
	DOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(СформированнаяСхемаXML_);
	ПИ_ = Новый РазыменовательПространствИменDOM("xs", xmlns.xs());
	Тип_ = ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов;
	XPath_ = "/xs:schema/xs:element[@form]";
	
	РезультатXPath_ = DOM_.ВычислитьВыражениеXPath(XPath_, DOM_, ПИ_, Тип_);
	
	Пока Истина Цикл
		Узел_ = РезультатXPath_.ПолучитьСледующий();
		Если Неопределено = Узел_ Тогда
			Прервать;
		КонецЕсли;
		Узел_.УдалитьАтрибут("form");
		БылиИзмененияВДОМе_ = Истина;
	КонецЦикла;
	
	// Надо удалить совпадающие типы.
	ИменаТипов_ = Новый Соответствие;
	Индекс_ = DOM_.documentElement.childNodes.Количество();
	Пока Индекс_ > 0 Цикл
		Индекс_ = Индекс_ - 1;
		Узел_ = DOM_.documentElement.childNodes[Индекс_];
		ЭтоТип_ = Истина
			И ТипЗнч(Узел_) = Тип("ЭлементDOM")
			И Узел_.namespaceURI = xmlns.xs()
			И (Узел_.localName = "simpleType" Или Узел_.localName = "complexType")
		;
		Если Не Истина = ЭтоТип_ Тогда
			Продолжить;
		КонецЕсли;
		ЗначениеАтрибута_name_ = Узел_.getAttribute("name");
		Если Истина = ИменаТипов_[ЗначениеАтрибута_name_] Тогда
			Узел_.parentNode.removeChild(Узел_);
			БылиИзмененияВДОМе_ = Истина;
		ИначеЕсли ЗначениеЗаполнено(ЗначениеАтрибута_name_) Тогда
			ИменаТипов_[ЗначениеАтрибута_name_] = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Истина = БылиИзмененияВДОМе_ Тогда
		СформированнаяСхемаXML_ = ФедеральныеВебСервисыСервер.ЗаписатьDOM(DOM_);
	КонецЕсли;
	
	Возврат СформированнаяСхемаXML_;
	
КонецФункции

#КонецОбласти
