////////////////////////////////////////////////////////////////////////////////
// Подсистема "Интеграция с 1С:Документооборотом"
// Модуль ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер: клиент, сервер
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Область ОбщиеПроцедурыИФункции

// Конструктор структуры, описывающей ключевые данные правила интеграции.
//
// Возвращаемое значение:
//  Структура:
//     * Ссылка - СправочникСсылка.ПравилаИнтеграцииС1СДокументооборотом - правило.
//     * ПредставлениеОбъектаДО - Строка - представление объекта ДО.
//     * ПредставлениеОбъектаИС - Строка - представление объекта ИС.
//     * ТипОбъектаДО - Строка - тип объекта ДО.
//     * ТипОбъектаИС - Строка - тип объекта ИС.
//     * ИдентификаторВидаДокумента - Строка - идентификатор вида документа ДО.
//     * ТипВидаДокумента - Строка - тип вида документа ДО.
//
Функция ДанныеПравилаИнтеграции() Экспорт
	
	Результат = Новый Структура;
	
	Результат.Вставить("Ссылка");
	Результат.Вставить("ТипОбъектаИС");
	Результат.Вставить("ТипОбъектаДО");
	Результат.Вставить("ПредставлениеОбъектаИС");
	Результат.Вставить("ПредставлениеОбъектаДО");
	Результат.Вставить("ИдентификаторВидаДокумента");
	Результат.Вставить("ТипВидаДокумента");
	
	Возврат Результат;
	
КонецФункции

// Возвращает структуру данных объекта 1С:Документооборот ссылочного типа.
//
// Параметры:
//   ID - Строка - идентификатор объекта ДО.
//   Тип - Строка - тип объекта XDTO.
//   Наименование - Строка - имя объекта ДО.
//   Представление - Строка - представление объекта ДО.
//
// Возвращаемое значение:
//   Структура - данные владельца подписей:
//     * ID - Строка - идентификатор объекта ДО.
//     * Тип - Строка - тип объекта XDTO.
//     * Наименование - Строка - имя объекта ДО.
//     * Представление - Строка - представление объекта ДО.
//
Функция ДанныеСсылочногоОбъектаДО(ID, Тип, Наименование = "", Представление = "") Экспорт
	
	ДанныеОбъекта = Новый Структура;
	ДанныеОбъекта.Вставить("ID", ID);
	ДанныеОбъекта.Вставить("Тип", Тип);
	ДанныеОбъекта.Вставить("Наименование", Наименование);
	ДанныеОбъекта.Вставить("Представление", Представление);
	
	Возврат ДанныеОбъекта;
	
КонецФункции

// Возвращает структуру данных файла.
//
// Параметры:
//   Наименование - Строка - имя объекта ДО.
//   ID - Строка - идентификатор объекта ДО.
//   Тип - Строка - тип объекта XDTO.
//   Расширение - Строка - расширение файла.
//   РольФайлаID - Строка - роль файла.
//
// Возвращаемое значение:
//   Структура - данные владельца подписей:
//     * Наименование - Строка - имя объекта ДО.
//     * Описание - Строка - описание файла.
//     * ID - Строка - идентификатор объекта ДО.
//     * Тип - Строка - тип объекта XDTO.
//     * Расширение - Строка - расширение файла.
//     * Размер - Число - размер файла.
//     * ДатаМодификации - Дата - дата модификации файла.
//     * ДатаМодификацииУниверсальная - Дата - дата модификации файла универсальная.
//     * ИмяФайла - Строка - имя файла с расширением.
//     * Текст - Строка - текст файла.
//     * РольФайлаID - Строка - роль файла.
//
Функция ДанныеФайла(Наименование, ID, Тип, Расширение = "", РольФайлаID = Неопределено) Экспорт
	
	ДанныеФайла = Новый Структура(
		"Наименование, Описание, ID, Тип, Расширение, Размер,
		|ДатаМодификации, ДатаМодификацииУниверсальная,
		|ИмяФайла, Текст, РольФайлаID");
	ДанныеФайла.Наименование = Наименование;
	ДанныеФайла.ID = ID;
	ДанныеФайла.Тип = Тип;
	ДанныеФайла.РольФайлаID = РольФайлаID;
	ДанныеФайла.Расширение = Расширение;
	
	ДанныеФайла.Описание = "";
	ДанныеФайла.ИмяФайла = ИмяСРасширением(Наименование, Расширение);
	ДанныеФайла.Размер = 0;
	ДанныеФайла.ДатаМодификации = Дата(1,1,1);
	ДанныеФайла.ДатаМодификацииУниверсальная = Дата(1,1,1);
	ДанныеФайла.Текст = "";
	
	Возврат ДанныеФайла;
	
КонецФункции

// Извлечь текст из файла OpenDocument и возвратить его в виде строки.
//
// Параметры:
//   ПутьКФайлу - Строка - Полное имя файла.
//   Отказ - Булево - Отказ.
//
// Возвращаемое значение:
//   Строка - Извлеченный текст.
//
Функция ИзвлечьТекстOpenDocument(ПутьКФайлу, Отказ) Экспорт
	
	ИзвлеченныйТекст = "";
	
#Если Не ВебКлиент И НЕ МобильныйКлиент Тогда
	
	ВременнаяПапкаДляРазархивирования = ПолучитьИмяВременногоФайла("");
	ВременныйZIPФайл = ПолучитьИмяВременногоФайла("zip");
	
	КопироватьФайл(ПутьКФайлу, ВременныйZIPФайл);
	Файл = Новый Файл(ВременныйZIPФайл);
	Файл.УстановитьТолькоЧтение(Ложь);

	Попытка
		Архив = Новый ЧтениеZipФайла();
		Архив.Открыть(ВременныйZIPФайл);
		Архив.ИзвлечьВсе(ВременнаяПапкаДляРазархивирования, РежимВосстановленияПутейФайловZIP.Восстанавливать);
		Архив.Закрыть();
		ЧтениеXML = Новый ЧтениеXML();
		
		ЧтениеXML.ОткрытьФайл(ВременнаяПапкаДляРазархивирования + "/content.xml");
		ИзвлеченныйТекст = ИзвлечьТекстИзContentXML(ЧтениеXML);
		ЧтениеXML.Закрыть();
	Исключение
		// Не считаем ошибкой, т.к. например расширение OTF может быть как OpenDocument, так и шрифт OpenType.
		Архив = Неопределено;
		ЧтениеXML = Неопределено;
		Отказ = Истина;
		ИзвлеченныйТекст = "";
	КонецПопытки;
	
	УдалитьФайлы(ВременнаяПапкаДляРазархивирования);
	УдалитьФайлы(ВременныйZIPФайл);
	
#КонецЕсли
	
	Возврат ИзвлеченныйТекст;
	
КонецФункции

// Извлекает текст в соответствии с кодировкой.
// Если кодировка не задана - сама вычисляет кодировку.
//
// Параметры:
//   ПолноеИмяФайла - Строка - Полное имя файла.
//   Кодировка - Строка - Кодировка.
//   Отказ - Булево - Отказ.
//
// Возвращаемое значение:
//   Строка - Извлеченный текст.
//
Функция ИзвлечьТекстИзТекстовогоФайла(ПолноеИмяФайла, Кодировка, Отказ) Экспорт
	
	ИзвлеченныйТекст = "";
	
#Если Не ВебКлиент Тогда
	
	// Определение кодировки.
	Если Не ЗначениеЗаполнено(Кодировка) Тогда
		Кодировка = Неопределено;
	КонецЕсли;
	
	Попытка
		КодировкаДляЧтения = ?(Кодировка = "utf-8_WithoutBOM", "utf-8", Кодировка);
		ЧтениеТекста = Новый ЧтениеТекста(ПолноеИмяФайла, КодировкаДляЧтения);
		ИзвлеченныйТекст = ЧтениеТекста.Прочитать();
	Исключение
		Отказ = Истина;
		ИзвлеченныйТекст = "";
	КонецПопытки;
	
#КонецЕсли
	
	Возврат ИзвлеченныйТекст;
	
КонецФункции

// Получает имя с расширением (если расширение пусто - только имя).
//
// Параметры:
//   ПолноеНаименование - Строка - полное наименование файла.
//   Расширение - Строка - расширение файла.
//
// Возвращаемое значение:
//   Строка - Имя с расширением. Если расширение пусто - только имя.
//
Функция ИмяСРасширением(ПолноеНаименование, Расширение) Экспорт
	
	ИмяСРасширением = ПолноеНаименование;
	
	Если Расширение <> "" Тогда
		ИмяСРасширением = СтрШаблон("%1.%2", ИмяСРасширением, Расширение);
	КонецЕсли;
	
	Возврат ИмяСРасширением;
	
КонецФункции

// Возвращает строку с размером файла в кратком и удобном для чтения формате.
//
// Параметры:
//   Размер - Число - размер файла в байтах.
//
// Возвращаемое значение:
//   Строка - размер файла в виде 123.4 Кб
//
Функция КраткоеПредставлениеРазмера(Знач Размер) Экспорт
	
	Если Размер = 0 Тогда
		Возврат "-";
		
	ИначеЕсли Размер < 1024 * 10 Тогда // < 10 Кб
		Возврат СтрШаблон(НСтр("ru = '%1 Кб'"), Формат(РазмерВКб(Размер), "ЧГ=0"));
		
	ИначеЕсли Размер < 1024 * 1024 Тогда // < 1 Мб
		Возврат СтрШаблон(НСтр("ru = '%1 Кб'"), Формат(РазмерВКб(Размер), "ЧГ=0"));
		
	ИначеЕсли Размер < 1024 * 1024 * 10 Тогда // < 10 Мб
		Возврат СтрШаблон(НСтр("ru = '%1 Мб'"), Формат(РазмерВМб(Размер), "ЧГ=0"));
		
	Иначе // >= 10 Мб
		Возврат СтрШаблон(НСтр("ru = '%1 Мб'"), Формат(РазмерВМб(Размер), "ЧГ=0"));
		
	КонецЕсли;
	
КонецФункции

// Возвращает пустые параметры создания файла для вызова
// ИнтеграцияС1СДокументооборотБазоваяФункциональностьВызовСервера.СоздатьИзФайлаНаДискеСервер.
//
// Параметры:
//   ТекущийФайл - Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеФайла
//
// Возвращаемое значение:
//   Структура:
//     * ТекущийФайл - Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеФайла
//     * АдресВременногоХранилищаФайла - Неопределено
//     * Владелец - Неопределено
//     * ЯвляетсяСканКопией - Булево
//     * ШаблонID - Строка
//     * ВнешнийОбъект - Структура:
//       * ID - Строка
//       * type - Строка
//       * name - Строка
//
Функция НовыеПараметрыСозданияФайла(ТекущийФайл) Экспорт
	
	ПараметрыСоздания = Новый Структура;
	ПараметрыСоздания.Вставить("ТекущийФайл", ТекущийФайл);
	ПараметрыСоздания.Вставить("АдресВременногоХранилищаФайла", Неопределено);
	ПараметрыСоздания.Вставить("Владелец", Неопределено);
	ПараметрыСоздания.Вставить("ЯвляетсяСканКопией", Ложь);
	ПараметрыСоздания.Вставить("ШаблонID", Неопределено);
	ПараметрыСоздания.Вставить("ВнешнийОбъект", Новый Структура("ID, type, name"));
	
	Возврат ПараметрыСоздания;
	
КонецФункции

// Возвращает размер файла в килобайтах.
//
// Параметры:
//   Размер - Число - размер файла в байтах.
//
// Возвращаемое значение:
//   Число - размер файла в Кб.
//
Функция РазмерВКб(Знач Размер) Экспорт
	
	Если Размер = 0 Тогда
		Возврат 0;
		
	ИначеЕсли Размер < 1024 * 10 Тогда // < 10 Кб
		Возврат Макс(1, Окр(Размер / 1024, 1, 1));
		
	Иначе
		Возврат Цел(Размер / 1024);
		
	КонецЕсли;
	
КонецФункции

// Возвращает размер файла в мегабайтах.
//
// Параметры:
//   Размер - Число - размер файла в байтах.
//
// Возвращаемое значение:
//   Число - размер файла в Мб.
//
Функция РазмерВМб(Знач Размер) Экспорт
	
	Если Размер = 0 Тогда
		Возврат 0;
		
	ИначеЕсли Размер < 1024 * 1024 * 10 Тогда // < 10 Мб
		Возврат Окр(Размер / 1024 / 1024, 1, 1);
		
	Иначе // >= 10 Мб
		Возврат Цел(Размер / 1024 / 1024);
		
	КонецЕсли;
	
КонецФункции

// Возвращает строку с размером файла в удобном для чтения формате с указанием количества байт.
//
// Параметры:
//   Размер - Число - размер файла в байтах.
//
// Возвращаемое значение:
//   Строка - размер файла в виде 123.4 Кб (123 456 байт)
//
Функция ПодробноеПредставлениеРазмера(Знач Размер) Экспорт
	
	Если Размер = 0 Тогда
		Возврат "-";
	КонецЕсли;
	
	Возврат СтрШаблон(НСтр("ru = '%1 (%2 байт)'"),
		КраткоеПредставлениеРазмера(Размер),
		Формат(Размер, "ЧДЦ=; ЧРГ=' '; ЧГ=3,0"));
	
КонецФункции

// Получить строку с представлением размера файла - например для отображения в Состояние при передаче файла.
//
// Параметры:
//   РазмерВМб - Число - Размер в Мб.
//
// Возвращаемое значение:
//   Строка - размера файла.
//
Функция ПолучитьСтрокуСРазмеромФайла(Знач РазмерВМб) Экспорт
	
	Если РазмерВМб < 0.1 Тогда
		РазмерВМб = 0.1;
	КонецЕсли;
	
	Если РазмерВМб >= 1 Тогда
		ФорматнаяСтрока = "ЧДЦ=0";
	Иначе
		ФорматнаяСтрока = "ЧДЦ=1; ЧН=0";
	КонецЕсли;
	
	Возврат Формат(РазмерВМб, ФорматнаяСтрока);
	
КонецФункции

// Сверяет размер файла с максимально допустимым размером, заданным в настройках интеграции.
//
// Параметры:
//   МаксРазмерФайла - Число - максимально допустимый размер файла.
//   Размер - Число - размер файла в байтах.
//   ИмяФайла - Строка - наименование файла.
//   ВызыватьИсключение - Булево - вызывать исключение если максимальный размер превышен.
//   ТекстСообщения - Строка - неявно возвращаемое значение, текст сообщения пользователю.
//
// Возвращаемое значение:
//   Булево - размер файла превышает максимально допустимый.
//
Функция РазмерФайлаПревышаетМаксимальноДопустимый(МаксРазмерФайла, Размер, ИмяФайла,
		ВызыватьИсключение = Истина, ТекстСообщения = "") Экспорт
	
	Если Размер > МаксРазмерФайла Тогда
		ТекстСообщения = СтрШаблон(
			НСтр("ru = 'Размер файла ""%1"" (%2) превышает максимально допустимый (%3).'"),
			ИмяФайла,
			КраткоеПредставлениеРазмера(Размер),
			КраткоеПредставлениеРазмера(МаксРазмерФайла));
		Если ВызыватьИсключение Тогда
			ВызватьИсключение ТекстСообщения;
		Иначе
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Разделяет пароль на две независимые части для последующего восстановления функцией СобратьПароль.
//
// Параметры:
//   Пароль - Строка - разделяемый пароль.
//
// Возвращаемое значение:
//   Массив из Строка - массив из двух строк, содержащих шестнадцатиричное представление пароля.
//
Функция РазделитьПароль(Пароль) Экспорт
	
	Результат = Новый Массив;
	Результат.Добавить("");
	Результат.Добавить("");
	Генератор = Неопределено;
	
	// Разложим пароль в массив чисел попарно.
	МассивЧисел = Новый Массив;
	Индекс = 1;
	Пока Индекс <= СтрДлина(Пароль) Цикл
		Число = КодСимвола(Пароль, Индекс);
		Индекс = Индекс + 1;
		Если Индекс <= СтрДлина(Пароль) Тогда
			Число = Число * 65536 + КодСимвола(Пароль, Индекс);
			Индекс = Индекс + 1;
		КонецЕсли;
		МассивЧисел.Добавить(Число);
	КонецЦикла;
	
	// Разделим каждое из полученных чисел.
	Для Каждого Число Из МассивЧисел Цикл
		РазделенноеЧисло = РазделитьЧисло(Число, Генератор); // ((1, NNN), (2, MMM))
		Результат[0] = Результат[0] + ШестнадцатиричноеПредставлениеЧисла(РазделенноеЧисло[0][1], 8);
		Результат[1] = Результат[1] + ШестнадцатиричноеПредставлениеЧисла(РазделенноеЧисло[1][1], 8);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает Истина, если файл с таким расширением находится в списке расширений.
//
// Параметры:
//   СписокРасширений - Строка - Список расширений.
//   РасширениеФайла - Строка - Расширение файла.
//
// Возвращаемое значение:
//   Булево
//
Функция РасширениеФайлаВСписке(СписокРасширений, РасширениеФайла) Экспорт
	
	РасширениеФайлаБезТочки = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(РасширениеФайла);
	
	МассивРасширений = СтрРазделить(НРег(СписокРасширений), " ", Ложь);
	
	Если МассивРасширений.Найти(РасширениеФайлаБезТочки) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Конструктор структуры, описывающей свойства файла.
//
// Возвращаемое значение:
//   Структура:
//     * ИдентификаторФайла - Строка - идентификатор файла в 1С:Документооборот.
//     * ИмяФайла - Строка - имя файла.
//     * ОписаниеФайла - Строка - описание файла.
//     * Редактируется - Булево - файл находится на редактировании.
//     * Зашифрован - Булево - файл зашифрован.
//     * ДанныеПодписейФайла - Массив из Структура - структура существующих подписей.
//     * УникальныйИдентификатор - УникальныйИдентификатор - идентификатор управляемой формы объекта.
//     * ВладелецФайла - Строка - идентификатор владельца файла в 1С:Документооборот.
//
Функция СвойстваФайла() Экспорт
	
	СвойстваФайла = Новый Структура;
	СвойстваФайла.Вставить("ИдентификаторФайла", Неопределено);
	СвойстваФайла.Вставить("ИмяФайла", Неопределено);
	СвойстваФайла.Вставить("ОписаниеФайла", Неопределено);
	СвойстваФайла.Вставить("Редактируется", Неопределено);
	СвойстваФайла.Вставить("Зашифрован", Неопределено);
	СвойстваФайла.Вставить("ДанныеПодписейФайла", Неопределено);
	СвойстваФайла.Вставить("УникальныйИдентификатор", Неопределено);
	СвойстваФайла.Вставить("ВладелецФайла", Неопределено);
	
	Возврат СвойстваФайла;
	
КонецФункции

// Определяет доступность сервиса ДО по номеру версии.
//
// Параметры:
//   ВерсияСервиса - Строка - версия сервиса ДО.
//
// Возвращаемое значение:
//   Булево
//
Функция СервисДоступен(ВерсияСервиса) Экспорт
	
	Возврат ВерсияСервиса <> "" И ВерсияСервиса <> "0.0.0.0";
	
КонецФункции

// Собирает пароль из двух частей, ранее разделенных функцией РазделитьПароль.
// В случае повреждения строк возвращает Неопределено.
//
// Параметры:
//   РазделенныйПароль - Массив из Строка - две строки, содержащие разделенный пароль.
//
// Возвращаемое значение:
//   Строка - собранный пароль или
//   Неопределено - если строки повреждены.
//
Функция СобратьПароль(Знач РазделенныйПароль) Экспорт
	
	Если РазделенныйПароль.Количество() <> 2 Тогда
		Возврат Неопределено;
	КонецЕсли;
	РазделенныйПароль[0] = СокрЛП(РазделенныйПароль[0]);
	РазделенныйПароль[1] = СокрЛП(РазделенныйПароль[1]);
	Если СтрДлина(РазделенныйПароль[0]) <> СтрДлина(РазделенныйПароль[1]) Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если СтрДлина(РазделенныйПароль[0]) % 8 <> 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	Результат = "";
	Чисел = Цел(СтрДлина(РазделенныйПароль[0])) / 8;
	Для НЧисла = 1 По Чисел Цикл
		РазделенноеЧисло = Новый Массив;
		Для НЧасти = 0 По 1 Цикл
			Пара = Новый Массив;
			Пара.Добавить(НЧасти + 1);
			Представление = Сред(РазделенныйПароль[НЧасти], 1 + (НЧисла - 1) * 8, 8);
			Пара.Добавить(ЧислоИзШестнадцатеричногоПредставления(Представление));
			РазделенноеЧисло.Добавить(Пара);
		КонецЦикла;
		СобранноеЧисло = СобратьЧисло(РазделенноеЧисло);
		Если СобранноеЧисло >= 65536 Тогда
			Результат = Результат + Символ(Цел(СобранноеЧисло / 65536));
		КонецЕсли;
		Результат = Результат + Символ(СобранноеЧисло % 65536);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Выводит сообщение в HTML представление, которое будет отображаться в области предпросмотра.
//
// Параметры:
//   Сообщение - Строка - сообщение для области предпросмотра.
//   ЗаголовокСообщенияВОбластиПредпросмотра - Строка - заголовок, содержащий настройки вывода сообщения.
//
// Возвращаемое значение:
//   Строка - HTML представление сообщения.
//
Функция СообщениеВПредпросмотр(Сообщение, ЗаголовокСообщенияВОбластиПредпросмотра) Экспорт
	
	Результат = Новый Массив;
	Результат.Добавить("<html>");
	Результат.Добавить(ЗаголовокСообщенияВОбластиПредпросмотра);
	Результат.Добавить("<div class=""block"">");
	
	Сообщение = СтрЗаменить(Сообщение, Символы.ПС, "<br>");
	Результат.Добавить(Сообщение);
	
	Результат.Добавить(
		"</div>
		|</body>
		|</html>");
	
	Возврат СтрСоединить(Результат, Символы.ПС);
	
КонецФункции

// Возвращает Строку сообщения о недопустимости подписания зашифрованного файла.
//
// Параметры:
//   ФайлСсылка - ЛюбаяСсылка - Ссылка на файл.
//
// Возвращаемое значение:
//   Строка
//
Функция СтрокаСообщенияОНедопустимостиПодписанияЗашифрованногоФайла(ФайлСсылка = Неопределено) Экспорт
	
	Если ФайлСсылка = Неопределено Тогда
		Возврат НСтр("ru = 'Нельзя подписать зашифрованный файл.'");
	Иначе
		Возврат СтрШаблон(НСтр("ru = 'Нельзя подписать зашифрованный файл: %1.'"), ФайлСсылка);
	КонецЕсли;
	
КонецФункции

// Проверяет, является ли переданное значение расширением скан-копии.
//
// Параметры:
//   Расширение - Строка - расширение файла.
//   СписокРасширенийСканКопийОригиналов - Строка - список расширений скан-копий.
//
// Возвращаемое значение:
//   Булево - Истина, если переданное значение является расширением скан-копии.
//
Функция ЭтоРасширениеСканКопии(Расширение, Знач СписокРасширенийСканКопийОригиналов) Экспорт
	
	РасширениеБезТочки = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Расширение);
	
	СписокРасширенийСканКопийОригиналов = СтрЗаменить(СписокРасширенийСканКопийОригиналов, " ", ",");
	СписокРасширенийСканКопийОригиналов = СтрЗаменить(СписокРасширенийСканКопийОригиналов, ";", ",");
	МассивРасширенийСканКопий = СтрРазделить(СписокРасширенийСканКопийОригиналов, ",", Ложь);
	
	// Если расширения скан-копий не заданы, то не делаем автоматическую пометку скан-копией.
	КоличествоРасширенийСканКопий = МассивРасширенийСканКопий.Количество();
	Если КоличествоРасширенийСканКопий = 0 Тогда
		Возврат Ложь;
	Иначе
		Возврат МассивРасширенийСканКопий.Найти(РасширениеБезТочки) <> Неопределено;
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ЭлектронныеПодписи

// Возвращает структуру данных владельца подписи.
//
// Параметры:
//   Наименование - Строка - имя объекта ДО.
//   ID - Строка - идентификатор объекта ДО.
//   Тип - Строка - тип объекта XDTO.
//   Зашифрован - Булево - владелец подписи зашифрован.
//   МассивПодписей - Массив из Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеПодписи
//
// Возвращаемое значение:
//   Структура - данные владельца подписей:
//     * Наименование - Строка - имя объекта ДО.
//     * ID - Строка - идентификатор объекта ДО.
//     * Тип - Строка - тип объекта XDTO.
//     * Зашифрован - Булево - владелец подписи зашифрован.
//     * МассивПодписей - Массив из Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеПодписи
//
Функция ДанныеВладельцаПодписи(Наименование, ID, Тип, Зашифрован, МассивПодписей = Неопределено) Экспорт
	
	Если МассивПодписей = Неопределено Тогда
		МассивПодписей = Новый Массив;
	КонецЕсли;
	
	ДанныеВладельцаПодписи = Новый Структура;
	ДанныеВладельцаПодписи.Вставить("Наименование", Наименование);
	ДанныеВладельцаПодписи.Вставить("ID", ID);
	ДанныеВладельцаПодписи.Вставить("Тип", Тип);
	ДанныеВладельцаПодписи.Вставить("Зашифрован", Зашифрован);
	ДанныеВладельцаПодписи.Вставить("МассивПодписей", МассивПодписей);
	Возврат ДанныеВладельцаПодписи;
	
КонецФункции

// Возвращает данные, из которых будет формироваться XDTO объект DMSignature, для передачи в ДО.
//
// Параметры:
//   Подпись - ДвоичныеДанные - двоичные данные подписи.
//   ДвоичныеДанныеСертификата - ДвоичныеДанные - двоичные данные сертификата.
//   СвойстваПодписи - Структура - тут может быть или структура СвойстваПодписи, которую возвращает БСП при
//     добавлении новой подписи, или строка таблицы подписей, если это уже существующая на стороне ДО подпись.
//
// Возвращаемое значение:
//   Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.СтруктураПодписи
//
Функция ДанныеПодписи(Подпись, ДвоичныеДанныеСертификата, СвойстваПодписи) Экспорт
	
	ДанныеПодписи = СтруктураПодписи();
	ДанныеПодписи.Подпись = Подпись;
	ДанныеПодписи.ДвоичныеДанныеСертификата = ДвоичныеДанныеСертификата;
	ДанныеПодписи.Отпечаток = СвойстваПодписи.Отпечаток;
	ДанныеПодписи.ДатаПодписи = СвойстваПодписи.ДатаПодписи;
	ДанныеПодписи.Комментарий = СвойстваПодписи.Комментарий;
	ДанныеПодписи.ИмяФайлаПодписи = СвойстваПодписи.ИмяФайлаПодписи;
	ДанныеПодписи.КомуВыданСертификат = СвойстваПодписи.КомуВыданСертификат;
	ДанныеПодписи.УстановившийПодпись = Строка(СвойстваПодписи.УстановившийПодпись);
	
	// Если подпись уже существует на стороне ДО - УстановившийПодписьИд будет заполнен.
	// Если это новая подпись, которая была сформирована на клиенте ИС - передадим идентификатор пользователя ИС,
	// который установил подпись.
	// Если на стороне ДО пользователь по переданному идентификатору не найдется - подписавшим будет считаться
	// текущий пользователем ДО, под которым выполнено подключение к ДО через бесшовную интеграцию.
	Если СвойстваПодписи.Свойство("УстановившийПодписьИд") Тогда
		ДанныеПодписи.УстановившийПодписьИд = СвойстваПодписи.УстановившийПодписьИд;
	Иначе
		ДанныеПодписи.УстановившийПодписьИд = Строка(СвойстваПодписи.УстановившийПодпись.УникальныйИдентификатор());
	КонецЕсли;
	
	Возврат ДанныеПодписи;
	
КонецФункции

// Дополняет соответствие подписей объектов.
//
// Параметры:
//   ПодписиОбъектов - Соответствие:
//     * Ключ - Строка - идентификатор объекта ДО, являющегося владельцем подписи.
//     * Значение - Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеВладельцаПодписи
//   Наименование - Строка - имя объекта ДО.
//   ID - Строка - идентификатор объекта ДО.
//   Тип - Строка - тип объекта XDTO.
//   Зашифрован - Булево - владелец подписи зашифрован.
//   МассивПодписей - Массив из Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.ДанныеПодписи
//
Процедура ДополнитьПодписиОбъектов(ПодписиОбъектов, Наименование, ID, Тип, Зашифрован,
		МассивПодписей = Неопределено) Экспорт
	
	ДанныеВладельцаПодписи = ПодписиОбъектов[ID];
	
	Если ДанныеВладельцаПодписи = Неопределено Тогда
		ПодписиОбъектов.Вставить(
			ID,
			ДанныеВладельцаПодписи(Наименование, ID, Тип, Зашифрован, МассивПодписей));
		
	ИначеЕсли МассивПодписей <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ДанныеВладельцаПодписи.МассивПодписей, МассивПодписей);
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает структуру параметров для проверки электронно-цифровой подписи.
//
// Параметры:
//   ДанныеСтроки - ДанныеФормыЭлементДерева - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.СтруктураСтрокиДереваПодписей
//   СоответствиеИдОбъектаИДвоичныхДанных - Соответствие - соответствие идентификаторов объектов и их двоичных данных.
//   АдресСлепкаДокумента - Строка - адрес временного хранилища двоичных данных документа Документооборота.
//
// Возвращаемое значение:
//   Структура:
//     * ФорматДатыПроверки - Строка
//     * ДвоичныеДанныеОбъекта - ДвоичныеДанные
//     * Подпись - ДвоичныеДанные
//
Функция ПараметрыПроверкиЭП(ДанныеСтроки, СоответствиеИдОбъектаИДвоичныхДанных, АдресСлепкаДокумента) Экспорт
	
	ПараметрыПроверкиЭП = Новый Структура("ФорматДатыПроверки, ДвоичныеДанныеОбъекта, Подпись");
	
	Если ДанныеСтроки.Зашифрован Тогда
		ДанныеСтроки.Неверна = Ложь;
		ДанныеСтроки.ПодписьВерна = Ложь;
		ДанныеСтроки.Статус =
			НСтр("ru = 'Проверка подписи зашифрованного файла доступна только на стороне 1С:Документооборот'");
		ДанныеСтроки.КомуВыданСертификатИСтатус =
			ДанныеСтроки.КомуВыданСертификат
			+ Символы.ПС
			+ ДанныеСтроки.Статус;
		Возврат ПараметрыПроверкиЭП;
	КонецЕсли;
	
	ПараметрыПроверкиЭП.Подпись = ПолучитьИзВременногоХранилища(ДанныеСтроки.АдресПодписи);
	
	ПараметрыПроверкиЭП.ДвоичныеДанныеОбъекта = СоответствиеИдОбъектаИДвоичныхДанных[ДанныеСтроки.ОбъектИд];
	
	Если ПараметрыПроверкиЭП.ДвоичныеДанныеОбъекта = Неопределено Тогда
		
		Если ДанныеСтроки.ОбъектТип = "DMFile" Тогда
			ПараметрыПроверкиЭП.ДвоичныеДанныеОбъекта =
				ИнтеграцияС1СДокументооборотБазоваяФункциональностьВызовСервера.ДвоичныеДанныеФайла(
					ДанныеСтроки.ОбъектИд);
		Иначе
			ПараметрыПроверкиЭП.ДвоичныеДанныеОбъекта = ПолучитьИзВременногоХранилища(АдресСлепкаДокумента);
		КонецЕсли;
		
		СоответствиеИдОбъектаИДвоичныхДанных[ДанныеСтроки.ОбъектИд] = ПараметрыПроверкиЭП.ДвоичныеДанныеОбъекта;
	КонецЕсли;
	
	ПараметрыПроверкиЭП.ФорматДатыПроверки = "ДФ='dd.MM.yyyy HH:mm'";
	
	Возврат ПараметрыПроверкиЭП;
	
КонецФункции

// Определяет выделена ли подпись в переданных данных строки строки из таблицы подписей.
//
// Параметры:
//   ВыделенныеПодписи - Массив из Структура - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиент.ВыделенныеПодписи
//   ДанныеСтроки - ДанныеФормыЭлементДерева - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.СтруктураСтрокиДереваПодписей
//
// Возвращаемое значение:
//   Булево
//
Функция ПодписьВыделена(ВыделенныеПодписи, ДанныеСтроки) Экспорт
	
	ПодписьВыделена = Ложь;
	Если ТипЗнч(ВыделенныеПодписи) = Тип("Массив") Тогда
		Для Каждого СтрокаВыделеннойПодписи Из ВыделенныеПодписи Цикл
			Если СтрокаВыделеннойПодписи.ОбъектID = ДанныеСтроки.ОбъектИд
					И СтрокаВыделеннойПодписи.НомерСтроки = ДанныеСтроки.НомерСтроки Тогда
				ПодписьВыделена = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Нужно обойти все подписи
		ПодписьВыделена = Истина;
	КонецЕсли;
	
	Возврат ПодписьВыделена;
	
КонецФункции

// Возвращает Строку сообщения о недопустимости подписания занятого файла.
//
// Параметры:
//   ФайлСсылка - ЛюбаяСсылка - Ссылка на файл.
//
// Возвращаемое значение:
//   Строка
//
Функция СтрокаСообщенияОНедопустимостиПодписанияЗанятогоФайла(ФайлСсылка = Неопределено) Экспорт
	
	Если ФайлСсылка = Неопределено Тогда
		Возврат НСтр("ru = 'Нельзя подписать занятый файл.'");
	Иначе
		Возврат СтрШаблон(НСтр("ru = 'Нельзя подписать занятый файл: %1.'"), ФайлСсылка);
	КонецЕсли;
	
КонецФункции

// Конструктор структуры, описывающей данные электронной подписи.
//
// Возвращаемое значение:
//   Структура:
//     * Подпись - ДвоичныеДанные
//     * ДвоичныеДанныеСертификата - ДвоичныеДанные
//     * Отпечаток - Строка
//     * ДатаПодписи - Дата
//     * Комментарий - Строка
//     * ИмяФайлаПодписи - Строка
//     * КомуВыданСертификат - Строка
//     * УстановившийПодпись - Строка
//     * УстановившийПодписьИд - Строка
//
Функция СтруктураПодписи() Экспорт
	
	ДанныеПодписи = Новый Структура;
	ДанныеПодписи.Вставить("Подпись", Неопределено);
	ДанныеПодписи.Вставить("ДвоичныеДанныеСертификата", Неопределено);
	ДанныеПодписи.Вставить("Сертификат", Неопределено);
	ДанныеПодписи.Вставить("Отпечаток", Неопределено);
	ДанныеПодписи.Вставить("ДатаПодписи", Неопределено);
	ДанныеПодписи.Вставить("Комментарий", Неопределено);
	ДанныеПодписи.Вставить("ИмяФайлаПодписи", Неопределено);
	ДанныеПодписи.Вставить("КомуВыданСертификат", Неопределено);
	ДанныеПодписи.Вставить("УстановившийПодпись", Неопределено);
	ДанныеПодписи.Вставить("УстановившийПодписьИд", Неопределено);
	
	Возврат ДанныеПодписи;
	
КонецФункции

// Конструктор структуры, описывающей строку дерева подписей.
//
// Параметры:
//   СтрокаДереваПодписей - ДанныеФормыЭлементДерева - строка дерева подписей.
//
// Возвращаемое значение:
//   Структура:
//     * АдресПодписи - Строка
//     * АдресСертификата - Строка
//     * ДатаПодписи - Дата
//     * ДатаПодписиИКомментарий - Строка
//     * Зашифрован - Булево
//     * ИмяФайлаПодписи - Строка
//     * ИндексКартинки - Число
//     * Комментарий - Строка
//     * КомуВыданСертификат - Строка
//     * КомуВыданСертификатИСтатус - Строка
//     * Неверна - Булево
//     * НомерСтроки - Число
//     * Объект - Строка
//     * ОбъектИд - Строка
//     * ОбъектИмя - Строка
//     * ОбъектТип - Строка
//     * Отпечаток - Строка
//     * ПодписьВерна - Булево
//     * Статус - Строка
//     * УстановившийПодпись - Строка
//     * УстановившийПодписьИд - Строка
//
Функция СтруктураСтрокиДереваПодписей(СтрокаДереваПодписей) Экспорт
	
	СтруктураСтроки = Новый Структура;
	СтруктураСтроки.Вставить("АдресПодписи", СтрокаДереваПодписей.АдресПодписи);
	СтруктураСтроки.Вставить("АдресСертификата", СтрокаДереваПодписей.АдресСертификата);
	СтруктураСтроки.Вставить("ДатаПодписи", СтрокаДереваПодписей.ДатаПодписи);
	СтруктураСтроки.Вставить("ДатаПодписиИКомментарий", СтрокаДереваПодписей.ДатаПодписиИКомментарий);
	СтруктураСтроки.Вставить("Зашифрован", СтрокаДереваПодписей.Зашифрован);
	СтруктураСтроки.Вставить("ИмяФайлаПодписи", СтрокаДереваПодписей.ИмяФайлаПодписи);
	СтруктураСтроки.Вставить("ИндексКартинки", СтрокаДереваПодписей.ИндексКартинки);
	СтруктураСтроки.Вставить("Комментарий", СтрокаДереваПодписей.Комментарий);
	СтруктураСтроки.Вставить("КомуВыданСертификат", СтрокаДереваПодписей.КомуВыданСертификат);
	СтруктураСтроки.Вставить("КомуВыданСертификатИСтатус", СтрокаДереваПодписей.КомуВыданСертификатИСтатус);
	СтруктураСтроки.Вставить("Неверна", СтрокаДереваПодписей.Неверна);
	СтруктураСтроки.Вставить("НомерСтроки", СтрокаДереваПодписей.НомерСтроки);
	СтруктураСтроки.Вставить("Объект", СтрокаДереваПодписей.Объект);
	СтруктураСтроки.Вставить("ОбъектИд", СтрокаДереваПодписей.ОбъектИд);
	СтруктураСтроки.Вставить("ОбъектИмя", СтрокаДереваПодписей.ОбъектИмя);
	СтруктураСтроки.Вставить("ОбъектТип", СтрокаДереваПодписей.ОбъектТип);
	СтруктураСтроки.Вставить("Отпечаток", СтрокаДереваПодписей.Отпечаток);
	СтруктураСтроки.Вставить("ПодписьВерна", СтрокаДереваПодписей.ПодписьВерна);
	СтруктураСтроки.Вставить("Статус", СтрокаДереваПодписей.Статус);
	СтруктураСтроки.Вставить("УстановившийПодпись", СтрокаДереваПодписей.УстановившийПодпись);
	СтруктураСтроки.Вставить("УстановившийПодписьИд", СтрокаДереваПодписей.УстановившийПодписьИд);
	
	Возврат СтруктураСтроки;
	
КонецФункции

// Преобразует 2-уровневое дерево в массив.
//
// Параметры:
//   ДеревоПодписей - ДанныеФормыДерево - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.СтруктураСтрокиДереваПодписей
//   ВыделенныеСтроки - Массив из Число - выделенные строки в дереве подписей.
//   ОбъектID - Строка - заполняется если нужно получить подписи конкретного объекта.
//
// Возвращаемое значение:
//   Массив из СтрокаДереваЗначений - см. ИнтеграцияС1СДокументооборотБазоваяФункциональностьКлиентСервер.СтруктураСтрокиДереваПодписей
//
Функция ТаблицаПодписей(ДеревоПодписей, ВыделенныеСтроки = Неопределено, ОбъектID = Неопределено) Экспорт
	
	ТаблицаПодписей = Новый Массив;
	
	Если ВыделенныеСтроки = Неопределено Тогда
		
		ЭлементыПервогоУровня = ДеревоПодписей.ПолучитьЭлементы();
		Для Каждого СтрокаУровняОдин Из ЭлементыПервогоУровня Цикл
			ЭлементыВторогоУровня = СтрокаУровняОдин.ПолучитьЭлементы();
			Для Каждого Строка Из ЭлементыВторогоУровня Цикл
				ПодходитПоID = Истина;
				Если ОбъектID <> Неопределено Тогда
					ПодходитПоID = (Строка.ОбъектИд = ОбъектID);
				КонецЕсли;
				Если Не ПустаяСтрока(Строка.Объект) И ПодходитПоID Тогда
					ТаблицаПодписей.Добавить(СтруктураСтрокиДереваПодписей(Строка));
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	Иначе
		
		Для Каждого Элемент Из ВыделенныеСтроки Цикл
			Строка = ДеревоПодписей.НайтиПоИдентификатору(Элемент);
			ПодходитПоID = Истина;
			Если ОбъектID <> Неопределено Тогда
				ПодходитПоID = (Строка.ОбъектИд = ОбъектID);
			КонецЕсли;
			Если Не ПустаяСтрока(Строка.Объект) И ПодходитПоID Тогда
				ТаблицаПодписей.Добавить(СтруктураСтрокиДереваПодписей(Строка));
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТаблицаПодписей;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Извлечь текст из объекта ЧтениеXML (прочитанного из файла OpenDocument).
//
Функция ИзвлечьТекстИзContentXML(ЧтениеXML)
	
	ИзвлеченныйТекст = "";
	ПоследнееИмяТега = "";
	
#Если Не ВебКлиент Тогда
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			ПоследнееИмяТега = ЧтениеXML.Имя;
			
			Если ЧтениеXML.Имя = "text:p" Тогда
				Если НЕ ПустаяСтрока(ИзвлеченныйТекст) Тогда
					ИзвлеченныйТекст = ИзвлеченныйТекст + Символы.ПС;
				КонецЕсли;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "text:line-break" Тогда
				Если НЕ ПустаяСтрока(ИзвлеченныйТекст) Тогда
					ИзвлеченныйТекст = ИзвлеченныйТекст + Символы.ПС;
				КонецЕсли;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "text:tab" Тогда
				Если НЕ ПустаяСтрока(ИзвлеченныйТекст) Тогда
					ИзвлеченныйТекст = ИзвлеченныйТекст + Символы.Таб;
				КонецЕсли;
			КонецЕсли;
			
			Если ЧтениеXML.Имя = "text:s" Тогда
				
				СтрокаДобавки = " "; // пробел
				
				Если ЧтениеXML.КоличествоАтрибутов() > 0 Тогда
					Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
						Если ЧтениеXML.Имя = "text:c"  Тогда
							ЧислоПробелов = Число(ЧтениеXML.Значение);
							СтрокаДобавки = "";
							Для Индекс = 0 По ЧислоПробелов - 1 Цикл
								СтрокаДобавки = СтрокаДобавки + " "; // пробел
							КонецЦикла;
						КонецЕсли;
					КонецЦикла
				КонецЕсли;
				
				Если НЕ ПустаяСтрока(ИзвлеченныйТекст) Тогда
					ИзвлеченныйТекст = ИзвлеченныйТекст + СтрокаДобавки;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			
			Если СтрНайти(ПоследнееИмяТега, "text:") <> 0 Тогда
				ИзвлеченныйТекст = ИзвлеченныйТекст + ЧтениеXML.Значение;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
#КонецЕсли
	
	Возврат ИзвлеченныйТекст;
	
КонецФункции

// Возвращает большое простое число, используемое как модуль кольца классов вычетов.
// Должно быть больше любого из кодируемых чисел.
//
// Возвращаемое значение:
//   Число
//
Функция МодульКольцаВычетов()
	
	Возврат 4294967291; // больше любого из вероятных сочетаний двух символов пароля.
	
КонецФункции

// Рассчитывает обратный модуль.
//
// Параметры:
//   ЧислоK - Число.
//
// Возвращаемое значение:
//   Число - такое, что (ЧислоK * ОбратныйМодуль(ЧислоK)) % Модуль = 1 для всех
//     положительных ЧислоK < Модуль.
//
Функция ОбратныйМодуль(Знач ЧислоK)
	
	Модуль = МодульКольцаВычетов();
	ЧислоK = ЧислоK % Модуль;
	
	Если ЧислоK < 0 Тогда
		Разложение = РазложитьНОД(Модуль, -ЧислоK);
		МножительРазложения = -Разложение[2];
	Иначе
		Разложение = РазложитьНОД(Модуль, ЧислоK);
		МножительРазложения = Разложение[2];
	КонецЕсли;
	
	Возврат (Модуль + МножительРазложения) % Модуль;
	
КонецФункции

// Разделяет число-секрет на указанное количество частей по алгоритму Шамира.
//
// Параметры:
//   Число - Число - разделяемое число, от 0 до 2^32 - 1.
//   Генератор - ГенераторСлучайныхЧисел - генератор случайных чисел, желательно сохранять его между вызовами.
//   Частей - Число - количество частей, на которые разделяется число.
//   Обязательных - Число - количество частей, требуемых для восстановления.
//
// Возвращаемое значение:
//   Массив из Массив - Массив пар чисел вида (1, 123), (2, 234), (3, 345), необходимых для восстановления.
//
Функция РазделитьЧисло(Число, Генератор = Неопределено, Частей = 2, Обязательных = 2)
	
#Если Не ВебКлиент Тогда
	
	Если Генератор = Неопределено Тогда
		Генератор = Новый ГенераторСлучайныхЧисел(ТекущаяДата() - Дата(1, 1, 1)); // Использование оправдано: ГСЧ.
	КонецЕсли;
	Модуль = МодульКольцаВычетов();
	
	Пока Истина Цикл
		Результат = Новый Массив;
		Коэффициенты = Новый Массив;
		Коэффициенты.Добавить(Число);
		Коэффициенты.Добавить(Цел(Генератор.СлучайноеЧисло(0, Модуль - 1)));
		Коэффициенты.Добавить(Цел(Генератор.СлучайноеЧисло(0, Модуль - 1)));
		Для Часть = 1 По Частей Цикл
			Значение = Число;
			Для Степень = 1 По Обязательных - 1 Цикл
				Значение = (Значение + (Коэффициенты[Степень] * (Pow(Часть, Степень) % Модуль)) % Модуль) % Модуль;
			КонецЦикла;
			Пара = Новый Массив;
			Пара.Добавить(Часть);
			Пара.Добавить(Значение);
			Результат.Добавить(Пара);
		КонецЦикла;
		Если СобратьЧисло(Результат) = Число Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
#Иначе
	
	ВызватьИсключение НСтр("ru = 'Функция не поддерживается в веб-клиенте.'");
	
#КонецЕсли
	
КонецФункции

// Выполняет разложение наибольшего общего делителя пары чисел A и B.
//
// Параметры:
//   ЧислоA - Число.
//   ЧислоB - Число.
//
// Возвращаемое значение:
//   Массив из Число - массив (X, Y, Z), такой, что:
//     X - наибольший общий делитель ЧислоA и ЧислоB,
//     X = ЧислоA * Y + ЧислоB * Z.
//
Функция РазложитьНОД(Знач ЧислоA, Знач ЧислоB)
	
	Результат = Новый Массив;
	
	Если ЧислоB = 0 Тогда
		Результат.Добавить(ЧислоA);
		Результат.Добавить(1);
		Результат.Добавить(0);
	Иначе
		Частное = Цел(ЧислоA / ЧислоB);
		Модуль = ЧислоA % ЧислоB;
		Разложение = РазложитьНОД(ЧислоB, Модуль);
		Результат.Добавить(Разложение[0]);
		Результат.Добавить(Разложение[2]);
		Результат.Добавить(Разложение[1] - Разложение[2] * Частное);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Собирает число, разделенное по алгоритму Шамира на части функцией РазделитьЧисло.
//
// Параметры:
//   РазделенноеЧисло - Массив из Массив - массив пар чисел вида (1, 123), (2, 234), ...
//
// Возвращаемое значение:
//   Число - исходное число.
//
Функция СобратьЧисло(РазделенноеЧисло)
	
	Результат = 0;
	Модуль = МодульКольцаВычетов();
	Для Строка = 0 По РазделенноеЧисло.Количество() - 1 Цикл
		Нумератор = 1; 
		Делитель = 1;
		Для Колонка = 0 По РазделенноеЧисло.Количество() - 1 Цикл
			Если Строка = Колонка Тогда
				Продолжить;
			КонецЕсли;
			От = РазделенноеЧисло[Строка][0];
			До = РазделенноеЧисло[Колонка][0];
			Нумератор = (Нумератор * -До) % Модуль;
			Делитель = (Делитель * (От - До)) % Модуль;
		КонецЦикла;
		Значение = РазделенноеЧисло[Строка][1];
		Результат = (Модуль + Результат + (Значение * Нумератор * ОбратныйМодуль(Делитель))) % Модуль;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает число из его шестнадцатеричного представления. Может вызывать исключение.
//
// Параметры:
//   Представление - Строка - шестнадцатеричное число.
//
// Возвращаемое значение:
//   Число - преобразованное число.
//
Функция ЧислоИзШестнадцатеричногоПредставления(Знач Представление)
	
	Если Представление = "" Тогда
		Возврат 0;
	КонецЕсли;
	Представление = ВРег(Представление);
	
	Результат = 0;
	Пока Представление <> "" Цикл
		Разряд = Лев(Представление, 1);
		Представление = Сред(Представление, 2);
		Если Разряд >= "0" И Разряд <= "9" Тогда
			Результат = Результат * 16 + КодСимвола(Разряд, 1) - КодСимвола("0");
		ИначеЕсли Разряд >= "A" И Разряд <= "F" Тогда
			Результат = Результат * 16 + 10 + КодСимвола(Разряд, 1) - КодСимвола("A");
		Иначе
			ВызватьИсключение НСтр("ru = 'Ошибочный символ в шестнадцатеричной строке.'");
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Возвращает шестнадцатиричное представление числа.
//
// Параметры:
//   Число - Число - целое число.
//   Разрядов - Число - минимальная ширина результата.
//            - Неопределено - не дополнять нулями.
//
// Возвращаемое значение:
//   Строка - шестнадцатиричное представление числа, возможно,
//   дополненное нулями до указанного количества разрядов.
//
Функция ШестнадцатиричноеПредставлениеЧисла(Знач Число, Разрядов = Неопределено)
	
	Если Число = 0 И Разрядов = Неопределено Тогда
		Возврат "0";
	КонецЕсли;
	
	Результат = "";
	НРазряда = 0;
	Пока Истина Цикл
		НРазряда = НРазряда + 1;
		Если Число = 0 Тогда // возможно, следует дополнить до указанного числа разрядов
			Если Разрядов = Неопределено Тогда
				Прервать;
			ИначеЕсли НРазряда > Разрядов Тогда
				Прервать;
			КонецЕсли;
		КонецЕсли;
		ПравыйРазряд = Число % 16;
		Число = Цел(Число / 16);
		Если ПравыйРазряд > 9 Тогда
			Результат = Символ(КодСимвола("A") + ПравыйРазряд - 10) + Результат;
		Иначе
			Результат = Символ(КодСимвола("0") + ПравыйРазряд) + Результат;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти