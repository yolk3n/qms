#Область ПрограммныйИнтерфейс

/// Построение документа DOM из стоки XML
//
// Параметры:
//   СтрокаXML - Строка -
//     Строка XML, по которой нужно построить DOM.
//
// Возвращаемое значение:
//   ДокументDOM - Построенный по строке XML документ DOM.
///
Функция ПостроитьDOM(СтрокаXML) Экспорт
	
	// Функция кешируется на время вызова, чтобы можно было ее вызывать несколько раз
	// без потери времени.
	Возврат ФедеральныеВебСервисыПовтИспНаВремяВызова.ПостроитьDOM(СтрокаXML);
	
КонецФункции

Функция ПолучитьСтрокуПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath, УзелКонтекста = Неопределено) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	Если Неопределено = УзелКонтекста Тогда 
		УзелКонтекста = ДокументDOM;
	КонецЕсли;

	ТипРезультата_ = ТипРезультатаDOMXPath.Строка;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, УзелКонтекста, Разыменователь, ТипРезультата_
	);
	
	Возврат РезультатXPath_.СтроковоеЗначение;
	
КонецФункции

Функция ПолучитьМассивСтрокПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath) Экспорт
	
	Результат_ = Новый Массив();
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, ДокументDOM, Разыменователь, ТипРезультатаDOMXPath.Строка
	);
	
	Пока Истина Цикл 
		Элемент_ = РезультатXPath_.ПолучитьСледующий();
		Если Элемент_ = Неопределено Тогда 
			Прервать;
		КонецЕсли;
		Если ТипЗнч(Элемент_) = Тип("АтрибутDOM") Тогда 
			Результат_.Добавить(Элемент_.Значение);
		Иначе
			Результат_.Добавить(Элемент_.Данные);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат_;
КонецФункции

Функция ПолучитьАтрибутПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath, Знач УзелКонтекста = Неопределено) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	Если Неопределено = УзелКонтекста Тогда 
		УзелКонтекста = ДокументDOM;
	КонецЕсли;
	
	ТипРезультата_ = ТипРезультатаDOMXPath.Любой;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, УзелКонтекста, Разыменователь, ТипРезультата_
	);
	
	Атрибут_ = РезультатXPath_.ПолучитьСледующий();
	
	Если Атрибут_ = Неопределено Тогда
		Возврат Неопределено;
	Иначе
		Возврат Атрибут_.Значение;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьРеквизитыПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath, Знач УзелКонтекста = Неопределено) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	Если Неопределено = УзелКонтекста Тогда 
		УзелКонтекста = ДокументDOM;
	КонецЕсли;
	
	ТипРезультата_ = ТипРезультатаDOMXPath.Любой;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, УзелКонтекста, Разыменователь, ТипРезультата_
	);
	
	Возврат РезультатXPath_;
	
КонецФункции

Функция ПолучитьРеквизитПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath, Знач УзелКонтекста = Неопределено) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	Если Неопределено = УзелКонтекста Тогда 
		УзелКонтекста = ДокументDOM;
	КонецЕсли;
	
	ТипРезультата_ = ТипРезультатаDOMXPath.Любой;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, УзелКонтекста, Разыменователь, ТипРезультата_
	);
	
	Возврат РезультатXPath_.ПолучитьСледующий();
	
КонецФункции

Функция ПолучитьТекстУзлаПоXPath(ДокументDOM, Знач Разыменователь = Неопределено, XPath, Знач УзелКонтекста = Неопределено) Экспорт
	
	Если Неопределено = Разыменователь Тогда
		Разыменователь = ДокументDOM.СоздатьРазыменовательПИ();
	КонецЕсли;
	
	Если Неопределено = УзелКонтекста Тогда 
		УзелКонтекста = ДокументDOM;
	КонецЕсли;
	
	РезультатXPath_ = ДокументDOM.ВычислитьВыражениеXPath(
		XPath, УзелКонтекста, Разыменователь, ТипРезультатаDOMXPath.Любой
	);
	DOM_ = РезультатXPath_.ПолучитьСледующий();
	Если ТипЗнч(DOM_) <> Тип("ЭлементDOM") Тогда 
		Возврат "";
	КонецЕсли;
	
	Возврат ЗаписатьDOM(DOM_);
КонецФункции

Функция ЗаписатьDOM(УзелDOM, ЗаписыватьДекларациюXML = Ложь) Экспорт
	
	ЗаписьXML_ = Новый ЗаписьXML;
	ЗаписьXML_.УстановитьСтроку("UTF-8");
	ЗаписьDOM_ = Новый ЗаписьDOM;
	ЗаписьDOM_.КонфигурацияDOM.УстановитьПараметр("xml-declaration", ЗаписыватьДекларациюXML);
	ЗаписьDOM_.КонфигурацияDOM.УстановитьПараметр("discard-default-content", Истина);
	
	// Сохраним в строку ПараметрыSOAP_.
	ЗаписьDOM_.Записать(УзелDOM, ЗаписьXML_);
	
	СтрокаXML_ = ЗаписьXML_.Закрыть();
	
	Возврат СтрокаXML_;
	
КонецФункции

Процедура ДобавитьДочернийТег(РодительскийТег, ДочернийТег, ДобавлятьОтступы = Истина) Экспорт
	
	ПозицияЗавершаегоТега_ = СтрНайти(РодительскийТег, "</", НаправлениеПоиска.СКонца);
	
	// Определим символ отступа в зависимости от параметра ДобавлятьОтступы.
	СимволОтступа_ = "";
	Если Истина = ДобавлятьОтступы Тогда
		СимволОтступа_ = Символы.Таб;
	КонецЕсли;
	
	// Дочерний тег не должен завершаться переводом строки, тогда следующая конструкция
	// сформирует "красивый" XML с правильными табуляциями, если исходные РодительскийТег
	// и ДочернийТег тоже были "красивыми".
	РодительскийТег = СтрШаблон(
		"%1%2%3
		|%4",
		Сред(РодительскийТег, 1, ПозицияЗавершаегоТега_ - 1),
		СимволОтступа_,
		СтрЗаменить(ДочернийТег, Символы.ПС, Символы.ПС + СимволОтступа_),
		Сред(РодительскийТег, ПозицияЗавершаегоТега_)
	);
	
КонецПроцедуры

Функция ЗаменитьТекстВнутриТега(СтрокаXML, ДокументDOM, XPathКТегу, РазыменовательПИ, Текст) Экспорт
	
	DOM_ = ДокументDOM;
	Если Неопределено = DOM_ Тогда
		DOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(СтрокаXML);
	КонецЕсли;
	
	// Подготовим и выполним запрос XPath для извлечения текстового содержимого тега.
	XPath_    = XPathКТегу + "/text()";
	СтарыйТекст_  = ФедеральныеВебСервисыСервер.ПолучитьСтрокуПоXPath(DOM_, РазыменовательПИ, XPath_);
	
	// Если текст соответствует желаемому, то ничего делать не надо.
	Если СтарыйТекст_ = Текст Тогда
		Возврат СтрокаXML;
	КонецЕсли;
	
	// Выполним запрос XPath для получения тега, в котором надо заменить текстовое содержимое.
	Тип_ = ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел;
	РезультатXPath_ = DOM_.ВычислитьВыражениеXPath(XPathКТегу, DOM_, РазыменовательПИ, Тип_);
	ЭлементТега_ = РезультатXPath_.ОдиночныйУзелЗначение;
	
	__ТИП__(ЭлементТега_, "ЭлементDOM", "В пакете отсутствует тег, соответствующий выражению XPath %1.", XPathКТегу);
	
	// Заменим идентификатор на правильный.
	Если Неопределено = ЭлементТега_.ПервыйДочерний Тогда
		ТекстDOM_ = DOM_.createTextNode(Текст);
		ЭлементТега_.appendChild(ТекстDOM_);
	Иначе
		ЭлементТега_.firstChild.nodeValue = Текст;
	КонецЕсли;
	
	// Выгрузим модифицированный DOM в строку.
	НовоеСообщение_ = ФедеральныеВебСервисыСервер.ЗаписатьDOM(DOM_);
	
	Возврат НовоеСообщение_;
	
КонецФункции

/// Проверка существования заданной ссылки в информационной базе.
//
// При отсутствии ссылки в базе, будет выдано исключение.
//
// Параметры:
//   Ссылка - ЛюбаяСсылка -
//     Ссылка на объект информационной базы.
///
Функция ПроверитьСуществованиеСсылки(Ссылка, ВызыватьИсключение = Истина) Экспорт
	
	Запрос_ = Новый Запрос(
		СтрШаблон(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Ссылка
			|ИЗ
			|	%1
			|ГДЕ
			|	Ссылка = &Ссылка",
			Ссылка.Метаданные().ПолноеИмя()
		)
	);
	Запрос_.УстановитьПараметр("Ссылка", Ссылка);
	
	РезультатЗапроса_ = Запрос_.Выполнить();
	
	Успех_ = Не РезультатЗапроса_.Пустой();
	
	Если Истина = ВызыватьИсключение Тогда
		__ПРОВЕРКА__(Успех_, СтрШаблон("Ссылка не найдена в информационной базе: %1.", Строка(Ссылка.УникальныйИдентификатор())));
	КонецЕсли;
	
	Возврат Успех_;
	
КонецФункции

/// Отправка сообщения SOAP по адресу, указанному в теге <ReplyTo> заголовка
//
// Параметры:
//   СообщениеSOAP - Строка -
//     Строка XML сообщения SOAP.
//   Заголовок - Строка -
//     Строка XML заголовка сообщения SOAP, в ответ на который отправляется данное сообщение.
///
Процедура ОтправитьСообщениеSOAPНаReplyTo(СообщениеSOAP, ЗаголовокЗапросаSOAP) Экспорт
	
	АдресДляОтвета_ = ПолучитьАдресДляОтвета(ЗаголовокЗапросаSOAP);
	
	ОтправитьСообщениеSOAP(СообщениеSOAP, АдресДляОтвета_);
	
КонецПроцедуры

Функция ПолучитьАдресДляОтвета(ЗаголовокЗапросаSOAP) Экспорт
	
	// Адрес для ответа нужно брать из заголовка запроса SOAP. Для этого прочитаем заголовок
	// в DOM и с помощью XPath извлечем адрес для ответа.
	ДокументDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(ЗаголовокЗапросаSOAP);
	
	КорневойЭлемент_ = ДокументDOM_.ЭлементДокумента;
	
	// Для запросов XPath обязательно требуется разыменователь.
	ПИ_ = ФедеральныеВебСервисыПовтИсп.РазыменовательПИSOAP(КорневойЭлемент_.URIПространстваИмен);
	
	// Получим адрес для ответа.
	XPath_ = "/soap:Header/wsa:ReplyTo/wsa:Address/text()";
	АдресДляОтвета_ = ПолучитьСтрокуПоXPath(ДокументDOM_, ПИ_, XPath_);
	
	__ПРОВЕРКА__(ЗначениеЗаполнено(АдресДляОтвета_), "Не заполнен тег <ReplyTo> запроса SOAP. %1%2", Символы.ПС, ЗаголовокЗапросаSOAP);
	
	Возврат АдресДляОтвета_;
	
КонецФункции

/// Отправка сообщения SOAP по указанному адресу
//
// Параметры:
//   СообщениеSOAP - Строка -
//     Строка XML сообщения SOAP.
//   АдресДляОтправки - Строка -
//     Адрес, на который нужно отправить сообщение.
//   Заголовок - Строка, Неопределено -
//     Строка XML заголовка сообщения SOAP, в ответ на который отправляется данное сообщение.
//   Фоново - Булево -
//     Признак, что сообщение нужно отправить в фоновом режиме.
//
// Возвращаемое значение:
//   Строка, Булево, Неопределено -
//     Строка ответа, если запрос отправляется не в фоновом задании и получен ответ с кодом 200.
//     Ложь, если запрос отправлялся не в фоновом задании и не получен ответ с кодом 200.
//     Неопределено, если запрос отправлялся в фоновом задании.
///
Функция ОтправитьСообщениеSOAP(СообщениеSOAP, АдресДляОтправки, ЗаголовокSOAP = Неопределено, Фоново = Ложь) Экспорт
	
	// Если вызов синхронный, перенаправляем выполнение сразу в функцию обработки.
	Если Не Истина = Фоново Тогда
		Возврат
			ФедеральныеВебСервисыСервер.
			ОтправитьСообщениеSOAPСлужебный(
				СообщениеSOAP, АдресДляОтправки, ЗаголовокSOAP
			)
		;
	КонецЕсли;
	
	// Подготовим параметры процедуры, которая будет вызываться в фоновом задании.
	ПараметрыПроцедуры_ = Новый Массив;
	ПараметрыПроцедуры_.Добавить(СообщениеSOAP);
	ПараметрыПроцедуры_.Добавить(АдресДляОтправки);
	ПараметрыПроцедуры_.Добавить(ЗаголовокSOAP);
	
	// Запускаем выполнение процедуры обработки в фоновом задании.
	ИмяПроцедуры_ = "ФедеральныеВебСервисыСервер.ОтправитьСообщениеSOAPСлужебный";
	ФоновыеЗадания.Выполнить(ИмяПроцедуры_, ПараметрыПроцедуры_, , ИмяПроцедуры_);
	
КонецФункции

Функция ОтправитьСообщениеSOAPСлужебный(СообщениеSOAP, АдресДляОтправки, Знач ЗаголовокSOAP = Неопределено) Экспорт
	
	__ПРОВЕРКА__(ЗначениеЗаполнено(АдресДляОтправки), "1557e32c-58f5-11e8-9753-080027536468: Не указан адрес для отправки сообщения. Возможно не задана константа. " + Символы.ПС + СообщениеSOAP);
	
	// Функция могла быть вызвана менеджером фоновых заданий.
	// Поскольку роль ФедеральныеВебСервисы не обладает правами,
	// и все действия выполняются в привилегированном режиме,
	// а привилегированный режим при запуске фонового задания
	// не сохраняется, установим его явно.
	УстановитьПривилегированныйРежим(Истина);
	
	// Для корректного создания конверта нам нужно знать версию SOAP.
	// Если в заголовке указана другая версия SOAP, возьмем её оттуда.
	xmlns_soap_ = xmlns.soap();
	
	// При необходимости, внесем изменения в заголовок.
	Если ЗначениеЗаполнено(ЗаголовокSOAP) Тогда
		
		ЗаголовокDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(ЗаголовокSOAP);
		
		// Определим пространство имен SOAP.
		xmlns_soap_ = ЗаголовокDOM_.ЭлементДокумента.URIПространстваИмен;
		
		// Найдем тег <wsa:To> и изменим его содержимое.
		ПИ_ = Новый РазыменовательПространствИменDOM("wsa", xmlns.wsa());
		Тип_ = ТипРезультатаDOMXPath.ЛюбойНеупорядоченныйУзел;
		РезультатXPath_ = ЗаголовокDOM_.ВычислитьВыражениеXPath("//wsa:To", ЗаголовокDOM_, ПИ_, Тип_);
		Узел_wsaTo_ = РезультатXPath_.ОдиночныйУзелЗначение;
		Если Не Неопределено = Узел_wsaTo_ Тогда
			Узел_wsaTo_.ПервыйДочерний.ЗначениеУзла = АдресДляОтправки;
			ЗаголовокSOAP = ФедеральныеВебСервисыСервер.ЗаписатьDOM(ЗаголовокDOM_);
		КонецЕсли;
		
	КонецЕсли;
	
	// На основе шаблона конверта
	ШаблонКонверта_ =
		"<soap:Envelope xmlns:soap=""%1"">
		|</soap:Envelope>"
	;
	// создадим конверт SOAP.
	Конверт_ = СтрШаблон(
		ШаблонКонверта_,
		xmlns_soap_
	);
	
	// Если задан, добавим в него заголовок
	Если ЗначениеЗаполнено(ЗаголовокSOAP) Тогда
		ДобавитьДочернийТег(Конверт_, ЗаголовокSOAP);
	КонецЕсли;
	
	// Сформируем тело ответа.
	ТелоОтвета_ = 
		"<soap:Body>
		|</soap:Body>"
	;
	ДобавитьДочернийТег(ТелоОтвета_, СообщениеSOAP, Ложь);
	
	// Добавим тело ответа в конверт.
	ДобавитьДочернийТег(Конверт_, ТелоОтвета_, Ложь);
	
	// Если нужно, подпишем сообщение.
	Сертификат_ =
		ФедеральныеВебСервисыЭлектроннаяПодпись.
		ПолучитьСертификатДляПодписиКонвертаSOAP(
			АдресДляОтправки
		)
	;
	Если ЗначениеЗаполнено(Сертификат_) Тогда
		Конверт_ = ФедеральныеВебСервисыЭлектроннаяПодпись.ПодписатьSoapСообщение(Конверт_, Сертификат_);
	КонецЕсли;
	
	// Разложим Адрес для ответа в структуру.
	СтруктураURI_ = СтруктураURI(АдресДляОтправки);
	
	__ПОЛЯ__(СтруктураURI_, "Схема, Логин, Пароль, ИмяСервера, Хост, Порт, ПутьНаСервере", "7ee7b944-485a-11e8-b229-080027536468");
	
	// Из полей вычленим адрес сервера
	АдресСервера_ = СтрШаблон("%1://%2", СтруктураURI_.Схема, СтруктураURI_.ИмяСервера);
	// и ресурс на сервере.
	РесурсНаСервере_ = СтрШаблон("/%1", СтруктураURI_.ПутьНаСервере);
	
	// Установим соединение с сервером.
	СоединениеHTTP_ = УстановитьСоединениеССерверомИнтернета(АдресДляОтправки);
	
	// Если не удалось установить соединение, сообщим об ошибке и завершим работу.
	Если СоединениеHTTP_ = Неопределено Тогда
		ТекстОшибки_ =
			"Не удалось установить соединение с сервером"
		;
		Сообщить(ТекстОшибки_);
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			,
			СтрШаблон(
				"Ошибка соединения с сервером %1.
				|%2",
				АдресСервера_,
				ТекстОшибки_
			)
		);
		Возврат Ложь;
	КонецЕсли;
	
	Результат_ = Ложь;
	
	Попытка
		
		HTTPЗапрос_ = Новый HTTPЗапрос(РесурсНаСервере_);
		HTTPЗапрос_.УстановитьТелоИзСтроки(Конверт_);
		
		РазмерСообщения_ = HTTPЗапрос_.ПолучитьТелоКакДвоичныеДанные().Размер();
		РазмерСтрокой_ = Формат(РазмерСообщения_, "ЧН=; ЧГ=");
		
		ЗаголовкиHTTP_ = HTTPЗапрос_.Заголовки;
		ЗаголовкиHTTP_.Вставить("Content-Type", "text/xml; charset=utf-8");
		ЗаголовкиHTTP_.Вставить("Proxy-Connection", "Keep-Alive");
		ЗаголовкиHTTP_.Вставить("Content-Length", РазмерСтрокой_);
		
		ЗаписатьВЖурналРегистрации(HTTPЗапрос_);
		
		HTTPОтвет_ = СоединениеHTTP_.ОтправитьДляОбработки(HTTPЗапрос_);
		
		ЗаписатьВЖурналРегистрации(HTTPОтвет_);
		
		// Если получен корректный ответ, вытащим из него тело запроса SOAP.
		Если HTTPОтвет_.КодСостояния = 200 Тогда
			
			ТелоКакСтрока_ = HTTPОтвет_.ПолучитьТелоКакСтроку();
			
			ДокументDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(ТелоКакСтрока_);
			
			// Для начала с помощью XPath определим версию SOAP. Для этого нам потребуется какой-нибудь
			soap_ = ФедеральныеВебСервисыСервер.ПолучитьСтрокуПоXPath(ДокументDOM_, , "namespace-uri(/*)");
			
			__ПРОВЕРКА__(soap_ = xmlns.soap() Или soap_ = xmlns.soap("1.2"), СтрШаблон("c6065752-49fb-11e8-913f-080027536468 Неожиданное пространство имен SOAP: %1.", soap_));
			
			// Выполим запрос XPath.
			РезультатXPath_ = ДокументDOM_.ВычислитьВыражениеXPath(
				"/soap:Envelope/soap:Body/*",
				ДокументDOM_,
				Новый РазыменовательПространствИменDOM("soap", soap_),
				ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел
			);
			// Из результата берем первый найденный узел.
			ПараметрыSOAP_ = РезультатXPath_.ОдиночныйУзелЗначение;
			
			// Получим параметры SOAP в строковом виде.
			Результат_ = ФедеральныеВебСервисыСервер.ЗаписатьDOM(ПараметрыSOAP_);
			
			// Выполим запрос XPath.
			РезультатXPath_ = ДокументDOM_.ВычислитьВыражениеXPath(
				"/soap:Envelope/soap:Header",
				ДокументDOM_,
				Новый РазыменовательПространствИменDOM("soap", soap_),
				ТипРезультатаDOMXPath.ПервыйУпорядоченныйУзел
			);
			// Из результата берем первый найденный узел.
			Заголовок_ = РезультатXPath_.ОдиночныйУзелЗначение;
			
			// Заголовок может оказаться незаполненным.
			Если Не Неопределено = Заголовок_ Тогда
				Результат_ = Новый Структура(
					"КодСостояния, Тело, Заголовок",
					200,
					Результат_,
					ФедеральныеВебСервисыСервер.ЗаписатьDOM(Заголовок_)
				);
			КонецЕсли;
			
		Иначе
			
			Результат_ = Новый Структура(
				"КодСостояния, Тело",
				HTTPОтвет_.КодСостояния, HTTPОтвет_.ПолучитьТелоКакСтроку()
			);
			
		КонецЕсли;
		
	Исключение
		
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			АдресДляОтправки,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
		);
		
	КонецПопытки;
	
	// Проверим, что XML соответствует схеме.
	// Сделаем это после отправки и получения ответа, чтобы логика работы не страдала,
	// поскольку валидация - вещь не быстрая, да и не очень надежная.
	ВалидацияXML(СообщениеSOAP);
	
	Возврат Результат_;
	
КонецФункции

Функция ПолучитьТелоОтвета(Ответ_) Экспорт
	
	// Ответом может быть Ложь, Строка или Структура с полем Тело.
	
	ТелоОтвета_ = Неопределено;
	
	Если ТипЗнч(Ответ_) = Тип("Строка") Тогда
		ТелоОтвета_ = Ответ_;
		
	ИначеЕсли ТипЗнч(Ответ_) = Тип("Структура") И Ответ_.КодСостояния = 200 Тогда
		ТелоОтвета_ = Ответ_.Тело;
		
	КонецЕсли;
	
	Возврат ТелоОтвета_;
	
КонецФункции

Функция ПроверитьДоступностьВебСервиса(АдресWSDL, ПространствоИмен, ЭлементыОпераций) Экспорт
	
	// Разложим Адрес для ответа в структуру.
	СтруктураURI_ = СтруктураURI(АдресWSDL);
	
	__ПОЛЯ__(СтруктураURI_, "Схема, Логин, Пароль, ИмяСервера, Хост, Порт, ПутьНаСервере", "5114dbb6-9f83-11e8-aafc-080027536468");
	
	// Из полей вычленим адрес сервера
	АдресСервера_ = СтрШаблон("%1://%2", СтруктураURI_.Схема, СтруктураURI_.ИмяСервера);
	// и ресурс на сервере.
	РесурсНаСервере_ = СтрШаблон("/%1", СтруктураURI_.ПутьНаСервере);
	
	// Установим соединение с сервером.
	СоединениеHTTP_ = УстановитьСоединениеССерверомИнтернета(АдресСервера_);
	
	// Если не удалось установить соединение, сообщим об ошибке и завершим работу.
	Если СоединениеHTTP_ = Неопределено Тогда
		Возврат СтрШаблон("Не удалось установить соединение с сервером по адресу %1.", АдресWSDL);
	КонецЕсли;
	
	Попытка
		
		HTTPЗапрос_ = Новый HTTPЗапрос(РесурсНаСервере_);
		
		ЗаголовкиHTTP_ = HTTPЗапрос_.Заголовки;
		ЗаголовкиHTTP_.Вставить("Proxy-Connection", "Keep-Alive");
		
		ЗаписатьВЖурналРегистрации(HTTPЗапрос_);
		
		HTTPОтвет_ = СоединениеHTTP_.Получить(HTTPЗапрос_);
		
		ЗаписатьВЖурналРегистрации(HTTPОтвет_);
		
		// Если получен корректный ответ, вытащим из него тело запроса SOAP.
		Если Не HTTPОтвет_.КодСостояния = 200 Тогда
			ШаблонСообщения_ =
				"Адрес: %1
				|Код состояния: %2
				|%3"
			;
			Тело_ = HTTPОтвет_.ПолучитьТелоКакСтроку();
			Возврат СтрШаблон(ШаблонСообщения_, АдресWSDL, HTTPОтвет_.КодСостояния, Тело_);
			
		КонецЕсли;
		
		Результат_ = HTTPОтвет_.ПолучитьТелоКакСтроку();
		
		DOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(Результат_);
		
		СоответствиеПИ_ = Новый Соответствие;
		СоответствиеПИ_.Вставить("wsdl", xmlns.wsdl());
		СоответствиеПИ_.Вставить("xs", xmlns.xs());
		ПИ_ = Новый РазыменовательПространствИменDOM(СоответствиеПИ_);
		
		Тип_ = ТипРезультатаDOMXPath.ЛюбойНеупорядоченныйУзел;
		
		ШаблонXPath_ = СтрШаблон(
			"/wsdl:definitions/wsdl:types/xs:schema[@targetNamespace='%1']/xs:element[@name='%2']",
			ПространствоИмен,
			"%1"
		);
		
		Ошибки_ = Новый Массив;
		
		Для Каждого ЭлементОперации_ Из ЭлементыОпераций Цикл
			
			XPath_ = СтрШаблон(ШаблонXPath_, ЭлементОперации_);
			РезультатXPath_ = DOM_.ВычислитьВыражениеXPath(XPath_, DOM_, ПИ_, Тип_);
			
			Если Неопределено = РезультатXPath_.ОдиночныйУзелЗначение Тогда
				Ошибки_.Добавить(СтрШаблон("Не найден элемент %1 операции SOAP", ЭлементОперации_));
			КонецЕсли;
			
		КонецЦикла;
		
		Если Не 0 = Ошибки_.Количество() Тогда
			Возврат СтрСоединить(Ошибки_, Символы.ПС);
		КонецЕсли;
		
	Исключение
		Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

/// Валидация XML
//
// Выполняется проверка документа XML на соответствие указанным в нём схемам.
// Процедура не выдает ошибок, но делает запись в журнал регистрации,
// если ошибки были обнаружены.
//
// Параметры:
//   СтрокаXML - Строка -
//     Проверяемый документ XML.
///
Процедура ВалидацияXML(СтрокаXML) Экспорт
	Возврат;
	Попытка
		
		// С помощью запроса XPath получим все элементы и атрибуты документа XML.
		// Для этого подготовим документ DOM, разыменователь пространств имен и тип результата.
		DOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(СтрокаXML);
		ПИ_ = Новый РазыменовательПространствИменDOM(Новый Соответствие);
		Тип_ = ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов;
		
		// Вычислим выражение XPath, возвращающее все элементы и атрибуты документа DOM.
		// В дальнейшем будем извлекать из них пространства имен, для проверки на соответствие
		// схемам XML.
		Рез_ = DOM_.ВычислитьВыражениеXPath("//. | //@*", DOM_, ПИ_, Тип_);
		
		// Для начала получим все пространства имен, которые встречаются в строке XML,
		// и заполним множество URL пространств имен.
		МножествоПИ_ = "";
		
		Пока Истина Цикл
			
			// Извлечем очередной элемент или атрибут.
			Элемент_ = Рез_.ПолучитьСледующий();
			
			// Если элементы кончились, завершаем цикл.
			Если Неопределено = Элемент_ Тогда
				Прервать;
			КонецЕсли;
			
			// Извлекаем пространство имен элемента или атрибута.
			URLПИ_ = Элемент_.URIПространстваИмен;
			
			// Если пространство имен не заполнено (или пустое) или встроенное, пропускаем его.
			Если Ложь
				Или Не ЗначениеЗаполнено(URLПИ_)
				Или URLПИ_ = "http://www.w3.org/2001/XMLSchema-instance"
			Тогда
				Продолжить;
			КонецЕсли;
			
			// Добавим найденный url пространства имен в множество найденных пространств имен,
			// если его там не было ранее.
			Если 0 = СтрНайти(МножествоПИ_, Символы.ПС + URLПИ_ + Символы.ПС) Тогда
				МножествоПИ_ = МножествоПИ_ + Символы.ПС + URLПИ_ + Символы.ПС;
			КонецЕсли;
			
		КонецЦикла;
		
		// Теперь на основе найденных URL пространств имен создадим набор схем XML.
		НаборСхем_ = ФедеральныеВебСервисыПовтИсп.ПолучитьНаборСхемXML(МножествоПИ_);
		
		// Проверим, что набор схем корректен.
		НаборСхем_.Проверить();
		
		// Теперь прочитаем XML, с учетом набора схем.
		ЧтениеXML_ = Новый ЧтениеXML;
		ПараметрыЧтенияXML_ = Новый ПараметрыЧтенияXML(,,,ТипПроверкиXML.СхемаXML);
		ЧтениеXML_.УстановитьСтроку(СтрокаXML, ПараметрыЧтенияXML_, НаборСхем_);
		// Вот здесь, собственно, выполняется валидация xml.
		ЧтениеXML_.Прочитать();
		ЧтениеXML_.Закрыть();
		
	Исключение
		
		// Если валидация по какой-то причине не прошла, то запишем это в журнал регистрации.
		// Работу программы прерывать не будем.
		Ошибка_ = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			СтрокаXML,
			Ошибка_
		);
		
	КонецПопытки;
	
КонецПроцедуры

/// Запись в журнал регистрации HTTP запроса или ответа.
//
// Параметры:
//   Объект - HTTPСервисЗапрос, HTTPСервисОтвет, HTTPЗапрос, HTTPОтвет -
//     HTTP запрос или HTTP ответ.
///
Процедура ЗаписатьВЖурналРегистрации(Объект) Экспорт
	
	// Уровень журнала регистрации по умолчанию - Примечание.
	// Но если код состояния ответа будет отличен от 200, уровень изменим на Ошибка.
	УровеньЖурналаРегистрации_ = УровеньЖурналаРегистрации.Примечание;
	
	ЛокальныйURL_ = "";
	
	// HTTP запрос и HTTP ответ различаются строкой состояния. Обработаем их по отдельности.
	Если ТипЗнч(Объект) = Тип("HTTPСервисЗапрос") Тогда
		
		СтрокаПараметров_ = "";
		Разделитель_ = "?";
		
		Для Каждого КлючИЗначение_ Из Объект.ПараметрыЗапроса Цикл
			СтрокаПараметров_ = СтрШаблон(
				"%1%2%3=%4",
				СтрокаПараметров_,
				Разделитель_,
				КлючИЗначение_.Ключ,
				КлючИЗначение_.Значение
			);
			Разделитель_ = "&";
		КонецЦикла;
		
		ЛокальныйURL_ = СтрШаблон(
			"%2%3%4",
			Объект.БазовыйURL,
			Объект.ОтносительныйURL,
			СтрокаПараметров_
		);
		
		СтрокаСостояния_ = СтрШаблон(
			"%1 %2 HTTP/1.1",
			Объект.HTTPМетод,
			ЛокальныйURL_
		);
		
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPЗапрос") Тогда
		
		ЛокальныйURL_ = Объект.АдресРесурса;
		
		СтрокаСостояния_ = СтрШаблон(
			"POST %1 HTTP/1.1",
			Объект.АдресРесурса
		);
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPСервисОтвет") Тогда
		
		СтрокаСостояния_ = СтрШаблон(
			"HTTP/1.1 %1 %2",
			Объект.КодСостояния,
			Объект.КодСостояния
		);
		Если Не 200 = Объект.КодСостояния Тогда
			УровеньЖурналаРегистрации_ = УровеньЖурналаРегистрации.Ошибка;
		КонецЕсли;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPОтвет") Тогда
		
		СтрокаСостояния_ = СтрШаблон(
			"HTTP/1.1 %1 %2",
			Объект.КодСостояния,
			Объект.КодСостояния
		);
		Если Не 200 = Объект.КодСостояния Тогда
			УровеньЖурналаРегистрации_ = УровеньЖурналаРегистрации.Ошибка;
		КонецЕсли;
		
	// Для тестирования
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
		
		СтрокаСостояния_ = СтрШаблон(
			"__ТЕСТ__ %1",
			Объект.ОтносительныйURL
		);
		
	Иначе
		
		__ПРОВЕРКА__(Ложь, "f27c3518-484d-11e8-ac2e-080027536468");
		
	КонецЕсли;
	
	// Далее сформируем строку заголовков.
	СтрокаЗаголовков_ = "";
	Для Каждого КлючИЗначение_ Из Объект.Заголовки Цикл
		СтрокаЗаголовков_ = СтрШаблон(
			"%1%2%3%4: %5",
			СтрокаЗаголовков_,
			Символы.ВК,
			Символы.ПС,
			КлючИЗначение_.Ключ,
			КлючИЗначение_.Значение
		);
	КонецЦикла;
	
	// Осталось взять тело запроса или ответа.
	Если ТипЗнч(Объект) = Тип("Структура") Тогда
		// Для тестирования.
		Тело_ = Объект.ТелоКакСтрока;
	Иначе
		Тело_ = Объект.ПолучитьТелоКакСтроку();
	КонецЕсли;
	
	// Теперь сформируем комментарий для журнала регистрации.
	Комментарий_ = СтрШаблон(
		"%1%2%3%4%5%6%7",
		СтрокаСостояния_,
		СтрокаЗаголовков_,
		Символы.ВК,
		Символы.ПС,
		Символы.ВК,
		Символы.ПС,
		Тело_
	);
	
	// Определимся с именем события журнала регистрации.
	Если ТипЗнч(Объект) = Тип("HTTPСервисЗапрос") Тогда
		ИмяСобытия_ = "ФедеральныеВебСервисы.Запрос.Входящий";
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPЗапрос") Тогда
		ИмяСобытия_ = "ФедеральныеВебСервисы.Запрос.Исходящий";
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPСервисОтвет") Тогда
		ИмяСобытия_ = "ФедеральныеВебСервисы.Ответ.Исходящий";
		
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPОтвет") Тогда
		ИмяСобытия_ = "ФедеральныеВебСервисы.Ответ.Входящий";
		
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура") Тогда
		ИмяСобытия_ = "ФедеральныеВебСервисы.Запрос.Входящий.ТЕСТ";
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Тело_) Тогда
		ТегПараметровSOAP_ = ОпределитьТегПараметровЗапросаSOAP(Тело_);
		Если ЗначениеЗаполнено(ТегПараметровSOAP_) Тогда
			ИмяСобытия_ = ИмяСобытия_ + "." + ТегПараметровSOAP_;
		КонецЕсли;
		ТегПараметровSOAP_ = СтрШаблон("<%1/>", ТегПараметровSOAP_);
	Иначе
		ТегПараметровSOAP_ = ЛокальныйURL_;
	КонецЕсли;
	
	// Наконец-то мы можем сделать запись в журнал регистрации.
	ЗаписьЖурналаРегистрации(
		ИмяСобытия_, УровеньЖурналаРегистрации_, , ТегПараметровSOAP_, Комментарий_
	);
	
КонецПроцедуры

Функция ДатаВФорматеXML(Дата) Экспорт
	
	ЧасовойПояс_ = ФедеральныеВебСервисыПовтИсп.ПолучитьЧасовойПоясСтрокой();
	// затем преобразовав в строку в формате xml:date
	ДатаВремяСтрокой_ = Формат(Дата, "ДФ=yyyy-MM-ddTHH:mm:ss; ДП=");
	// и напоследок добавив часовой пояс.
	ДатаВремяЧасовойПояс_ = ДатаВремяСтрокой_ + ЧасовойПояс_;
	
	Возврат ДатаВремяЧасовойПояс_;
	
КонецФункции

Процедура ДобавитьВНаборСхем(НаборСхем, МассивПространствИмен, ИндексВМассиве) Экспорт
	
	// Выбираем искомое пространство имен из массива.
	ПространствоИмен_ = МассивПространствИмен[ИндексВМассиве];
	
	// Текстом файла со схемой может быть содержимое xsd файла, описание wsdl или содержимое
	// любого другого документа XML, содержащего тег <xs:schema>.
	ТекстФайлаСоСхемой_ = ФедеральныеВебСервисыПовтИсп.ПолучитьТекстФайлаСоСхемой(ПространствоИмен_);
	
	// Для выполнения запросов XPath нам потребуется разыменователь с пространством имен xs.
	ПИ_ = Новый РазыменовательПространствИменDOM("xs", xmlns.xs());
	
	// Также нам потребуется следующий тип результата XPath.
	ТипРезультата_ = ТипРезультатаDOMXPath.ЛюбойНеупорядоченныйУзел;
	
	// Для выбора схемы будем использовать такой запрос XPath.
	XPath_СхемаXML_ = СтрШаблон("//xs:schema[@targetNamespace='%1']", ПространствоИмен_);
	
	КолВо_ = -1;
	Если ТипЗнч(ТекстФайлаСоСхемой_) = Тип("Массив") Тогда
		КолВо_ = ТекстФайлаСоСхемой_.Количество();
	КонецЕсли;
	
	Для Индекс_ = 0 По ?(КолВо_ < 0, 0, КолВо_ - 1) Цикл
		
		// Преобразуем описание WSDL в DOM для выполнения запросов XPath.
		ДокументDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(
			?(КолВо_ < 0, ТекстФайлаСоСхемой_, ТекстФайлаСоСхемой_[Индекс_])
		);
		
		// Выполним запрос XPath.
		РезультатXPath_ =
			ДокументDOM_.ВычислитьВыражениеXPath(XPath_СхемаXML_, ДокументDOM_, ПИ_, ТипРезультата_)
		;
		// Результатом запроса XPath должен быть корневой узел схемы.
		КорневойУзелСхемы_ = РезультатXPath_.ОдиночныйУзелЗначение;
		
		// В схеме могут встречаться теги <xs:import> и <xs:include>, в которых атрибут
		// schemaLocation ссылается на недоступное место. Когда платформа 1С:Предприятие выполняет
		// проверку на соответствие xml схеме, она пытается загрузить внешние схемы, указанные в
		// этих тегах. Подождав некоторое время (несколько десятков секунд) и не получив ответ,
		// платформа выдает ошибку. Чтобы этого не происходило, удалим из тегов <xs:import> и
		// <xs:include> атрибут schemaLocation. Для этого также используем XPath.
		ШаблонXPath_ = "./*[(local-name()='import' or local-name()='include') and namespace-uri()='%1']";
		XPath_ = СтрШаблон(ШаблонXPath_, xmlns.xs());
		РезультатXPath_ =
			ДокументDOM_.ВычислитьВыражениеXPath(
				XPath_, КорневойУзелСхемы_, ПИ_, ТипРезультатаDOMXPath.НеупорядоченныйИтераторУзлов
			)
		;
		Узел_ = РезультатXPath_.ПолучитьСледующий();
		Пока Не Неопределено = Узел_ Цикл
			Если Узел_.ЕстьАтрибут("namespace") Тогда
				// Заодно добавим импортируемое пространство имен в массив пространств имен.
				ДополнительноеПИ_ = Узел_.ПолучитьАтрибут("namespace");
				Если Неопределено = МассивПространствИмен.Найти(ДополнительноеПИ_) Тогда
					МассивПространствИмен.Добавить(ДополнительноеПИ_);
				КонецЕсли;
			КонецЕсли;
			Если Узел_.ЕстьАтрибут("schemaLocation") Тогда
				Узел_.УдалитьАтрибут("schemaLocation");
			КонецЕсли;
			Узел_ = РезультатXPath_.ПолучитьСледующий();
		КонецЦикла;
		
		// Для создания схемы используем построитель схем.
		ПостроительСхем_ = Новый ПостроительСхемXML;
		// Собственно, создаем схему.
		СхемаXML_ = ПостроительСхем_.СоздатьСхемуXML(КорневойУзелСхемы_);
		
		// Теперь нужно обновить ДОМ схемы, иначе манипуляции с тегами <xs:import> и <xs:include>
		// не будут учтены. Можно просто удалить его.
		СхемаXML_.ДокументDOM = Неопределено;
		
		// Добавляем схему в набор.
		НаборСхем.Добавить(СхемаXML_);
		
	КонецЦикла;
	
КонецПроцедуры

/// Истина, если в сеансе обрабатывается запрос от федерального веб-сервиса
//
// Полезно вызывать фукнцию в привилегированном режиме.
Функция ЭтоОбработкаЗапросаSOAP() Экспорт
	
	Возврат (Истина = ПараметрыСеанса.ФедеральныеВебСервисыЭтоОбработкаЗапроса);
	
КонецФункции

/// Установка признака обработки запроса от федерального веб-сервиса
Процедура НачалоОбработкиЗапросаSOAP() Экспорт
	
	// Параметр сеанса устанавливаем в привилегированном режиме, поскольку собственно обработка
	// запроса, которая выполняется в привилегированном режиме, могла еще не начаться.
	УстановитьПривилегированныйРежим(Истина);
	
	ПараметрыСеанса.ФедеральныеВебСервисыЭтоОбработкаЗапроса = Истина;
	
КонецПроцедуры

Функция СтруктураURI(АдресДляОтправки) Экспорт
	
	// Если подсистема работает в составе конфигурации "1С:Медицина", то переадресуем вызов
	// в общий модуль ОбщегоНазначенияКлиентСервер.
	Если Не Неопределено = Метаданные.ОбщиеМодули.Найти("ОбщегоНазначенияКлиентСервер") Тогда
		ОписаниеОшибки_ = "";
		Возврат Вычислить(
			"ОбщегоНазначенияКлиентСервер.СтруктураURI(АдресДляОтправки)"
		);
	КонецЕсли;
	
	// Следующий код скопирован из общего модуля ОбщегоНазначенияКлиентСервер.
	
	СтрокаURI = СокрЛП(АдресДляОтправки);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не СтрРазделить(Порт, "0123456789", Ложь).Количество() = 0 Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

/// Получение значения константы ФедеральныеВебСервисыИдентификаторРМИСвКУФЭР.
//
// Возвращаемое значение:
//   Строка - идентификатор РМИС в КУ ФЭР.
///
Функция ПолучитьИдентификаторРМИСвКУФЭР() Экспорт
	
	ЗначениеКонстанты_ = КешСеанса.ПолучитьЗначение(
		"ФедеральныеВебСервисыСервер.ПолучитьКонстанту",
		"ФедеральныеВебСервисыИдентификаторРМИСвКУФЭР"
	);
	
	Возврат ЗначениеКонстанты_;
	
КонецФункции

// Возвращает значение константы
//
// Параметры:
//  ИмяКонстанты - Строка	 - Имя константы
// 
// Возвращаемое значение:
//   - 
//
Функция ПолучитьКонстанту(ИмяКонстанты) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборКонстант_ = Константы.СоздатьНабор(ИмяКонстанты);
	НаборКонстант_.Прочитать();
	
	Возврат НаборКонстант_[ИмяКонстанты];
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ОпределитьТегПараметровЗапросаSOAP(Тело)
	
	Попытка
		
		ДокументDOM_ = ФедеральныеВебСервисыСервер.ПостроитьDOM(Тело);
		
		// Для начала с помощью XPath определим версию SOAP.
		soap_ = ФедеральныеВебСервисыСервер.ПолучитьСтрокуПоXPath(ДокументDOM_, , "namespace-uri(/*)");
		
		// Далее будем выполнять запросы XPath. Для этого нам потребуется разыменователь.
		ПИ_ = Новый РазыменовательПространствИменDOM("soap", soap_);
		
		// С помощью XPath определим имя тега.
		XPath_ = "local-name(/soap:Envelope/soap:Body/*)";
		ИмяТега_ = ФедеральныеВебСервисыСервер.ПолучитьСтрокуПоXPath(ДокументDOM_, ПИ_, XPath_);
		
		Возврат ИмяТега_;
		
	Исключение
		
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Ошибка",
			УровеньЖурналаРегистрации.Ошибка,
			,
			"Not XML",
			СтрШаблон(
				"%1
				|%2",
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()),
				Тело
			)
		);
		
	КонецПопытки;
	
	Возврат "";
	
КонецФункции

Функция УстановитьСоединениеССерверомИнтернета(URLСервера, ОписаниеОшибки = "") Экспорт
	
	// Если подсистема работает в составе конфигурации "1С:Медицина", то переадресуем вызов
	// в общий модуль ДокументооборотСКО.
	Если Не Неопределено = Метаданные.ОбщиеМодули.Найти("ДокументооборотСКО") Тогда
		ОписаниеОшибки_ = "";
		Возврат Вычислить(
			"ДокументооборотСКО.УстановитьСоединениеССерверомИнтернета(URLСервера, ОписаниеОшибки_)"
		);
	КонецЕсли;
	
	// Если подсистем работает как отдельная конфигурация, сделаем упрощенную реализацию.
	// В упрощенной реализации, в частности, не используются настройки прокси.
	
	СтруктураURI_ = СтруктураURI(URLСервера);
	
	// Если схема не равна https, то тогда считаем, что используется незащищенное соединение.
	Соединение_ = Неопределено;
	Если ЗначениеЗаполнено(СтруктураURI_.Схема) И НРег(СтруктураURI_.Схема) = "https" Тогда
		Соединение_ = Новый ЗащищенноеСоединениеOpenSSL;
	КонецЕсли;
	
	Возврат Новый HTTPСоединение(
		СтруктураURI_.Хост,
		СтруктураURI_.Порт,
		СтруктураURI_.Логин,
		СтруктураURI_.Пароль,
		Неопределено,
		60,
		Соединение_
	);
	
КонецФункции

#КонецОбласти

#Область Юнит_тесты

Процедура __ТЕСТ__(ПроверкаНаличияПроцедуры = Ложь) Экспорт
	
	Если Истина = ПроверкаНаличияПроцедуры Тогда
		Возврат;
	КонецЕсли;
	
	#Область ОпределитьТегПараметровЗапросаSOAP
		
		XML_ = "Не XML";
		Тег_ = ОпределитьТегПараметровЗапросаSOAP(XML_);
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Информация",
			УровеньЖурналаРегистрации.Информация,
			,
			,
			"ОпределитьТегПараметровЗапросаSOAP(""" + XML_ + """) = """ + Тег_ + """"
		);
		
		XML_ = "<Envelope xmlns=""stub""><Body><МоеИмяТега/></Body></Envelope>";
		Тег_ = ОпределитьТегПараметровЗапросаSOAP(XML_);
		ЗаписьЖурналаРегистрации(
			"ФедеральныеВебСервисы.Информация",
			УровеньЖурналаРегистрации.Информация,
			,
			,
			"ОпределитьТегПараметровЗапросаSOAP(""" + XML_ + """) = """ + Тег_ + """"
		);
		
	#КонецОбласти
	
	#Область ВалидацияXML
		
		// Следующий пакет должен проходить валидацию.
		ПакетДляВалидации_ =
			"<ns3:CancelBookingResultRequest
			|		xmlns:ns2=""http://rosminzdrav.ru/fer/concentrator/booking/commons""
			|		xmlns:ns3=""http://rosminzdrav.ru/fer/concentrator/dispensary/callback"">
			|	<requestId>708f4f73-2076-40f1-9ed1-556010fa7d28</requestId>
			|	<error>
			|		<ns2:errorCode>RMIS1</ns2:errorCode>
			|		<ns2:errorMessage>Внутренняя ошибка ИС</ns2:errorMessage>
			|	</error>
			|</ns3:CancelBookingResultRequest>"
		;
		ВалидацияXML(ПакетДляВалидации_);
		
		// А этот пакет не должен проходить валидацию.
		ПакетДляВалидации_ =
			"<ns3:CancelBookingResultRequest
			|		xmlns:ns2=""http://rosminzdrav.ru/fer/concentrator/booking/commons""
			|		xmlns:ns3=""http://rosminzdrav.ru/fer/concentrator/dispensary/callback"">
			|	<requestId>708f4f73-2076-40f1-9ed1-556010fa7d28</requestId>
			|	<ns2:error>
			|		<ns2:errorCode>RMIS1</ns2:errorCode>
			|		<ns2:errorMessage>Внутренняя ошибка ИС</ns2:errorMessage>
			|	</ns2:error>
			|</ns3:CancelBookingResultRequest>"
		;
		ВалидацияXML(ПакетДляВалидации_);
		
	#КонецОбласти
	
КонецПроцедуры

#КонецОбласти
