
#Область СлужебныеПроцедурыИФункции

// Возвращает признак использования сертификатов пользователя в облачном сервисе.
//
// Возвращаемое значение:
//  Булево - флаг использования в сертификатов пользователя в облачном сервисе.
//
Функция ИспользованиеСертификатовОблачногоСервисаВозможно() Экспорт
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МодульНастройкиЭДО = ОбщегоНазначения.ОбщийМодуль("НастройкиЭДО");
	Возврат МодульНастройкиЭДО.ИспользованиеСертификатовОблачногоСервисаВозможно();
		
КонецФункции

// Возвращает отпечатки сертификатов криптографии в облачном сервисе.
//
// Возвращаемое значение:
//   См. КриптографияБЭДКлиентСервер.НовыйРезультатПолученияОтпечатков
Функция ПолучитьОтпечаткиСертификатовВСервисе() Экспорт
	
	РезультатПолучения = КриптографияБЭДКлиентСервер.НовыйРезультатПолученияОтпечатков();
	
	Если Не КриптографияБЭД.ИспользоватьЭлектроннуюПодписьВМоделиСервиса() Тогда
		Возврат РезультатПолучения;
	КонецЕсли;
	
	РезультатПолучения.Доступность = Истина;
	
	ДатаСеанса = ТекущаяДатаСеанса();
	
	Попытка
		МодульХранилищеСертификатов = ОбщегоНазначения.ОбщийМодуль("ХранилищеСертификатов");
		ПерсональныеСертификаты = МодульХранилищеСертификатов.Получить("ПерсональныеСертификаты");
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Получение отпечатков облачных сертификатов'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,,
			ТекстОшибки);
		РезультатПолучения.Ошибка = Истина;
		РезультатПолучения.ТекстОшибки = ТекстОшибки;
		Возврат РезультатПолучения;
	КонецПопытки;
		
	Для Каждого ПерсональныйСертификат Из ПерсональныеСертификаты Цикл
		Если ПерсональныйСертификат.ДатаОкончания <= ДатаСеанса Тогда
			Продолжить; // Пропуск просроченных сертификатов.
		КонецЕсли;

		Отпечаток = Base64Строка(ПерсональныйСертификат.Отпечаток);
		РезультатПолучения.Отпечатки.Добавить(Отпечаток);
	КонецЦикла;
	
	Возврат РезультатПолучения;
	
КонецФункции

// Возвращает отпечатки сертификатов криптографии на сервере.
//
// Параметры:
//   ПоказыватьОшибку  - Булево - если Ложь, то ошибка создания менеджера криптографии не отображается.
//
// Возвращаемое значение:
//   См. КриптографияБЭДКлиентСервер.НовыйРезультатПолученияОтпечатков
Функция ПолучитьОтпечаткиСертификатовНаСервере(ПоказыватьОшибку = Ложь) Экспорт
	
	РезультатПолучения = КриптографияБЭДКлиентСервер.НовыйРезультатПолученияОтпечатков();
	
	Если Не ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере() Тогда
		Возврат РезультатПолучения;
	КонецЕсли;
	
	РезультатПолучения.Доступность = Истина;
	
	МенеджерКриптографии = КриптографияБЭД.МенеджерКриптографии(ПоказыватьОшибку, РезультатПолучения.ТекстОшибки);
	Если МенеджерКриптографии = Неопределено Тогда
		РезультатПолучения.Ошибка = Истина;
		РезультатПолучения.Доступность = Ложь;
		Возврат РезультатПолучения;
	КонецЕсли;
	
	ТекущаяДата = ТекущаяДатаСеанса(); // Используется для выявления истекших сертификатов, которые хранятся на клиентском компьютере.
	
	ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
		ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
	СертификатыХранилища = ХранилищеСертификатовКриптографии.ПолучитьВсе();
	
	Для Каждого Сертификат Из СертификатыХранилища Цикл
		Если Сертификат.ДатаОкончания < ТекущаяДата Тогда
			Продолжить; // Пропуск истекших сертификатов.
		КонецЕсли;
		
		СтрокаОтпечатка = Base64Строка(Сертификат.Отпечаток);
		РезультатПолучения.Отпечатки.Добавить(СтрокаОтпечатка);
		
	КонецЦикла;
	
	Возврат РезультатПолучения;
	
КонецФункции

Функция ДанныеПароляСертификата(Сертификат) Экспорт
	
	Данные = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Сертификат, КлючДанныхПароляСертификата());
	Если Данные = Неопределено Тогда
		Данные = Новый Соответствие;
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Процедура ЗаписатьПарольСертификата(Сертификат, Пароль, Знач Пользователь = Неопределено) Экспорт
	
	Если Пользователь = Неопределено Тогда
		Пользователь = Справочники.Пользователи.ПустаяСсылка();
	КонецЕсли;
	
	Данные = ДанныеПароляСертификата(Сертификат);
	Если Не ЗначениеЗаполнено(Пользователь) Тогда
		Данные = Новый Соответствие;
	КонецЕсли;
	Данные.Вставить(Пользователь, Пароль);
	
	ОбщегоНазначения.ЗаписатьДанныеВБезопасноеХранилище(Сертификат, Данные, КлючДанныхПароляСертификата());
	
КонецПроцедуры

Процедура УдалитьПарольСертификата(Сертификат) Экспорт
	
	ОбщегоНазначения.УдалитьДанныеИзБезопасногоХранилища(Сертификат, КлючДанныхПароляСертификата());
	
КонецПроцедуры

Функция КлючДанныхПароляСертификата()
	
	Возврат "ПаролиСертификатов";
	
КонецФункции

// Обработчик подписки на событие ЗаполнитьВидыЭДДляСертификатаЭП.
//
// Параметры:
//  Источник - СправочникОбъект.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат криптографии;
//  Отказ - Булево - Признак отказа от записи элемента.
//
Процедура ЗаполнитьПодписываемыеВидыДокументовСертификатаПередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	СсылкаНаОбъект = ОбщегоНазначенияБЭД.ПолучитьСсылкуОбъектаБезопасно(Источник);
	Если Источник.ЭтоНовый() Тогда
		РегистрыСведений.ПодписываемыеВидыЭД.СохранитьПодписываемыеВидыЭД(СсылкаНаОбъект);
	КонецЕсли;

КонецПроцедуры

Функция ТекстОшибкиНеправомерногоИспользованияОблачногоСертификата() Экспорт
	
	СообщениеОбОшибке = НСтр("ru = 'Выбранный сертификат связан с недопустимым средством ""облачной"" электронной подписи.
				|Согласно приказу Минфина РФ от 10.11.2015 № 174Н электронные документы должны быть подписаны
				|усиленной квалифицированной электронной подписью с использованием средств электронной подписи,
				|имеющих подтверждение (сертификат) соответствия требованиям, установленным в соответствии с Федеральным законом от 06.04.2011 N 63-ФЗ.
				|Выберите сертификат, связанный с другим средством электронной подписи.'");
	
	Возврат СообщениеОбОшибке;
	
КонецФункции

#Область PKCS7

// Возвращает свойства криптосообщения в формате PKCS #7 в соответствии с https://tools.ietf.org/html/rfc2315.
//
// Параметры:
//   Криптосообщение - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                              при Настройки.ЭтоСтрокаBase64 = Истина) в формате PKCS #7.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ПрочитатьПодписанныеДанные          - Булево - по умолчанию Истина, для типа SignedData возвращать Содержимое.
//     ПрочитатьИздателяИСерийныйНомер     - Булево - по умолчанию Истина, для типа SignedData в Подписанты возвращать
//                                                    Идентификатор, Издатель, СерийныйНомер, Сертификат,
//                                                    для типа EnvelopedData в Получатели возвращать Идентификатор, Издатель,
//                                                    СерийныйНомер.
//     ПрочитатьАлгоритмПубличногоКлюча    - Булево - по умолчанию Ложь, для типа EnvelopedData в Получатели возвращать
//                                                    АлгоритмПубличногоКлюча.
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина Криптосообщение задает строку Base64.
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//    Общие свойства:
//    * Тип - Строка - Unknown - файл неподдерживаемого формат, EnvelopedData - зашифрованные данные, SignedData - подпись.
//    * Размер - Число - размер файла в байтах.
//    
//    Свойства для типа SignedData:
//    * Подписанты - Массив - подписанты сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** Сертификат - ДвоичныеДанные - файл сертификата
//       ** АлгоритмХеширования - Строка - название алгоритма или OID нераспознанного алгоритма.
//       ** АлгоритмПодписи - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                     или OID нераспознанного алгоритма.
//    * Сертификаты - Массив - файлы сертификатов.
//    * СпискиОтзываСертификатов - Массив - файлы списков отзыва сертификатов.
//    * Содержимое - ДвоичныеДанные - подписанные данные для прикрепленной подписи.
//
//    Свойства для типа EnvelopedData:
//    * Получатели - Массив - получатели зашифрованного сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                             или OID нераспознанного алгоритма, возвращается при задании
//                                             Настройки.ПрочитатьАлгоритмПубличногоКлюча = Истина
//
Функция ПолучитьСвойстваКриптосообщения(Знач Криптосообщение, Настройки = Неопределено) Экспорт 
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ПрочитатьПодписанныеДанные", 			Истина);
	НастройкиВызова.Вставить("ПрочитатьИздателяИСерийныйНомер", 	Истина);
	НастройкиВызова.Вставить("ПрочитатьАлгоритмПубличногоКлюча", 	Ложь);
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваКриптосообщения = Новый Структура;
	СвойстваКриптосообщения.Вставить("Тип", "Unknown");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		Криптосообщение = Base64Значение(Криптосообщение);
	ИначеЕсли ТипЗнч(Криптосообщение) = Тип("Строка") И ЭтоАдресВременногоХранилища(Криптосообщение) Тогда
		Криптосообщение = ПолучитьИзВременногоХранилища(Криптосообщение);
	КонецЕсли;
	СвойстваКриптосообщения.Вставить("Размер", Криптосообщение.Размер());
	
	Если Не ЗначениеЗаполнено(СвойстваКриптосообщения.Размер) Тогда
		Возврат СвойстваКриптосообщения;
	КонецЕсли;
	
	ЧтениеДанных = Новый ЧтениеДанных(Криптосообщение);
	Попытка
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); // contentType
		Если Свойства.РазмерБлока > 100 ИЛИ Свойства.РазмерБлока = 0 Тогда // Защита от считывания лишних данных
			ЧтениеДанных.Закрыть();
			Возврат СвойстваКриптосообщения;
		КонецЕсли;
		
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		// PKCS #7: EnvelopedData https://tools.ietf.org/html/rfc2315#section-10.1
		Если Тип = "1.2.840.113549.1.7.3" Тогда
			СвойстваКриптосообщения = ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
			
		// PKCS #7: SignedData https://tools.ietf.org/html/rfc2315#section-9.1	
		ИначеЕсли Тип = "1.2.840.113549.1.7.2" Тогда
			СвойстваКриптосообщения = ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ЧтениеДанных.Закрыть();
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

// Возвращает отдельные свойства сертификата в формате X.509 в соответствие с https://tools.ietf.org/html/rfc5280.
//
// Параметры:
//   ДанныеСертификата - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                                при Настройки.ЭтоСтрокаBase64 = Истина) в формате X.509.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина ДанныеСертификата задает строку Base64.
//     ВозможенФорматBase64                - Булево - по умолчанию Ложь, при Истина двоичные данные в ДанныеСертификата
//                                                    могут быть в формате Base64, в том числе с заголовками сертификата,
//                                                    корректность чтения определяется по прочитанному алгоритму
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//     Размер                  - Число - размер файла в байтах.
//     Версия                  - Число - версия формата сертификата, 0 - v1, 1 - v2, 2 - v3.
//     СерийныйНомер           - ДвоичныеДанные - серийный номер сертификата.
//     АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                        или OID нераспознанного алгоритма.
//
Функция ПолучитьСвойстваСертификата(Знач ДанныеСертификата, Настройки = Неопределено)
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозможенФорматBase64", 				Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваСертификата = Новый Структура;
	СвойстваСертификата.Вставить("Размер", 					0);
	СвойстваСертификата.Вставить("Версия", 					0);
	СвойстваСертификата.Вставить("СерийныйНомер", 			0);
	СвойстваСертификата.Вставить("АлгоритмПубличногоКлюча", "");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		ДанныеСертификата = Base64Значение(ДанныеСертификата);
	ИначеЕсли ТипЗнч(ДанныеСертификата) = Тип("Строка") И ЭтоАдресВременногоХранилища(ДанныеСертификата) Тогда
		ДанныеСертификата = ПолучитьИзВременногоХранилища(ДанныеСертификата);
	КонецЕсли;
	
	СвойстваСертификата.Размер = ДанныеСертификата.Размер();
	
	Если НастройкиВызова.ВозможенФорматBase64 И СвойстваСертификата.Размер < 65536 Тогда
		НастройкиВызова.ЭтоСтрокаBase64 		= Ложь;
		НастройкиВызова.ВозможенФорматBase64 	= Ложь;
		СвойстваСертификата = ПолучитьСвойстваСертификата(ДанныеСертификата, НастройкиВызова);
		
		Если НЕ ЗначениеЗаполнено(СвойстваСертификата.АлгоритмПубличногоКлюча) Тогда
			ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата, "windows-1251");
			Попытка
				ТекстСертификата = ОбъектЧтениеДанных.ПрочитатьСимволы();
			Исключение
				ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
					НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
					НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
				ЗаписьЖурналаРегистрации(
					ИмяСобытия,
					УровеньЖурналаРегистрации.Ошибка,,,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				Если НастройкиВызова.ВозвращатьИсключения Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
			ОбъектЧтениеДанных.Закрыть();
			
			ТекстСертификата = СокрЛП(ТекстСертификата);
			Если СтрНачинаетсяС(ТекстСертификата, "-----BEGIN CERTIFICATE-----")
				И СтрЗаканчиваетсяНа(ТекстСертификата, "-----END CERTIFICATE-----") Тогда
				ДлинаТекстаСертификата = СтрДлина(ТекстСертификата);
				ТекстСертификата = Сред(ТекстСертификата, 28, ДлинаТекстаСертификата - 52);
				ТекстСертификата = СокрЛП(ТекстСертификата);
			КонецЕсли;
			
			НастройкиВызова.ЭтоСтрокаBase64 		= Истина;
			НастройкиВызова.ВозможенФорматBase64 	= Ложь;
			СвойстваСертификата = ПолучитьСвойстваСертификата(ТекстСертификата, НастройкиВызова);
		КонецЕсли;
		
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СвойстваСертификата.Размер) Тогда
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата);
	Попытка
		// https://tools.ietf.org/html/rfc5280#section-4
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // Certificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // TBSCertificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда
			Если СвойстваБлока.Класс <> "CONTEXT-SPECIFIC" ИЛИ СвойстваБлока.Тег <> 0 Тогда // version [0] EXPLICIT Version DEFAULT v1
				ОбъектЧтениеДанных.Закрыть();
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда // Version ::= INTEGER {v1(0), v2(1), v3(2)}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		ВерсияСертификата = ПрочитатьЦелоеЧисло(ОбъектЧтениеДанных, СвойстваБлока);
		Если ВерсияСертификата < 0 ИЛИ ВерсияСертификата > 2 Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.Версия = ВерсияСертификата;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		СвойстваСертификата.СерийныйНомер = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных,
			СвойстваБлока); // serialNumber CertificateSerialNumber ::= INTEGER
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // signature AlgorithmIdentifier = SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // issuer RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // validity Validity ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subject RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subjectPublicKeyInfo SubjectPublicKeyInfo ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // algorithm AlgorithmIdentifier = SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		АлгоритмПубличногоКлюча = ПрочитатьAlgorithmIdentifier(ОбъектЧтениеДанных, СвойстваСертификата, СвойстваБлока, Истина);
		Если АлгоритмПубличногоКлюча = Неопределено Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.АлгоритмПубличногоКлюча = АлгоритмПубличногоКлюча;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ОбъектЧтениеДанных.Закрыть();
	
	Возврат СвойстваСертификата;
	
КонецФункции

#Область ФункцииЧтенияPKCS7

Функция ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	СвойстваКриптосообщения.Вставить("Получатели", ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "EnvelopedData");
	
	Возврат СвойстваКриптосообщения;

КонецФункции

Функция ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// DigestAlgorithmIdentifiers
	ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	
	Если Настройки.ПрочитатьПодписанныеДанные Тогда
		СвойстваКриптосообщения.Вставить("Содержимое", ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения));
	Иначе
		СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	СвойстваКриптосообщения.Вставить("Сертификаты", ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("СпискиОтзываСертификатов", ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("Подписанты", ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "SignedData");
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

Функция ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства = Неопределено, ПроверитьТип = Ложь)
	
	Если Свойства = Неопределено Тогда
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	КонецБлока = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если ПроверитьТип И (Свойства.Класс <> "UNIVERSAL" ИЛИ Свойства.Тег <> 6) Тогда // algorithm OBJECT IDENTIFIER
		Возврат Неопределено;
	КонецЕсли;
	ИдентификаторАлгоритма = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	ОбъектныеИдентификаторы = Новый Соответствие;
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.9", "GOST R 34.11-94");
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.19", "GOST R 34.10-2001");
	
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.1", "GOST R 34.10-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.2", "GOST R 34.10-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.2", "GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.3", "GOST R 34.11-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.2", "GOST R 34.10-2012-256 + GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.3", "GOST R 34.10-2012-512 + GOST R 34.11-2012-512");
	
	Идентификатор = ОбъектныеИдентификаторы.Получить(ИдентификаторАлгоритма);
	Если Идентификатор = Неопределено Тогда
		Идентификатор = ИдентификаторАлгоритма;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

Функция ПрочитатьIssuerAndSerialNumber(ЧтениеДанных, СвойстваКриптосообщения, КонецБлока)
	
	Издатель = Новый Структура;
	
	// https://tools.ietf.org/html/rfc5652#section-10.2.4
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Значение = ПрочитатьСтроку(ЧтениеДанных, Свойства);
		
		Издатель.Вставить("OID" + СтрЗаменить(Идентификатор, ".", "_"), Значение);
	КонецЦикла;
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	ИздательСерийныйНомер = Новый Структура;
	ИздательСерийныйНомер.Вставить("СерийныйНомер", ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства));
	ИздательСерийныйНомер.Вставить("Издатель", Издатель);
	ИздательСерийныйНомер.Вставить("Идентификатор", ИдентификаторСертификата(ИздательСерийныйНомер));
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат ИздательСерийныйНомер;
	
КонецФункции

Функция ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Получатели = Новый Массив;
		
	СвойстваНабора = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Получатели.Добавить(ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	КонецЦикла;
	
	Возврат Получатели;
	
КонецФункции

Функция ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаRecipientInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Получатель = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
		Получатель = Новый Структура;
	КонецЕсли;
	
	Если Настройки.ПрочитатьАлгоритмПубличногоКлюча Тогда
		Получатель.Вставить("АлгоритмПубличногоКлюча", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	КонецЕсли;
	ПропуститьБлок(ЧтениеДанных, КонецБлокаRecipientInfo - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат Получатель;
	
КонецФункции

Функция ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения)
	
	Содержимое = Base64Значение("");
	
	СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если СвойстваПоследовательности.РазмерБлока > 11 Тогда
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Содержимое = ПрочитатьДвоичныеДанные(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Иначе
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Возврат Содержимое;
	
КонецФункции

Функция ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, СвойстваНабора, Настройки)
	
	СертификатыСИдентификаторами = Новый Соответствие;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Для Каждого Сертификат Из СвойстваКриптосообщения.Сертификаты Цикл
			СертификатыСИдентификаторами.Вставить(ИдентификаторСертификата(Новый Структура("Сертификат", Сертификат)), Сертификат);
		КонецЦикла;
	КонецЕсли;

	Подписанты = Новый Массив;
	
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Подписанты.Добавить(ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки));
	КонецЦикла;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Подписант = Новый Структура;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		ИздательСерийныйНомер = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных, СвойстваКриптосообщения, Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
		Подписант.Вставить("Сертификат", ИздательСерийныйНомер);
		
		Сертификат = СертификатыСИдентификаторами.Получить(Подписант.Сертификат.Идентификатор);
		Если ЗначениеЗаполнено(Сертификат) Тогда
			Подписант.Сертификат.Вставить("Сертификат", Сертификат);
		КонецЕсли;
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмХеширования", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	
	ПодписанныеАтрибуты = ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("ПодписанныеАтрибуты", ПодписанныеАтрибуты);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмПодписи", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	
	НеподписанныеАтрибуты = ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("НеподписанныеАтрибуты", НеподписанныеАтрибуты);
	КонецЕсли;
	
	Возврат Подписант;
	
КонецФункции

Функция ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	Сертификаты = Новый Массив;
	
	// certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			Сертификат = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			Сертификаты.Добавить(Сертификат);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	СпискиОтзываСертификатов = Новый Массив;
	
	// crls  [1] IMPLICIT CertificateRevocationLists OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			СписокОтзываСертификатов = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			СпискиОтзываСертификатов.Добавить(СписокОтзываСертификатов);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат СпискиОтзываСертификатов;
	
КонецФункции

Функция ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока, Настройки)
	
	ПодписанныеАтрибуты = Новый Структура;
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		ГраницаБлока = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
			Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < ГраницаБлока Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
				КонецБлока = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
				Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
				Если Идентификатор = "1.2.840.113549.1.9.5" Тогда // signingTime
					ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
					ПодписанныеАтрибуты.Вставить(
						"ВремяПодписания", 
						ПрочитатьДату(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер))); 
				Иначе
					ПропуститьДо(ЧтениеДанных, КонецБлока);
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			ПропуститьДо(ЧтениеДанных, ГраницаБлока);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат ПодписанныеАтрибуты;
	
КонецФункции

Функция ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	НеподписанныеАтрибуты = Новый Структура;
	
	Если ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() >= СвойстваКриптосообщения.Размер Тогда
		Возврат НеподписанныеАтрибуты;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	КонецЕсли;
	
	Возврат НеподписанныеАтрибуты;
	
КонецФункции

#КонецОбласти

#Область БазовыеФункцииЧтенияASN1

Функция ПрочитатьДату(ЧтениеДанных, Свойства)
	
	Если Свойства.Тег = 23 Тогда // UTCTime https://www.obj-sys.com/asn1tutorial/node15.html
		Возврат Дата("20" + Сред(ПрочитатьСтроку(ЧтениеДанных, Свойства), 1, 12));
	Иначе
		Возврат '0001-01-01';	
	КонецЕсли;
	
КонецФункции
	
Функция ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

Функция ПрочитатьСтроку(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Если Свойства.Тег = 30 Тогда // BMPString
		Кодировка = "utf-16";	
	ИначеЕсли Свойства.Тег = 28 Тогда // UniversalString
		Кодировка = "utf-32";
	Иначе
		Кодировка = "utf-8";	
	КонецЕсли;
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	Строка = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	// Дополнительная защита от ошибок сериализации из-за нечитаемых символов
	Возврат ЗаменитьНечитаемыеСимволы(Строка);
	
КонецФункции

Функция ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Значение = 0;
	Для Каждого Байт Из Буфер Цикл
		Значение = Значение * 256 + Байт;
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции

Функция ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства)
	
	ОбъектныйИдентификатор = Новый Массив;
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если Буфер[0] < 40 Тогда
		SID1 = 0;
	ИначеЕсли Буфер[0] < 80 Тогда
		SID1 = 1;
	Иначе
		SID1 = 2;
	КонецЕсли;
	ОбъектныйИдентификатор.Добавить(Формат(SID1, "ЧРГ=; ЧГ="));
	
	// SID2
	ОбъектныйИдентификатор.Добавить(Буфер[0] - SID1 * 40);
	
	// Остальные SID
	Для Индекс = 1 По Буфер.Размер - 1 Цикл
		ОбъектныйИдентификатор.Добавить(Формат(ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, Индекс), "ЧРГ=; ЧГ="));
	КонецЦикла;
	
	Возврат СтрСоединить(ОбъектныйИдентификатор, ".");
		
КонецФункции

Функция ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, ТекущийБайт)
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Множители = Новый Массив;	
	Пока Истина Цикл
		Байт = Буфер[ТекущийБайт];
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаСтаршийБит));
	 	Если ДлинныйРазмер Тогда
			Множители.Добавить(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаЗначащиеБиты))
		Иначе
			Множители.Добавить(Байт);
			Прервать;
		КонецЕсли;
		
		ТекущийБайт = ТекущийБайт + 1;
		Если ТекущийБайт > Буфер.Размер Тогда
			ВызватьИсключение(НСтр("ru = 'Ошибка разбора OID'"));
		КонецЕсли;
	КонецЦикла;
	
	Результат = 0;
	Для Индекс = 0 По Множители.ВГраница() Цикл
		Показатель = Множители.ВГраница() - Индекс;
		Результат = Результат + Множители[Индекс] * Pow(128, Показатель);
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция КлассТегаБлока(Байт)

	МаскаКлассБлока = 192; // 1100 0000	
	Класс = ОперацияПобитовоеИ(Байт, МаскаКлассБлока);
	
	Если Класс = 0 Тогда
		Возврат "UNIVERSAL";
	ИначеЕсли Класс = 192 Тогда
		Возврат "PRIVATE";
	ИначеЕсли Класс = 64 Тогда
		Возврат "APPLICATION";
	Иначе
		Возврат "CONTEXT-SPECIFIC";
	КонецЕсли;

КонецФункции

Функция ТегБлока(Байт)
	
	МаскаТег = 31; // 0001 1111
	Возврат ОперацияПобитовоеИ(Байт, МаскаТег);

КонецФункции

Функция ПрочитатьСвойстваБлока(ЧтениеДанных, РазмерДанных)
	
	Свойства = Новый Структура;
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);

	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Свойства.Вставить("Класс", КлассТегаБлока(Буфер[0]));
	Свойства.Вставить("Тег", ТегБлока(Буфер[0]));
		
	// Прочитать размер блока
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
	Если Буфер[0] = 128 Тогда // Используется потоковый способ кодирования, т.е. размер блока не указан (окончание блока 00 00)
		РазмерБлока = -1;
	Иначе
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[0], МаскаСтаршийБит));
		Если ДлинныйРазмер Тогда
			КоличествоБайтовПодРазмер = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(КоличествоБайтовПодРазмер);
			РазмерБлока = 0;
			Для Каждого Байт Из Буфер Цикл
				РазмерБлока = РазмерБлока * 256 + Байт;
				
				Если РазмерБлока > РазмерДанных Тогда
					ВызватьИсключение(НСтр("ru = 'Размер блока превышает размер файла'"));
				КонецЕсли;
			КонецЦикла;
		Иначе
			РазмерБлока = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);	
		КонецЕсли;
	КонецЕсли;
	
	Если РазмерБлока > РазмерДанных Тогда
		ВызватьИсключение(НСтр("ru = 'Размер блока превышает размер файла'"));
	КонецЕсли;
	
	Свойства.Вставить("РазмерБлока", РазмерБлока);
	
	Возврат Свойства;
	
КонецФункции

Процедура ПропуститьБлок(ЧтениеДанных, СколькоБайт)
	
	Если СколькоБайт = -1 Тогда
		МаксимальнаяДлинаВЗаголовке = 8192;
		НомерБайта = 1;
		Пока Истина Цикл
			Пока Истина Цикл
				Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
				Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
					Возврат;
				КонецЕсли;
				НомерБайта = НомерБайта + 1;
				Если Буфер[0] = 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
			Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
				Возврат;
			КонецЕсли;
			НомерБайта = НомерБайта + 1;
			Если Буфер[0] = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		ЧтениеДанных.Пропустить(СколькоБайт);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПропуститьДо(ЧтениеДанных, Граница)
	
	ТекущаяПозиция = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Если ТекущаяПозиция >= Граница Тогда
		Возврат;
	КонецЕсли;
	
	ЧтениеДанных.Пропустить(Граница - ТекущаяПозиция);
	
КонецПроцедуры

Функция ОперацияПобитовоеИ(Байт1, Байт2)
	
	Буфер1 = БуферИзБайта(Байт1);
	Буфер2 = БуферИзБайта(Байт2);
	Буфер1.ЗаписатьПобитовоеИ(0, Буфер2);
	
	Возврат Буфер1[0];
	
КонецФункции

Функция БуферИзБайта(Байт)
	
	Буфер = Новый БуферДвоичныхДанных(1);
	Буфер[0] = Байт;
	
	Возврат Буфер;
	
КонецФункции

#КонецОбласти

Функция ИдентификаторСертификата(Знач Сертификат)
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") ИЛИ Сертификат.Свойство("СерийныйНомер") Тогда
		СерийныйНомер = Сертификат.СерийныйНомер;
		Издатель = Сертификат.Издатель;
	Иначе
		СертификатКриптографии = Новый СертификатКриптографии(Сертификат.Сертификат);
		СерийныйНомер = СертификатКриптографии.СерийныйНомер;
		Издатель = СертификатКриптографии.Издатель;
	КонецЕсли;		
	
	СписокOID = Новый СписокЗначений;
	Для Каждого OID Из Издатель Цикл
		Если Не СтрНачинаетсяС(OID.Ключ, "OID") Тогда
			Продолжить;
		КонецЕсли;
		СписокOID.Добавить(OID.Значение, СтрЗаменить(Сред(OID.Ключ, 4), "_", "."));
	КонецЦикла;
	
	Ключи = СтрРазделить("2.5.4.3,2.5.4.4,2.5.4.6,2.5.4.7,2.5.4.8,2.5.4.10,2.5.4.11,2.5.4.12,2.5.4.42,1.2.840.113549.1.9.1", ",");
	Свойства = Новый СписокЗначений;
	Для Каждого Элемент Из СписокOID Цикл
		Если Ключи.Найти(Элемент.Представление) <> Неопределено Тогда
			Свойства.Добавить(Элемент.Значение, Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	СерийныйНомерСтрока = НРег(СтрЗаменить(СерийныйНомер, " ", ""));
	
	Свойства.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	
	МассивЗначений = Свойства.ВыгрузитьЗначения();
	
	МассивЗначений.Добавить(СерийныйНомерСтрока);
	
	ИздательИСерийныйНомер = СтрСоединить(МассивЗначений, "#");
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(ИздательИСерийныйНомер);
	
	Возврат НРег(СтрЗаменить(Хеширование.ХешСумма, " ", ""));	
	
КонецФункции

Функция ЗаменитьНечитаемыеСимволы(ИсходнаяСтрока, ЗаменятьНа = "_")
	
	СтрокаПослеЗамены = ИсходнаяСтрока;
	
	ДлинаСтроки = СтрДлина(ИсходнаяСтрока);
	Для Индекс = 1 По ДлинаСтроки Цикл
		ТекущийСимвол = Сред(ИсходнаяСтрока, Индекс, 1);
		Если КодСимвола(ТекущийСимвол) < 32 Тогда
			СтрокаПослеЗамены = СтрЗаменить(СтрокаПослеЗамены, ТекущийСимвол, ЗаменятьНа);
		КонецЕсли;	
	КонецЦикла;
	
	Возврат СтрокаПослеЗамены;
	
КонецФункции

#КонецОбласти

#Область ПолучениеДистрибутивовКриптоПровайдеров

// Получает дистрибутив КриптоПро CSP
//
// Параметры:
//  ПараметрыЗагрузки - Структура:
//    * Продукт - Строка - Тип продукта КриптоПро (x64/x86) для загрузки.
//    * КонтактноеЛицо - Строка - Контактное лицо запросившее дистрибутив.
//    * ЭлектроннаяПочта - Строка - Электронная почта для регистрации дистрибутива.
//   АдресРезультата - Строка - Адрес результата в хранилище значений.
//   АдресДополнительногоРезультата - Строка - Адрес дополнительного результата в хранилище значений.
//
Процедура ПолучитьДистрибутивCryptoProCSP(ПараметрыЗагрузки, АдресРезультата, АдресДополнительногоРезультата) Экспорт
	
	ПараметрыДистрибутива = Неопределено;
	
	КонтекстДиагностики = ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики();
	АдресЗагрузки = "https://www.cryptopro.ru";
	ОписаниеСоединения = ИнтернетСоединениеБЭД.ОписаниеHTTPСоединения(АдресЗагрузки, 60);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/x-www-form-urlencoded");
	Запрос = Новый HTTPЗапрос("/products/csp/downloads/kontur", Заголовки);
	
	СтрокаЗапроса = "product=%1&username=%2&email=%3&company=%4";
	СтрокаЗапроса = СтрШаблон(СтрокаЗапроса,
		ПараметрыЗагрузки.Продукт,
		КодироватьСтроку(ПараметрыЗагрузки.КонтактноеЛицо, СпособКодированияСтроки.URLВКодировкеURL), 
		КодироватьСтроку(ПараметрыЗагрузки.ЭлектроннаяПочта, СпособКодированияСтроки.URLВКодировкеURL),
		"");
	
	Запрос.УстановитьТелоИзСтроки(СтрокаЗапроса);
	
	ВидОперации = НСтр("ru = 'Получение серийного номера CryptoPRO CSP'");
	РезультатВызова = ИнтернетСоединениеБЭД.ВызватьHTTPМетод(ОписаниеСоединения, Запрос,
		ИнтернетСоединениеБЭД.HTTPМетоды().POST, ВидОперации, КонтекстДиагностики);
	
	Если РезультатВызова.Успех Тогда
		Ответ = РезультатВызова.Ответ;
		Если Ответ.КодСостояния = 200 И Ответ.Заголовки.Получить("Distribution-Number") <> Неопределено Тогда
			Дистрибутив = Ответ.ПолучитьТелоКакДвоичныеДанные();
			ПараметрыДистрибутива = Новый Структура;
			ПараметрыДистрибутива.Вставить("НомерДистрибутива", Ответ.Заголовки["Distribution-Number"]);
			ПараметрыДистрибутива.Вставить("КонтрольнаяСумма", Ответ.Заголовки["GOST"]);
			ПараметрыДистрибутива.Вставить("Версия", Ответ.Заголовки["Version"]);

			ВременныйКаталог = ФайловаяСистема.СоздатьВременныйКаталог();

			Дистрибутив.Записать(ВременныйКаталог + "Setup.exe");

			ТекстСкрипта = ":: setup CryptoPro CSP
						   |@echo off
						   |
						   |""!setup.exe!""!args!";
			ТекстСкрипта = СтрЗаменить(ТекстСкрипта, "!setup.exe!", "Setup.exe");
			Если ЗначениеЗаполнено(ПараметрыЗагрузки.СерийныйНомер) Тогда
				ТекстСкрипта = СтрЗаменить(ТекстСкрипта, "!args!", СтрШаблон(" -args ""PIDKEY=%1""",
					ПараметрыЗагрузки.СерийныйНомер));
			Иначе
				ТекстСкрипта = СтрЗаменить(ТекстСкрипта, "!args!", "");
			КонецЕсли;
			
			РаботаСФайламиБЭД.ЗаписатьТекстВФайл(ТекстСкрипта, ВременныйКаталог + "Setup.bat", КодировкаТекста.OEM);

			Файлы = Новый Массив;
			Для Каждого Файл Из НайтиФайлы(ВременныйКаталог, ПолучитьМаскуВсеФайлы()) Цикл
				ОписаниеФайла = Новый Структура;
				ОписаниеФайла.Вставить("Имя", Файл.Имя);
				ОписаниеФайла.Вставить("ДвоичныеДанные", Новый ДвоичныеДанные(Файл.ПолноеИмя));
				Файлы.Добавить(ОписаниеФайла);
			КонецЦикла;
			ПараметрыДистрибутива.Вставить("Дистрибутив", Файлы);

		Иначе
			Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
				ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка(), Ответ.ПолучитьТелоКакСтроку(),
				НСтр(
				"ru = 'Ошибка при получении серийного номера CryptoPro CSP, подробности см. в журнале регистрации'"));
			ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
				ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().Криптография);
		КонецЕсли;
	Иначе
		ОписаниеОшибки = ИнформацияОбОшибке();
		КраткоеПредставлениеОшибки = НСтр("ru = 'Сервис получения серийных номеров для CryptoPRO CSP временно недоступен. Повторите попытку позже.'");
		КонтекстДиагностики.ЗаголовокОперации = НСтр("ru = 'При получении серийного номера CryptoPRO CSP'");
		
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
			ИнтернетСоединениеБЭДКлиентСервер.ВидОшибкиИнтернетСоединение(),
			ПодробноеПредставлениеОшибки(ОписаниеОшибки), КраткоеПредставлениеОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().Криптография);
	КонецЕсли;
	
	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("ПараметрыДистрибутива", ПараметрыДистрибутива);
	СтруктураВозврата.Вставить("КонтекстДиагностики", КонтекстДиагностики);

	ПоместитьВоВременноеХранилище(СтруктураВозврата, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти