#Область ПрограммныйИнтерфейс

// Возвращает структуру, содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  Ссылка    - ЛюбаяСсылка - объект, значения реквизитов которого необходимо получить.
//
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
//
// Возвращаемое значение:
//  Структура - содержит имена (ключи) и значения затребованных реквизитов.
//              Если строка затребованных реквизитов пуста, то возвращается пустая структура.
//              Если в качестве объекта передана пустая ссылка, то все реквизиты вернутся со значением Неопределено.
//
Функция ЗначенияРеквизитовОбъекта(Ссылка, Знач Реквизиты) Экспорт
	
	Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
		Если ПустаяСтрока(Реквизиты) Тогда
			Возврат Новый Структура;
		КонецЕсли;
		Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
	КонецЕсли;
	
	СтруктураРеквизитов = Новый Структура;
	Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
		СтруктураРеквизитов = Реквизиты;
	ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Реквизит Из Реквизиты Цикл
			СтруктураРеквизитов.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
		КонецЦикла;
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"),
			Строка(ТипЗнч(Реквизиты)));
	КонецЕсли;
	
	ТекстПолей = "";
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		ИмяПоля   = ?(ЗначениеЗаполнено(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Значение),
		              СокрЛП(КлючИЗначение.Ключ));
		
		Псевдоним = СокрЛП(КлючИЗначение.Ключ);
		
		ТекстПолей  = ТекстПолей + ?(ПустаяСтрока(ТекстПолей), "", ",") + "
		|	" + ИмяПоля + " КАК " + Псевдоним;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	Запрос.Текст =
	"ВЫБРАТЬ
	|" + ТекстПолей + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК ПсевдонимЗаданнойТаблицы
	|ГДЕ
	|	ПсевдонимЗаданнойТаблицы.Ссылка = &Ссылка
	|";
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Новый Структура;
	Для Каждого КлючИЗначение Из СтруктураРеквизитов Цикл
		Результат.Вставить(КлючИЗначение.Ключ);
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
//
// Функция не предназначена для получения значений реквизитов пустых ссылок.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ЗначенияРеквизитовОбъекта(Ссылка, ИмяРеквизита);
	Возврат Результат[СтрЗаменить(ИмяРеквизита, ".", "")];
	
КонецФункции 

// Возвращает значения реквизита, прочитанного из информационной базы для нескольких объектов.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Функция не предназначена для получения значений реквизитов пустых ссылок.
//
// Параметры:
//  МассивСсылок - массив ссылок на объекты одного типа.
//				ВАЖНО! значения массива должны быть ссылками на 
//				объекты одного типа!
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Соответствие - Ключ - ссылка на объект, Значение - значение прочитанного реквизита.
// 
Функция ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита) Экспорт
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъектов(МассивСсылок, ИмяРеквизита);
КонецФункции


////
 // Процедура: ОбработатьОшибку
 //   Получает список сообщений в очереди. Если очередь не пуста,
 //   то считается, что ошибка вызвана специально (к примеру Отказ = Истина в обработке проведения),
 //   иначе считается что это неожиданная ошибка в программе, полная информация выводится в журнал регистрации,
 //   краткая в сообщения. Вызывается из обработчиков исключения.
 //
 // Параметры:
 //   ИнформацияОбОшибке
 //     Объект ИнформацияОбОшибке из обработчика исключения.
 //   ВыводитьСообщение.
 //     Использовать СообщениеПользователю для вывода сообщения
 ///
Процедура ОбработатьОшибку(ИнформацияОбОшибке, ВыводитьСообщение = Истина, Метаданные = Неопределено, Данные = Неопределено, НеПроверятьСообщенияВОчереди = Ложь) Экспорт
	Перем Первопричина, СообщенияВОчереди;
	
	СообщенияВОчереди = ПолучитьСообщенияПользователю();
	
	Если НеПроверятьСообщенияВОчереди = Ложь И СообщенияВОчереди.Количество() > 0 Тогда
		Возврат;
	КонецЕсли;
	
	Текст_ = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
	
	Если Текст_ = "" Тогда
		Текст_ = "Ошибка в " + ИнформацияОбОшибке.ИмяМодуля + ", стр. " + ИнформацияОбОшибке.НомерСтроки
			+ " " + ИнформацияОбОшибке.ИсходнаяСтрока + ": " + ИнформацияОбОшибке.Описание;

		Врем_ = ИнформацияОбОшибке;

		Пока Врем_.Причина <> Неопределено Цикл
			Врем_ = Врем_.Причина;
			Текст_ = Текст_ + Символы.ПС + "Ошибка в " + Врем_.ИмяМодуля + ", стр. " + Врем_.НомерСтроки
				+ " " + Врем_.ИсходнаяСтрока + ": " + Врем_.Описание;
		КонецЦикла;
	КонецЕсли;


	ЗаписатьВЖурналРегистрации(Текст_,,, Метаданные, Данные);

	Если ВыводитьСообщение Тогда
		Врем = ИнформацияОбОшибке;

		Пока Врем.Причина <> Неопределено Цикл
			Врем = Врем.Причина;
		КонецЦикла;

		Первопричина = Врем;
		Сообщение_ = Новый СообщениеПользователю;
		Сообщение_.Текст = Первопричина.Описание;
		Сообщение_.Сообщить();
	КонецЕсли;

КонецПроцедуры

////
 // Процедура: ЗаписатьВЖурналРегистрации
 //   Осуществляет запись в журнал регистрации.
 //
 // Параметры:
 ///
Процедура ЗаписатьВЖурналРегистрации(
				Текст, 
				Уровень = Неопределено, 
				Заголовок = "Ошибка выполнения",
				Метаданные = Неопределено,
				Данные = Неопределено) Экспорт
	
	Если Уровень = Неопределено Тогда
		Уровень = УровеньЖурналаРегистрации.Ошибка;
	КонецЕсли;
	
	// Т.к. в транзакции могли быть ошибки, в Данные используется строка,
	// для того что бы платформа не пыталась получить представление.
	ЗаписьЖурналаРегистрации(
		Заголовок, 
		Уровень,
		Метаданные,
		Данные,
		Текст
	);
КонецПроцедуры

// Записывает очередное сообщение в глобальный массив сообщений.
//
//  Параметры : 
//   ИмяСобытия          - Строка - имя события для журнала регистрации;
//   ПредставлениеУровня - Строка - описание уровня события, по нему будет определен уровень события при записи на сервере;
//   ОбъектМетаданных    - ОбъектМетаданных - подробнее см. синтакс-помощник по "ЗаписьЖурналаРегистрации";
//   Данные              - Произвольный - данные, с которыми связано событие (например, ссылки на объект);
//   Комментарий         - Строка - комментарий для события журнала;
//   ПредставлениеРежима - Строка - представление режима транзакции для данного события;
//   ДатаСобытия         - Дата - точная дата возникновения события, описанного в сообщении. Будет добавлена в начало комментария;
//   ЗаписатьСобытия     - Булево - признак вызова процедуры непосредственной записи накопленных сообщений после добавления.
//
Процедура ЗаписатьСообщениеДляЖурналаРегистрации(
		Знач ИмяСобытия,
		Знач ПредставлениеУровня = "Информация", 
		Знач СсылкаНаОбъект = Неопределено,
		Знач Комментарий = "",
		Знач ДатаСобытия = Неопределено
	) Экспорт
	
	УровеньСобытия = УровеньСобытияПоПредставлению(ПредставлениеУровня);
	Если НЕ ЗначениеЗаполнено(ДатаСобытия) Тогда
		ДатаСобытия = ТекущаяДатаСеанса();
	КонецЕсли;
	Комментарий = Строка(ДатаСобытия) + " " + Комментарий;
	
	ЗаписьЖурналаРегистрации(
				ИмяСобытия,
				УровеньСобытия,
				?(СсылкаНаОбъект = Неопределено, СсылкаНаОбъект, СсылкаНаОбъект.Метаданные()),
				СсылкаНаОбъект,
				Комментарий
			);
		
КонецПроцедуры

Функция УровеньСобытияПоПредставлению(ПредставлениеУровня)
	Если ПредставлениеУровня = "Информация" Тогда
		Возврат УровеньЖурналаРегистрации.Информация;
	ИначеЕсли ПредставлениеУровня = "Ошибка" Тогда
		Возврат УровеньЖурналаРегистрации.Ошибка;
	ИначеЕсли ПредставлениеУровня = "Предупреждение" Тогда
		Возврат УровеньЖурналаРегистрации.Предупреждение; 
	ИначеЕсли ПредставлениеУровня = "Примечание" Тогда
		Возврат УровеньЖурналаРегистрации.Примечание;
	КонецЕсли;	
КонецФункции

/// Создание таблицы значений по именам и типам колонок
//
// Параметры:
//   Колонки - Строка -
//     Строка пар, разделенных запятыми или точками с запятой,
//     каждая пара представляет собой имя колонки и строковое представление типа,
//     разделенные двоеточием, причем представление типа может отсутствовать.
//     Представление типа должно быть подходящим для конструктора ОписаниеТипов.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Пустая таблица значений с заданными колонками.
///
Функция СоздатьТаблицуЗначений(Колонки) Экспорт
	
	Таблица_ = Новый ТаблицаЗначений;
	
	ДобавитьКолонкиВТаблицуЗначений(Таблица_, Колонки);
	
	Возврат Таблица_;
	
КонецФункции

/// Добавление в таблицу колонок с заданными именами и типами
//
// Параметры:
//   Таблица - ТаблицаЗначений -
//     Таблица, в которую добавляются колонки.
//   Колонки - Строка -
//     Строка пар, разделенных запятыми или точками с запятой,
//     каждая пара представляет собой имя колонки и строковое представление типа,
//     разделенные двоеточием, причем представление типа может отсутствовать.
//     Представление типа должно быть подходящим для конструктора ОписаниеТипов.
//   ВыдаватьОшибкуЕслиКолонкаСуществует - Булево -
//     Если значение параметра Истина, то при добавлении колонки с именем, которое
//     уже встречается среди имен колонок таблицы значений, будет выдана ошибка.
//     Если значение параметра Ложь, то колонка не будет добавлена,
//     если уже существует колонка с тем же именем.
///
Функция ДобавитьКолонкиВТаблицуЗначений(Таблица, Знач Колонки, ВыдаватьОшибкуЕслиКолонкаСуществует = Истина) Экспорт
	
	__ТИП__(Таблица, "ТаблицаЗначений, ДеревоЗначений", "6e14c890-0b02-11e8-82a6-080027536468");
	__ТИП__(Колонки, "Строка", "7ffbb956-0b02-11e8-8ddb-080027536468");
	
	// Короткий синоним.
	ВыдаватьОшибку_ = ВыдаватьОшибкуЕслиКолонкаСуществует;
	
	// Удалим лишние символы.
	Колонки = АлгоритмыСтроковые.УдалитьПробельныеСимволы(Колонки);
	
	//  Чтобы определить имена колонок и не перепутать их с типами будем использовать такой
	// подход. Если между двоеточиями встречается точка с запятой, то от первого двоеточия до
	// этой точки с запятой идет перечисление типов, а потом идут имена колонок (если идут).
	// Если же точки с зяпятой нет, то тогда идет перечисление типов до предпоследнего
	// идентификатора, который определяет имя очередной колонки. Реализовать данный подход
	// попытаемся с использованием функций СтрРазделить.
	РазбиениеПоДвоеточию_ = СтрРазделить(Колонки, ":");
	
	// В первом элементе разбиения нет типов - только имена колонок. Определим их. Последнее
	// имя возможно будет иметь тип.
	ТекущийЭлемент_ = РазбиениеПоДвоеточию_[0];
	ИменаКолонок_ = СтрРазделить(ТекущийЭлемент_, ",;");
	КолВо_ = ИменаКолонок_.Количество();
	Для Индекс_ = 0 По КолВо_ - 2 Цикл
		Имя_ = ИменаКолонок_[Индекс_];
		Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
			Таблица.Колонки.Добавить(Имя_);
		КонецЕсли;
	КонецЦикла;
	Имя_ = ИменаКолонок_[КолВо_ - 1];
	
	// Остальные элементы разбиения начинаются с описания типов, а заканчиваются именем
	// очередной колонки, кроме последнего элемента разбиения.
	Для ИндексВРазбиении_ = 1 По РазбиениеПоДвоеточию_.Количество() - 1 Цикл
		
		// Для удобства заведем переменную для текущего элемента разбиения.
		ТекущийЭлемент_ = РазбиениеПоДвоеточию_[ИндексВРазбиении_];
		
		// Если есть двоеточие, то пляшем от него.
		Поз_ = СтрНайти(ТекущийЭлемент_, ";");
		
		Если Не 0 = Поз_ Тогда
			// Добавляем очередную колонку в таблицу значений.
			Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
				Таблица.Колонки.Добавить(Имя_, ПолучитьОписаниеТипов(Сред(ТекущийЭлемент_, 1, Поз_ - 1)));
			КонецЕсли;
			
			// С оставшимся концом повторяем трюк с именами колонок, выполненный для первого элемента
			// разбиения.
			ТекущийЭлемент_ = Сред(ТекущийЭлемент_, Поз_ + 1);
			ИменаКолонок_ = СтрРазделить(ТекущийЭлемент_, ",;");
			КолВо_ = ИменаКолонок_.Количество();
			Для Индекс_ = 0 По КолВо_ - 2 Цикл
				Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
					Таблица.Колонки.Добавить(ИменаКолонок_[Индекс_]);
				КонецЕсли;
			КонецЦикла;
			Имя_ = ИменаКолонок_[КолВо_ - 1];
			
		ИначеЕсли ИндексВРазбиении_ = РазбиениеПоДвоеточию_.Количество() - 1 Тогда
			// Оставшийся кусок относится исключительно к типу, поэтому создаем одну колонку.
			Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
				Таблица.Колонки.Добавить(Имя_, ПолучитьОписаниеТипов(ТекущийЭлемент_));
			КонецЕсли;
			Имя_ = Неопределено;
			
		Иначе
			// Всё, кроме последнего идентификатора, относится к описанию типа.
			Поз_ = СтрНайти(ТекущийЭлемент_, ",", НаправлениеПоиска.СКонца);
			Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
				Таблица.Колонки.Добавить(Имя_, ПолучитьОписаниеТипов(Сред(ТекущийЭлемент_, 1, Поз_ - 1)));
			КонецЕсли;
			Имя_ = Сред(ТекущийЭлемент_, Поз_ + 1);
		
		КонецЕсли;
		
	КонецЦикла;
	
	// Если осталось одно имя колонки без типа, добавляем колонку с этим именем в таблицу.
	Если ЗначениеЗаполнено(Имя_) Тогда
		Если Истина = ВыдаватьОшибку_ Или Неопределено = Таблица.Колонки.Найти(Имя_) Тогда
			Таблица.Колонки.Добавить(Имя_);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции


/// Получение описания типов по его строковому представлению
//
// Параметры:
//   ТипыСтрокой - Строка -
//     Список типов, разделенных запятыми.
//     После типа Строка, Число, Дата, ДвоичныеДанные могут в круглых скобках идти
//     квалификаторы. Кроме этого поддерживается тип ЛюбаяСсылка, который заменяется на
//     множество всех допустимых ссылочных типов.
//
// Возвращаемое значение:
//   ОписаниеТипов - Описание типов, соответствующее данному строковому представлению.
///
Функция ПолучитьОписаниеТипов(Знач ТипыСтрокой) Экспорт
	
	//  Заведедем переменную, равную значению Неопределено, так как создать значение типа
	// ОписаниеТипов с пустым множеством типов невозможно.
	Перем ОписаниеТипов_;
	
	// Удалим пробельные символы из строки ТипыСтрокой и переведем её в нижний регистр, чтобы
	// не зависеть от того, какой регистр символов использовал пользователь для записи типов.
	ТипыСтрокой = НРег(АлгоритмыСтроковые.УдалитьПробельныеСимволы(ТипыСтрокой));
	
	// Сначала посмотрим, есть ли тип ЛюбаяСсылка. Если он есть, то он должен представлять
	// собой отдельный тип, а не входить, как подстрока в имя другого типа.
	Если Истина
		И Не 0 = СтрНайти(ТипыСтрокой, "любаяссылка")
		И Не 0 = СтрНайти("," + ТипыСтрокой + ",", ",любаяссылка,")
	Тогда
		
		// Следующий код взят из функции ДинамическоеПолеФормы.ПолучитьОписаниеВсехСсылочныхТипов.
		ОписаниеТипов_ = Новый ОписаниеТипов(Справочники.ТипВсеСсылки());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, Документы.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, Перечисления.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, ПланыВидовХарактеристик.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, ПланыСчетов.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, БизнесПроцессы.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, Задачи.ТипВсеСсылки().Типы());
		ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, ПланыОбмена.ТипВсеСсылки().Типы());
		
		// Удалим подстроку "ЛюбаяСсылка" из переменной ТипыСтрокой для дальнейшей обработки.
		ТипыСтрокой = "," + ТипыСтрокой + ",";
		ТипыСтрокой = СтрЗаменить(ТипыСтрокой, ",любаяссылка,", ",");
		ТипыСтрокой = Сред(ТипыСтрокой, 2, СтрДлина(ТипыСтрокой) - 2);
		
	КонецЕсли;
	
	//  Теперь посмотрим, есть ли квалификаторы, а они есть при наличии круглых скобок.
	РазделеннаяСтрока_ = СтрРазделить(ТипыСтрокой, "()");
	Если РазделеннаяСтрока_.Количество() > 1 Тогда
		
		//  Количество элементов в массиве РазделеннаяСтрока должно быть нечетным. Воспользуемся
		// этим фактом, чтобы обработать каждый квалификатор по отдельности.
		ЧислоИтераций_ = (РазделеннаяСтрока_.Количество() - 1) / 2;
		
		Для Индекс_ = 0 По ЧислоИтераций_ - 1 Цикл
			
			// Определим значения квалификаторов.
			ЗначенияКвалификаторов_ = СтрРазделить(РазделеннаяСтрока_[2 * Индекс_ + 1], ",");
			// Сразу удалим квалификаторы из массива РазделеннаяСтрока_.
			РазделеннаяСтрока_[2 * Индекс_ + 1] = "";
			// Нам нужно определить, для какого типа устанавливаются квалификаторы.
			ТипыСНужнымКонцом_ = РазделеннаяСтрока_[2 * Индекс_];
			
			Если СтрЗаканчиваетсяНа(ТипыСНужнымКонцом_, "число") Тогда
				// Это квалификаторы числа. 
				// Квалификаторы не являются обязательными. Определим, сколько из них задано.
				ЧислоКвалификаторов_ = ЗначенияКвалификаторов_.Количество();
				// Определим число разрядов,
				ЧислоРазрядов_ = 0;
				Если ЧислоКвалификаторов_ >= 1 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[0]) Тогда
					ЧислоРазрядов_ = Число(ЗначенияКвалификаторов_[0]);
				КонецЕсли;
				// число разрядов дробной части,
				ДробнаяЧасть_ = 0;
				Если ЧислоКвалификаторов_ >= 2 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[1]) Тогда
					ДробнаяЧасть_ = Число(ЗначенияКвалификаторов_[1]);
				КонецЕсли;
				// допустимый знак
				ДопустимыйЗнак_ = ДопустимыйЗнак.Любой;
				Если ЧислоКвалификаторов_ >= 3 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[2]) Тогда
					ДопустимыйЗнак_ = ДопустимыйЗнак[ЗначенияКвалификаторов_[2]];
				КонецЕсли;
				// и создадим переменную КвалификаторыЧисла_.
				КвалификаторыЧисла_ = Новый КвалификаторыЧисла(ЧислоРазрядов_, ДробнаяЧасть_, ДопустимыйЗнак_);
				
			ИначеЕсли СтрЗаканчиваетсяНа(ТипыСНужнымКонцом_, "строка") Тогда
				// Это квалификаторы строки. 
				// Квалификаторы не являются обязательными. Определим, сколько из них задано.
				ЧислоКвалификаторов_ = ЗначенияКвалификаторов_.Количество();
				// Определим длину строки,
				Длина_ = 0;
				Если ЧислоКвалификаторов_ >= 1 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[0]) Тогда
					Длина_ = Число(ЗначенияКвалификаторов_[0]);
				КонецЕсли;
				// допустимую длину
				ДопустимаяДлина_ = ДопустимаяДлина.Переменная;
				Если ЧислоКвалификаторов_ >= 2 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[1]) Тогда
					ДопустимаяДлина_ = ДопустимаяДлина[ЗначенияКвалификаторов_[1]];
				КонецЕсли;
				// и создадим переменную КвалификаторыСтроки_.
				КвалификаторыСтроки_ = Новый КвалификаторыСтроки(Длина_, ДопустимаяДлина_);
				
			ИначеЕсли СтрЗаканчиваетсяНа(ТипыСНужнымКонцом_, "дата") Тогда
				// Это квалификаторы даты. 
				// Квалификаторы не являются обязательными. Определим, сколько из них задано.
				ЧислоКвалификаторов_ = ЗначенияКвалификаторов_.Количество();
				// Определим части даты
				ЧастиДаты_ = ЧастиДаты.ДатаВремя;
				Если ЧислоКвалификаторов_ >= 1 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[0]) Тогда
					ЧастиДаты_ = ЧастиДаты[ЗначенияКвалификаторов_[0]];
				КонецЕсли;
				// и создадим переменную КвалификаторыДаты_.
				КвалификаторыДаты_ = Новый КвалификаторыДаты(ЧастиДаты_);
				
			ИначеЕсли СтрЗаканчиваетсяНа(ТипыСНужнымКонцом_, "двоичныеданные") Тогда
				// Это квалификаторы двоичных данных
				// Квалификаторы не являются обязательными. Определим, сколько из них задано.
				ЧислоКвалификаторов_ = ЗначенияКвалификаторов_.Количество();
				// Определим длину двоичных данных,
				Длина_ = 0;
				Если ЧислоКвалификаторов_ >= 1 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[0]) Тогда
					Длина_ = Число(ЗначенияКвалификаторов_[0]);
				КонецЕсли;
				// допустимую длину
				ДопустимаяДлина_ = 0;
				Если ЧислоКвалификаторов_ >= 2 И ЗначениеЗаполнено(ЗначенияКвалификаторов_[1]) Тогда
					ДопустимаяДлина_ = ДопустимаяДлина[ЗначенияКвалификаторов_[1]];
				КонецЕсли;
				// и создадим переменную КвалификаторыДвоичныхДанных_.
				КвалификаторыДвоичныхДанных_ = Новый КвалификаторыДвоичныхДанных(Длина_, ДопустимаяДлина_);
				
			Иначе
				// Это невозможно.
				__ПРОВЕРКА__(Ложь, "ff72af5e-332b-11e8-b86f-080027536468");
			КонецЕсли;
			
		КонецЦикла;
		
		// Соберем обратно строку типов, удалив квалификаторы.
		ТипыСтрокой = СтрСоединить(РазделеннаяСтрока_, "");
		
	КонецЕсли;
	
	// Обработаем определяемые типы.
	Если Истина
		И Не 0 = СтрНайти(ТипыСтрокой, "определяемыйтип.")
		И Не 0 = СтрНайти("," + ТипыСтрокой, ",определяемыйтип.")
	Тогда
		ИменаТипов_ = СтрРазделить(ТипыСтрокой, ",");
		Индекс_ = ИменаТипов_.Количество();
		Пока Индекс_ > 0 Цикл
			Индекс_ = Индекс_ - 1;
			Если СтрНачинаетсяС(ИменаТипов_[Индекс_], "определяемыйтип.") Тогда
				Тип_ = Метаданные.ОпределяемыеТипы.Найти(Сред(ИменаТипов_[Индекс_], 17)).Тип;
				Если Неопределено = ОписаниеТипов_ Тогда
					ОписаниеТипов_ = Тип_;
				Иначе
					ОписаниеТипов_ = Новый ОписаниеТипов(ОписаниеТипов_, Тип_.Типы())
				КонецЕсли;
				ИменаТипов_.Удалить(Индекс_);
			КонецЕсли;
		КонецЦикла;
		ТипыСтрокой = СтрСоединить(ИменаТипов_, ",");
	КонецЕсли;
	
	//  Обработаем оставшиеся типы.
	Если ЗначениеЗаполнено(ТипыСтрокой) Тогда
		Если Неопределено = ОписаниеТипов_ Тогда
			ОписаниеТипов_ = Новый ОписаниеТипов(
				ТипыСтрокой,
				КвалификаторыЧисла_,
				КвалификаторыСтроки_,
				КвалификаторыДаты_,
				КвалификаторыДвоичныхДанных_
			);
		Иначе
			ОписаниеТипов_ = Новый ОписаниеТипов(
				ОписаниеТипов_,
				ТипыСтрокой,
				,
				КвалификаторыЧисла_,
				КвалификаторыСтроки_,
				КвалификаторыДаты_,
				КвалификаторыДвоичныхДанных_
			);
		КонецЕсли;
	КонецЕсли;
	
	Возврат ОписаниеТипов_;
	
КонецФункции

// Процедуры и функции для заполнения шаблона данными.
//
#Область ПроцедурыИФункцииЗаполненияШаблона

// Заполняет шаблон данными.
// Шаблон - Строка - Пример: [Поле1], {{ФИО: [Поле2]}}, [Поле3]Документ: [ИмяДок][/Поле3]
//       [...] - Заменяется на значение,
//       {{...[Поле2]}} - Если значение Поле2 пустое, то в результат не попадет все что между {{ и }},
//       {{...[Поле2]}иначе{альтернативный текст}} - Если значение Поле2 пустое, то в результат попадет альтернативный текст,
//           если пераметр [Поле2] булево, его значение не будет выведено, при этом Ложь эквивалентно пустому значение, Истина заполненному,
//           если внутрь фигурных скобок требуется вложить другие фигурные, необходимо использовать конструкции
//           {1{...}иначе1{...}1} и {2{...}иначе2{...}2}, работающие аналогично, причем порядок вложения такой:
//           самые внешние скобки {{, внутрь их можно вложить {1{, далее {2{, таким образом допустимо вложение глубиной 3,
//       [Поле3]...[/Поле3] - содержимое между тэгами будет повторяться столько раз, сколько элементов
//                            в массиве. Между тэгами допустимо испоьзовать другие поля, включая вложенные массивы.
// Данные - Соответствие, Массив - Пример: Данные["Поле1"] = 123;
//       Данные["Поле2"] = "Иванов";Данные["Поле3"] = Новый Массив (массив соответствий с подобной же заполнением)
// ЭкранироватьСтроки - Булево - в случае значение Истина, заменяет символы <, >, & на &lt;, &gt; &amp; соответственно.
Функция ПодставитьДанныеВШаблон(Знач Шаблон, Данные, Версия = 1, Строго = Ложь, ПрефиксИмениПараметра = "[", ПостфиксИмениПараметра = "]", ЭкранироватьСтроки = Ложь) Экспорт
	
	Если Версия = 2 Тогда
		Если ПрефиксИмениПараметра <> "[" ИЛИ ПостфиксИмениПараметра <> "]" Тогда 
			ВызватьИсключение("Подстановка в шаблон версии 2 не предусмотрена для префикса и посфтикса отличных от '[' и ']'.");
		КонецЕсли;
		
		Возврат ПодставитьДанныеВШаблонВерсия2(Шаблон, Данные, Версия, Строго);
	КонецЕсли;
	
	Результат_ = Шаблон;
	
	Если стрНайти(Результат_, "_{{_") = 0 // если функция вызывается рекурсивно, избегаем повторной замены.
		И стрНайти(Результат_, "_{1{_") = 0
		И стрНайти(Результат_, "_{2{_") = 0
	Тогда 
		Результат_ = стрЗаменить(Результат_, "}иначе{", "_}иначе{_");
		Результат_ = стрЗаменить(Результат_, "}иначе1{", "_}иначе1{_");
		Результат_ = стрЗаменить(Результат_, "}иначе2{", "_}иначе2{_");

		Результат_ = стрЗаменить(Результат_, "{2{", "_{2{_");
		Результат_ = стрЗаменить(Результат_, "}2}", "_}2}_");

		Результат_ = стрЗаменить(Результат_, "{1{", "_{1{_");
		Результат_ = стрЗаменить(Результат_, "}1}", "_}1}_");

		Результат_ = стрЗаменить(Результат_, "{{", "_{{_");
		Результат_ = стрЗаменить(Результат_, "}}", "_}}_");
	КонецЕсли;

	
	Если ТипЗнч(Данные) <> Тип("Массив") Тогда
		МассивДанных_ = Новый Массив;
		МассивДанных_.Добавить(Данные);
	Иначе
		МассивДанных_ = Данные;
	КонецЕсли;
	
	Для Каждого Данные_ Из МассивДанных_ Цикл
		Для Каждого Поле_ Из Данные_ Цикл
			Если ТипЗнч(Поле_.Ключ) = Тип("Строка") Тогда
				ИмяПараметра_ = Поле_.Ключ;
				
				Если НЕ СтрНачинаетсяС(ИмяПараметра_, ПрефиксИмениПараметра) Тогда 
					ИмяПараметра_ = ПрефиксИмениПараметра + ИмяПараметра_;
				КонецЕсли;
				Если НЕ СтрЗаканчиваетсяНа(ИмяПараметра_, ПостфиксИмениПараметра) Тогда 
					ИмяПараметра_ = ИмяПараметра_ + ПостфиксИмениПараметра;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(Поле_.Значение) И ТипЗнч(Поле_.Значение) <> Тип("Булево")
					Или ТипЗнч(Поле_.Значение) = Тип("Массив")
					Или ТипЗнч(Поле_.Значение) = Тип("Булево") И Поле_.Значение = Истина
				Тогда
					Если ТипЗнч(Поле_.Значение) = Тип("Число") Тогда
					
						Значение_ = Формат(Поле_.Значение,"ЧГ=0");
						Результат_ = стрЗаменить(Результат_, ИмяПараметра_, Значение_);
						
					ИначеЕсли ТипЗнч(Поле_.Значение) = Тип("Булево") Тогда
					
						Результат_ = стрЗаменить(Результат_, ИмяПараметра_, "");
						
					ИначеЕсли ТипЗнч(Поле_.Значение) = Тип("Массив") Тогда
						НомерВхождения_ = 1;
						
						Пока НомерВхождения_ < 10 Цикл
							РезультатВырезания_ = ВырезатьЧастьШаблонаМеждуПолями(Результат_, ИмяПараметра_, ПрефиксИмениПараметра);
							
							Если РезультатВырезания_ <> Неопределено Тогда
								Подшаблон_ = РезультатВырезания_.Подшаблон;
								
								ЗаполненныйПодшаблон_ = "";
								
								Если ЗначениеЗаполнено(Подшаблон_) Тогда
									Для Каждого ЗначенияПолей_ Из Поле_.Значение Цикл
										РезультатЗаполнения_ = ПодставитьДанныеВШаблон(
											Подшаблон_, 
											ЗначенияПолей_, 
											Версия, 
											Строго, 
											ПрефиксИмениПараметра, 
											ПостфиксИмениПараметра
										);
										ЗаполненныйПодшаблон_ = ЗаполненныйПодшаблон_ + РезультатЗаполнения_;
									КонецЦикла;
				
									Если Поле_.Значение.Количество() > 0 Тогда
										Результат_ = стрЗаменить(Результат_, РезультатВырезания_.ПодшаблонСТэгами, ЗаполненныйПодшаблон_);
									Иначе
										// Массив пуст, если его теги находятся между {{ и }} то надо удалить все что между этими скобками.
										Результат_ = стрЗаменить(Результат_, РезультатВырезания_.ПодшаблонСТэгами, ИмяПараметра_);
										УдалитьПараметрИзШаблона(Результат_, ИмяПараметра_, Истина);//удаляем только 1 включение, другие надо отработать с начала этого цикла.
									КонецЕсли;
								КонецЕсли;
							Иначе
								Прервать;
							КонецЕсли;
							
							НомерВхождения_ = НомерВхождения_ + 1;
						КонецЦикла;
						
					Иначе
						Если ЭкранироватьСтроки И ТипЗнч(Поле_.Значение) = Тип("Строка") Тогда
							Результат_ = стрЗаменить(Результат_, ИмяПараметра_, ЭкранироватьЗначение(Поле_.Значение));
						Иначе
							Результат_ = стрЗаменить(Результат_, ИмяПараметра_, Поле_.Значение);
						КонецЕсли;
					КонецЕсли;
				Иначе
					УдалитьПараметрИзШаблона(Результат_, ИмяПараметра_);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Результат_ = УдалитьВсеАльтернативы(Результат_, "2"); // удаляет "}иначе2{...}2}"
	Результат_ = УдалитьВсеАльтернативы(Результат_, "1"); // удаляет "}иначе1{...}1}"
	Результат_ = УдалитьВсеАльтернативы(Результат_, ""); // удаляет "}иначе{...}}"

	Результат_ = стрЗаменить(Результат_, "_{2{_", "");
	Результат_ = стрЗаменить(Результат_, "_}2}_", "");

	Результат_ = стрЗаменить(Результат_, "_{1{_", "");
	Результат_ = стрЗаменить(Результат_, "_}1}_", "");

	Результат_ = стрЗаменить(Результат_, "_{{_", "");
	Результат_ = стрЗаменить(Результат_, "_}}_", "");
	
	Возврат Результат_;
КонецФункции

// Вычитывает параметры шаблона из шаблона
//
// Параметры:
//  Шаблон								 - Строка	 - Шаблон
//  ПрефиксИмениПараметра	 - Строка	 - Постфикс имени параметра
//  ПостфиксИмениПараметра - Строка	 - Префикс имени параметра
// 
// Возвращаемое значение:
//  Массив - Массив со строковыми значениями, заключенными между ПрефиксомИмениПараметра и ПостфиксомИмениПараметра
//
Функция ПараметрыШаблонаИзШаблона(Знач Шаблон, Знач ПрефиксИмениПараметра = "[", Знач ПостфиксИмениПараметра = "]") Экспорт
	
	// удовлетовряющее регулярному выражению: \[[^0-9\[\]][^\[\]]*\]
	// Т.е. выражение в квадратных скобках, не начинающееся с цифры.
	Результат_ = Новый Массив();
	
	ДлинаПрефикса_ = СтрДлина(ПрефиксИмениПараметра);
	ДлинаПостфикса_ = СтрДлина(ПостфиксИмениПараметра);
	НачальнаяПозиция_ = 1;
	
	Пока Истина Цикл 
		ИндексНачалаТега_ = СтрНайти(Шаблон, ПрефиксИмениПараметра, НаправлениеПоиска.СНачала, НачальнаяПозиция_);
		Если 0 = ИндексНачалаТега_ Тогда 
			Прервать;
		КонецЕсли;
		НачальнаяПозиция_ = ИндексНачалаТега_ + ДлинаПрефикса_;
		ИндексОкончанияТега_ = СтрНайти(Шаблон, ПостфиксИмениПараметра, НаправлениеПоиска.СНачала, НачальнаяПозиция_);
		Если 0 = ИндексОкончанияТега_ Тогда 
			Прервать;
		КонецЕсли;
		НачальнаяПозиция_ = ИндексОкончанияТега_ + ДлинаПостфикса_;
		
		ПараметрШаблона_ = Сред(Шаблон, ИндексНачалаТега_, ИндексОкончанияТега_ - ИндексНачалаТега_ + ДлинаПостфикса_);
		Результат_.Добавить(ПараметрШаблона_);
	КонецЦикла;
	
	Возврат Результат_;
КонецФункции

// Экранирует строку для записи в xml.
Функция ЭкранироватьЗначение(Строка) Экспорт
	
	Если Не ЗначениеЗаполнено(Строка) Тогда
		Возврат "";
	КонецЕсли;
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьXML.ЗаписатьНачалоЭлемента("q");
	ЗаписьXML.ЗаписатьАтрибут("s", Строка);
	ЗаписьXML.ЗаписатьКонецЭлемента();
	XML_ = ЗаписьXML.Закрыть();
	
	Длина_ = стрДлина(XML_);
	Если Длина_ > 8 Тогда
		Результат_ = Сред(XML_, 7, Длина_ - 9);
	Иначе
		Результат_ = "";
	КонецЕсли;
	
	Возврат Результат_;

КонецФункции

// Вырезает часть текста между тэгами [ИмяПараметра] и [/ИмяПараметра].
Функция ВырезатьЧастьШаблонаМеждуПолями(Шаблон, ИмяПараметра, ПрефиксИмениПараметра)
	Результат_ = Новый Структура("ПодшаблонСТэгами, Подшаблон");
	
	ИмяОткрывающегоТэга_ = ИмяПараметра;
	ИмяЗакрывающегоТэга_ = стрЗаменить(ИмяПараметра, ПрефиксИмениПараметра, ПрефиксИмениПараметра + "/");
	
	Начало_ = стрНайти(Шаблон, ИмяОткрывающегоТэга_);
	
	Если Начало_ > 0 Тогда
		Конец_ = стрНайти(Шаблон, ИмяЗакрывающегоТэга_,, Начало_);
		Если Конец_ > 0 Тогда
			Результат_.ПодшаблонСТэгами = Сред(Шаблон, Начало_, (Конец_ + стрДлина(ИмяЗакрывающегоТэга_) - 1) - Начало_ + 1);
			Результат_.Подшаблон = Сред(Шаблон, Начало_ + стрДлина(ИмяОткрывающегоТэга_), Конец_ - (Начало_ + стрДлина(ИмяОткрывающегоТэга_)));
		
			Возврат Результат_;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Удаляет часть строки между скобками {{ }}, внутри которых встречается, переданный в аргументах,
// параметр шаблона, к примеру [ИМЯ_ПАРАМЕТРА].
Функция УдалитьПараметрИзШаблона(Шаблон, ИмяПараметра, ТолькоПервый = Ложь)

	УдалитьПараметрИзШаблонаПоНомеруВложения(Шаблон, ИмяПараметра, "2");
	УдалитьПараметрИзШаблонаПоНомеруВложения(Шаблон, ИмяПараметра, "1");
	УдалитьПараметрИзШаблонаПоНомеруВложения(Шаблон, ИмяПараметра, "");
	
	Если ТолькоПервый = Ложь И стрНайти(Шаблон, ИмяПараметра) > 0 Тогда
		// Удалим следующее включение, если оно есть.
		Шаблон = УдалитьПараметрИзШаблона(Шаблон, ИмяПараметра);
	КонецЕсли;
	
	Возврат Шаблон;

КонецФункции

Функция УдалитьПараметрИзШаблонаПоНомеруВложения(Шаблон, ИмяПараметра, НомерВложения)

	УдалятьПараметр_ = Ложь;
	Если НомерВложения = "" Тогда
		УдалятьПараметр_ = Истина;
	КонецЕсли;
	
	ОткрывающаяСкобка_ = стрШаблон("_{%1{_", НомерВложения);
	ЗакрывающаяСкобка_ = стрШаблон("_}%1}_", НомерВложения);
	
	ДлинаСкобки_ = стрДлина(ЗакрывающаяСкобка_);

	ПозицияКлюча_ = стрНайти(Шаблон, ИмяПараметра);
	
	Если ПозицияКлюча_ > 0 Тогда
		ОткрСкобка_ = стрНайти(Шаблон, ОткрывающаяСкобка_, НаправлениеПоиска.СКонца, ПозицияКлюча_);
		ЗакрСкобка_ = стрНайти(Шаблон, ЗакрывающаяСкобка_, НаправлениеПоиска.СНачала, ПозицияКлюча_);
		Если ОткрСкобка_ > 0 И ЗакрСкобка_ > 0 И ПозицияКлюча_ > ОткрСкобка_ И ПозицияКлюча_ < ЗакрСкобка_ Тогда
			
			УдаляемаяЧасть_ = Сред(Шаблон, ОткрСкобка_, (ЗакрСкобка_ - ОткрСкобка_) + ДлинаСкобки_);
			
			Если стрНайти(УдаляемаяЧасть_, ОткрывающаяСкобка_, НаправлениеПоиска.СНачала, ДлинаСкобки_ + 1) = 0
				И стрНайти(УдаляемаяЧасть_, ЗакрывающаяСкобка_, НаправлениеПоиска.СКонца, стрДлина(УдаляемаяЧасть_) - ДлинаСкобки_) = 0
			Тогда
				
				Альтернатива_ = ПолучитьАльтернативуМеждуФигурнымиСкобками(УдаляемаяЧасть_, НомерВложения);
				
				Если стрНайти(Альтернатива_, ИмяПараметра) = 0 Тогда
					Шаблон = стрЗаменитьТолькоПервый(Шаблон, УдаляемаяЧасть_, Альтернатива_);
				Иначе
					Если УдалятьПараметр_ Тогда
						// параметр внутри альтернативного варианта, просто удалим параметр,
						// а не все что между фигурныи скобками.
						Шаблон = стрЗаменитьТолькоПервый(Шаблон, ИмяПараметра, "");
					КонецЕсли;
				КонецЕсли;
			Иначе
				Если УдалятьПараметр_ Тогда
					// вокруг параметра фигурных скобок нет, а найденные принадлежат другим параметрам.
					Шаблон = стрЗаменитьТолькоПервый(Шаблон, ИмяПараметра, "");
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			Если УдалятьПараметр_ Тогда
				// вокруг параметра фигурных скобок нет.
				Шаблон = стрЗаменитьТолькоПервый(Шаблон, ИмяПараметра, "");
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Шаблон;
КонецФункции

// Выполняет замену только первого вхождения.
Функция стрЗаменитьТолькоПервый(Строка, СтрокаПоиска, СтрокаНаЗамену)
	ДлинаСтроки_ = стрДлина(Строка);
	ДлинаВхождения_ = стрДлина(СтрокаПоиска);
	
	Если ДлинаСтроки_ > 0 И ДлинаВхождения_ > 0 Тогда
	
		ПозицияВхождения_ = стрНайти(Строка, СтрокаПоиска);
		
		Если ПозицияВхождения_ > 0 Тогда
			
			Возврат Лев(Строка, ПозицияВхождения_ - 1) + СтрокаНаЗамену
				+ Прав(Строка, ДлинаСтроки_ + 1 - ПозицияВхождения_ - ДлинаВхождения_);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Строка;
КонецФункции

// Из строки {{...}иначе{...}} вырезает и возвращает часть между }иначе{...}}
Функция ПолучитьАльтернативуМеждуФигурнымиСкобками(УдаляемаяЧасть, НомерВложения)
	Разделитель_ = стрШаблон("_}иначе%1{_", НомерВложения);
	ЗакрывающаяСкобка_ = стрШаблон("_}%1}_", НомерВложения);
	
	ДлинаРазделителя_ = стрДлина(Разделитель_);
	ДлинаСкобки_ = стрДлина(ЗакрывающаяСкобка_);
	
	ПозицияАльтернативы_ = стрНайти(УдаляемаяЧасть, Разделитель_);
	
	Если ПозицияАльтернативы_ > 0 Тогда
		Возврат Сред(УдаляемаяЧасть,
				ПозицияАльтернативы_ + ДлинаРазделителя_,
				стрДлина(УдаляемаяЧасть) - ПозицияАльтернативы_ - (ДлинаРазделителя_ + ДлинаСкобки_ - 1)
			);
	КонецЕсли;
	
	Возврат "";
КонецФункции

// Удаляет все встречаемые "}иначе{...}}"
Функция УдалитьВсеАльтернативы(Шаблон, НомерВложения)
	Разделитель_ = стрШаблон("_}иначе%1{_", НомерВложения);
	ЗакрывающаяСкобка_ = стрШаблон("_}%1}_", НомерВложения);
	ДлинаСкобки_ = стрДлина(ЗакрывающаяСкобка_);
	
	Пока Истина Цикл
		ПозицияАльтернативы_ = стрНайти(Шаблон, Разделитель_);
		Если ПозицияАльтернативы_ > 0 Тогда
			ЗакрСкобка_ = стрНайти(Шаблон, ЗакрывающаяСкобка_, НаправлениеПоиска.СНачала, ПозицияАльтернативы_);
			
			Если ЗакрСкобка_ > 0 Тогда
				УдаляемаяЧасть_ = Сред(Шаблон, ПозицияАльтернативы_, (ЗакрСкобка_ - ПозицияАльтернативы_) + ДлинаСкобки_);
				Шаблон = стрЗаменитьТолькоПервый(Шаблон, УдаляемаяЧасть_, "");
			КонецЕсли;
		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Шаблон;
КонецФункции

/// Подстановка параметров в шаблон
//
// Если в шаблоне есть текст [Имя],
// вместо него подставляется значение параметра с ключом "[Имя]" или "Имя".
// Булево значение (и истина, и ложь) заменяются на пустую строку.
//
// Если в шаблоне есть текст {{текст1[Имя1]текст2[Имя2]текст3}иначе{[Имя3]}иначе{текст4}},
// то в результат включается одна из подстановок параметров в текст
// "текст1[Имя1]текст2[Имя2]текст3", "[Имя3]" или "текст4".
// Причем если в первой порции заполнены все встречающиеся параметры,
// то включается она, а остальные порции не включаются.
// Если первая порция не включается, а во второй заполнены все параметры,
// то включается вторая порция, а остальные не включаются.
// И так далее. Булев параметр считается заполненным, если он равен Истина.
// Порции могут включать вложенные схемы {{}}.
//
// Поддерживается также булев параметр [!Имя], который равен Истина,
// если параметр Имя не заполнен, и Ложь, если заполнен.
//
// Конструкции вида [Имя]текст[/Имя] обрабатывается, если значение параметра
// Имя является массивом. При этом, к тесту применяется подстановка параметров
// столько раз, сколько элементов есть в массиве, и результат конкатенируется.
// В качестве элементов массива допускается использовать соответствия и
// массивы соответствий, которые задают новые или изменяют значения ранее
// определенных параметров, встречающихся между открывающим и закрывающим тегами.
// Теги могут рекурсивно друг в друга вкладываться при соблюдений правил
// вложимости тегов well formed XML.
///
Функция ПодставитьДанныеВШаблонВерсия2(Шаблон, Параметры, Версия, Строго)
	
	СоответствиеПараметров_ = СформироватьСоответствеПараметров(Параметры);
	
	// Для начала найдем все позиции фраз "{{", "}}", "}иначе{", а также "[Имя]", "[/Имя]".
	// В этих массивах на индексах, сравнимых с нулем по модулю 3, записаны позиции в Шаблоне,
	// на индексах, сравнимых с единицей по модулю 3, - идентификаторы фраз,
	// на индексах, сравнимых с двойкой по модулю 3, - длины фраз.
	// Фразы "{{" будем искать с конца, чтобы не спутать с последовательностью
	// подряд идущих токенов "}иначе{" и "{{".
	ПозицииФразыСтарт_ = ПозицииФразы(Шаблон, ИдФразыСтарт(), ЛексемаСтарт(), , Строго, Истина);
	ПозицииФразыИначе_ = ПозицииФразы(Шаблон, ИдФразыИначе(), ЛексемаИначе(), , Строго);
	ПозицииФразыФиниш_ = ПозицииФразы(Шаблон, ИдФразыФиниш(), ЛексемаФиниш(), , Строго);
	ПозицииФразыЗакрТег_ = ПозицииФразы(
		Шаблон, ИдФразыЗакрТег(), ЛексемаНачЗакрТега(), ЛексемаКонТега(), Строго
	);
	// Для поиска открывающих тегов используем другую функцию.
	ПозицииФразыОткрТег_ = ПозицииФразыОткрТег(Шаблон, ПозицииФразыЗакрТег_, Строго);
	
	// Сольем массивы в единый массив.
	МассивМассивов_ = АлгоритмыДляКоллекций.СоздатьМассив(
		ПозицииФразыСтарт_,
		ПозицииФразыИначе_,
		ПозицииФразыФиниш_,
		ПозицииФразыОткрТег_,
		ПозицииФразыЗакрТег_
	);
	Шаг_ = 3;
	Политики_ = 2 + 4;
	ПозицииФраз_ = АлгоритмыДляКоллекций.МногопутевоеСлияние(МассивМассивов_, Шаг_, Политики_);
	
	// Запомним длины лексем открывающего и закрывающего тега. Пригодятся.
	ДлОткрТега_ = СтрДлина(ЛексемаНачОткрТега());
	ДлЗакрТега_ = СтрДлина(ЛексемаНачЗакрТега());
	
	// Проверим корректность вложимости фраз.
	Уровень_ = 0;
	Индекс_ = 0;
	// В следующем массиве четные индексы - позиции, нечетные - фразы.
	ПозицииСтартовПоУровням_ = Новый Массив(100);
	ПозицииСтартовПоУровням_[0] = 1;
	ПозицииСтартовПоУровням_[1] = "";
	Пока Не Индекс_ = ПозицииФраз_.Количество() Цикл
		
		Фраза_ = Сред(Шаблон, ПозицииФраз_[Индекс_], ПозицииФраз_[Индекс_ + 2]);
		
		Если Ложь Тогда
			// Для красоты оформления кода.
			
		ИначеЕсли ПозицииФраз_[Индекс_ + 1] = ИдФразыСтарт() Тогда
			Уровень_ = Уровень_ + 1;
			ПозицииСтартовПоУровням_[2 * Уровень_ + 0] = ПозицииФраз_[Индекс_];
			ПозицииСтартовПоУровням_[2 * Уровень_ + 1] = Фраза_;
			
		ИначеЕсли ПозицииФраз_[Индекс_ + 1] = ИдФразыИначе() Тогда
			Если Уровень_ = 0 Тогда
				
				ТекстОшибки_ = НСтр("ru = 'Не найден открывающий тег для тега %1.'");
				Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			Если Не ЛексемаСтарт() = ПозицииСтартовПоУровням_[2 * Уровень_ + 1] Тогда
				
				ТестОшибки_ = НСтр("ru = 'Обнаружен тег %1 после тега %2.'");
				ФразаСтарта_ = ПозицииСтартовПоУровням_[2 * Уровень_ + 1];
				Ошибка_ = СформироватьОшибкуВШаблоне(
					Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_, ФразаСтарта_
				);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			
		ИначеЕсли ПозицииФраз_[Индекс_ + 1] = ИдФразыФиниш() Тогда
			Если Уровень_ = 0 Тогда
				
				ТекстОшибки_ = НСтр("ru = 'Не найден открывающий тег для тега %1.'");
				Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			Если Не ЛексемаСтарт() = ПозицииСтартовПоУровням_[2 * Уровень_ + 1] Тогда
				
				ТекстОшибки_ = НСтр("ru = 'Обнаружен тег %1 после тега %2.'");
				ФразаСтарта_ = ПозицииСтартовПоУровням_[2 * Уровень_ + 1];
				Ошибка_ = СформироватьОшибкуВШаблоне(
					Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_, ФразаСтарта_
				);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			Уровень_ = Уровень_ - 1;
			
		ИначеЕсли ПозицииФраз_[Индекс_ + 1] = ИдФразыОткрТег() Тогда
			Уровень_ = Уровень_ + 1;
			ПозицииСтартовПоУровням_[2 * Уровень_ + 0] = ПозицииФраз_[Индекс_];
			ПозицииСтартовПоУровням_[2 * Уровень_ + 1] = Фраза_;
			
		ИначеЕсли ПозицииФраз_[Индекс_ + 1] = ИдФразыЗакрТег() Тогда
			Если Уровень_ = 0 Тогда
				
				ТекстОшибки_ = НСтр("ru = 'Не найден открывающий тег для тега %1.'");
				Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			// Проверим соответствие тегов [/Имя] и [Имя].
			ФразаСтарта_ = ПозицииСтартовПоУровням_[2 * Уровень_ + 1];
			Если Не Сред(Фраза_, ДлЗакрТега_ + 1) = Сред(ФразаСтарта_, ДлОткрТега_ + 1) Тогда
				
				ТекстОшибки_ = НСтр("ru = 'Обнаружен тег %1 после тега %2.'");
				Ошибка_ = СформироватьОшибкуВШаблоне(
					Шаблон, ПозицииФраз_[Индекс_], ТекстОшибки_, Фраза_, ФразаСтарта_
				);
				ВызватьИсключение Ошибка_;
			КонецЕсли;
			Уровень_ = Уровень_ - 1;
			
		КонецЕсли;
		
		Индекс_ = Индекс_ + 3;
	КонецЦикла;
	
	Если Не Уровень_ = 0 Тогда
		
		ТекстОшибки_ = НСтр("ru = 'Открывающий тег %1 без закрывающего.'");
		ФразаСтарта_ = ПозицииСтартовПоУровням_[2 * Уровень_ + 1];
		Ошибка_ = СформироватьОшибкуВШаблоне(
			Шаблон, ПозицииСтартовПоУровням_[2 * Уровень_], ТекстОшибки_, ФразаСтарта_
		);
		ВызватьИсключение Ошибка_;
	КонецЕсли;
	
	// Очистим множество забытых параметров.
	ЗабытыеПараметры = Новый Соответствие;
	
	// Обработаем шаблон.
	Результат_ = ОбработатьПодстроку(
		Шаблон,
		1, // ПозНач
		ПозицииФраз_,
		0, // ИндексПозицииФразы
		СоответствиеПараметров_,
		Ложь, // Пропускать
		Строго,
		Истина, // ВерхнийУровень
		ЗабытыеПараметры
	);
	
	// Если обнаружены забытые параметры, сообщим об этом.
	Если ЗабытыеПараметры.Количество() > 0 Тогда
		ЗабытыеПараметрыМассивом_ = Новый Массив;
		Для Каждого КлючИЗначение_ Из ЗабытыеПараметры Цикл
			ЗабытыеПараметрыМассивом_.Добавить(КлючИЗначение_.Ключ);
		КонецЦикла;
		
		ТекстОшибки_ = НСтр("ru = 'Не заполнены следующие параметры шаблона: %1.'");
		Ошибка_ = СтрШаблон(ТекстОшибки_, СтрСоединить(ЗабытыеПараметрыМассивом_, ", "));
		Если Строго Тогда
			ВызватьИсключение Ошибка_;
		КонецЕсли;
		Сообщить(Ошибка_);
	КонецЕсли;
	
	__ТИП__(Результат_, "Строка", "cd7aa3aa-74ed-11ec-8c3d-ff25e0e35047");
	
	// Вернем результат.
	Возврат Результат_;
	
КонецФункции

Функция ИдФразыСтарт()
	Возврат 0;
КонецФункции

Функция ИдФразыИначе()
	Возврат 1;
КонецФункции

Функция ИдФразыФиниш()
	Возврат 2;
КонецФункции

Функция ИдФразыЗакрТег()
	Возврат 3;
КонецФункции

Функция ИдФразыОткрТег()
	Возврат 4;
КонецФункции

Функция ИдФразыПарам()
	Возврат 5;
КонецФункции

Функция ЛексемаСтарт()
	Возврат "{{";
КонецФункции

Функция ЛексемаИначе()
	Возврат "}иначе{";
КонецФункции

Функция ЛексемаФиниш()
	Возврат "}}";
КонецФункции

Функция ЛексемаНачОткрТега()
	Возврат "[";
КонецФункции

Функция ЛексемаНачЗакрТега()
	Возврат "[/";
КонецФункции

Функция ЛексемаКонТега()
	Возврат "]";
КонецФункции

Функция ЛексемаНачПарам()
	Возврат "[";
КонецФункции

Функция ЛексемаКонПарам()
	Возврат "]";
КонецФункции

/// Вычленение имени параметра из строки
//
// Имя параметра не должно начинаться на символ !.
// Имя параметра не должно содержать символа [.
// Это условие, помимо прочего, позволяет отвергнуть конструкцию <![CDATA[.
//                                                                 ^
// Функция также отвергает конструкцию <![CDATA[.
//                                             ^
// Параметры:
//   Шаблон - Строка -
//     Строковый шаблон с параметрами.
//   ПозНач - Число -
//     Позиция символа [ в Шаблоне,
//     то есть позиция начало конструкции [Имя], [/Имя] или [!Имя].
//
// Возвращаемое значение:
//   Строка, Неопределено - Имя параметра или Неопределено, если его не удалось извлечь.
///
Функция ПолучитьИмяПараметра(Шаблон, ПозНач, НачЛексема, КонЛексема, Строго, ИсходныйШаблон = Ложь)
	
	__ПРОВЕРКА__(Сред(Шаблон, ПозНач, СтрДлина(НачЛексема)) = НачЛексема, "308a93e6-2a30-11ec-8f23-931578ffb4ae");
	
	// Если лексема начинается с "[", убедимся, что это не <![CDATA[.
	Если СтрНачинаетсяС(НачЛексема, "[") Тогда
		// Для этого введем пару вспомогательных переменных.
		CDATA_ = "<![CDATA[";
		ДлинаCDATA_ = СтрДлина(CDATA_);
		// Проверим на <![CDATA[.
		//               ^
		Если ПозНач > 2 И Сред(Шаблон, ПозНач - 2, ДлинаCDATA_) = CDATA_ Тогда
			Возврат Неопределено;
		КонецЕсли;
		// Проверим на <![CDATA[.
		//                     ^
		Если ПозНач >= ДлинаCDATA_ И Сред(Шаблон, ПозНач - ДлинаCDATA_ + 1, ДлинаCDATA_) = CDATA_ Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	// Параметр должен завершаться последней лексемой, например, символом ']'.
	ПозКон_ = СтрНайти(Шаблон, КонЛексема, , ПозНач);
	Если ПозКон_ = 0 Тогда
		Если ИсходныйШаблон Тогда
			
			ТекстОшибки_ = НСтр("ru = 'Незакрытый параметр в шаблоне.'");
			Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ТекстОшибки_);
		Иначе
			// Не используем функцию СформироватьОшибкуВШаблоне, поскольку в качестве первого
			// параметра (Шаблон) может быть передан не исходный шаблон, а результат обработки
			// какой-то подстроки исходного шаблона.
			
			ТекстОшибки_ = НСтр("ru = 'Незакрытый параметр в подстроке ""%1"".'");
			Ошибка_ = СтрШаблон(ТекстОшибки_, Сред(Шаблон, ПозНач, 50));
		КонецЕсли;
		Если Строго Тогда
			ВызватьИсключение Ошибка_;
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	// В имени параметра не должно быть первого символа первой лексемы.
	// Если используются параметры (теги) [Имя] и [/Имя], это означает,
	// что в имени параметра не должно быть символа '['.
	Поз_ = СтрНайти(Шаблон, Сред(НачЛексема, 1, 1), , ПозНач + СтрДлина(НачЛексема));
	Если ПозНач < Поз_ И Поз_ < ПозКон_ Тогда
		Если ИсходныйШаблон Тогда
			
			ТекстОшибки_ = НСтр("ru = 'Незакрытый параметр в шаблоне.'");
			Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ТекстОшибки_);
		Иначе
			// Не используем функцию СформироватьОшибкуВШаблоне, поскольку в качестве первого
			// параметра (Шаблон) может быть передан не исходный шаблон, а результат обработки
			// какой-то подстроки исходного шаблона.
			
			ТекстОшибки_ = НСтр("ru = 'Незакрытый параметр в подстроке ""%1"".'");
			Ошибка_ = СтрШаблон(ТекстОшибки_, Сред(Шаблон, ПозНач, 50));
		КонецЕсли;
		Если Строго Тогда
			ВызватьИсключение Ошибка_;
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	// Определим смещение от ПозНач до первого символа имени параметра.
	Смещение_ = СтрДлина(НачЛексема);
	// Если первым символом оказался '!', значит это отрицание. Увеличим смещение.
	Если "!" = Сред(Шаблон, ПозНач + Смещение_, 1) Тогда
		Смещение_ = Смещение_ + 1;
	КонецЕсли;
	
	// Имя параметра не должно начинаться с символа !.
	Если "!" = Сред(Шаблон, ПозНач + Смещение_, 1) Тогда
		Если ИсходныйШаблон Тогда
			
			ТекстОшибки_ = НСтр("ru = 'Имя параметра не должно начинаться с восклицательного знака.'");
			Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ТекстОшибки_);
		Иначе
			// Не используем функцию СформироватьОшибкуВШаблоне, поскольку в качестве первого
			// параметра (Шаблон) может быть передан не исходный шаблон, а результат обработки
			// какой-то подстроки исходного шаблона.
			
			ТекстОшибки_ = НСтр("ru = 'Имя параметра не должно начинаться с восклицательного знака: ""%1"".'");
			Ошибка_ = СтрШаблон(ТекстОшибки_, Сред(Шаблон, ПозНач, 50));
		КонецЕсли;
		Если Строго Тогда
			ВызватьИсключение Ошибка_;
		КонецЕсли;
		Возврат Неопределено;
	КонецЕсли;
	
	// Теперь определим имя параметра.
	ИмяПараметра_ = Сред(Шаблон, ПозНач + Смещение_, ПозКон_ - ПозНач - Смещение_);
	
	Возврат ИмяПараметра_;
	
КонецФункции

Функция ПозицииФразы(Шаблон, ИдФразы, НачЛексема, КонЛексема = "", Строго, СКонца = Ложь)
	
	МассивПозиций_ = Новый Массив;
	
	ДлШаблона_ = СтрДлина(Шаблон);
	ДлНачЛексемы_ = СтрДлина(НачЛексема);
	Приращение_ = ДлНачЛексемы_;
	НаправлениеПоиска_ = НаправлениеПоиска.СНачала;
	
	Если СКонца Тогда
		// Не -1, а -Приращение, потому что возможна такая последовательность: }иначе{{{,
		// и, если бы было -1, здесь алгоритм насчитал бы два тега "{{".
		Приращение_ = -Приращение_;
		НаправлениеПоиска_ = НаправлениеПоиска.СКонца;
	КонецЕсли;
	
	Поз_ = СтрНайти(Шаблон, НачЛексема, НаправлениеПоиска_);
	
	// Для параметров и тегов будем делать проверку на корректность имени параметра.
	// Длиной такой фразы будет общаяя длина тега [...] или [/...].
	Если ИдФразы = ИдФразыПарам() Или ИдФразы = ИдФразыЗакрТег() Или ИдФразы = ИдФразыОткрТег() Тогда
		ДлКонЛексемы_ = СтрДлина(КонЛексема);
		Пока Не 0 = Поз_ Цикл
			ИмяПараметра_ = ПолучитьИмяПараметра(Шаблон, Поз_, НачЛексема, КонЛексема, Строго, Истина);
			Если Не Неопределено = ИмяПараметра_ Тогда
				ДлФразы_ = ДлНачЛексемы_ + СтрДлина(ИмяПараметра_) + ДлКонЛексемы_;
				// Перед параметром может стоять восклицательный знак.
				Если Сред(Шаблон, Поз_ + ДлНачЛексемы_, 1) = "!" Тогда
					ДлФразы_ = ДлФразы_ + 1;
				КонецЕсли;
				// Заполняем массив.
				МассивПозиций_.Добавить(Поз_);
				МассивПозиций_.Добавить(ИдФразы);
				МассивПозиций_.Добавить(ДлФразы_);
			КонецЕсли;
			Поз_ = Поз_ + Приращение_;
			// Обратите внимание на конструкцию "Тогда Иначе".
			Если 0 < Поз_ И Поз_ <= ДлШаблона_ Тогда Иначе
				Прервать;
			КонецЕсли;
			Поз_ = СтрНайти(Шаблон, НачЛексема, НаправлениеПоиска_, Поз_);
		КонецЦикла;
	Иначе
		Пока Не 0 = Поз_ Цикл
			МассивПозиций_.Добавить(Поз_);
			МассивПозиций_.Добавить(ИдФразы);
			МассивПозиций_.Добавить(ДлНачЛексемы_);
			Поз_ = Поз_ + Приращение_;
			// Обратите внимание на конструкцию "Тогда Иначе".
			Если 0 < Поз_ И Поз_ <= ДлШаблона_ Тогда Иначе
				Прервать;
			КонецЕсли;
			Поз_ = СтрНайти(Шаблон, НачЛексема, НаправлениеПоиска_, Поз_);
		КонецЦикла;
	КонецЕсли;
	
	Если СКонца Тогда
		// Развернем содержимое массива в обратную сторону.
		РазвернутьПозицииФразы(МассивПозиций_, ИдФразы);
	КонецЕсли;
	
	Возврат МассивПозиций_;
	
КонецФункции

Функция ПозицииФразыОткрТег(Шаблон, ПозицииФразыЗакрТег, Строго)
	
	// ФразыОткрТег будем искать, следующим образом:
	// По ФразеЗакрТег определим имя тега
	// и найдем ближайшее слева вхождение открывающего тега с тем же именем.
	// Будем также считать, что вложимость одноименных тегов недопустима,
	// поскольку не имеет смысла.
	// Открывающие теги будем складывать в стек и извлекать оттуда,
	// чтобы восстановить правильный порядок.
	// Обход массива закрывающих тегов начнем с конца.
	СтекФразОткрТег_ = Новый Массив;
	ПозицииФразыОткрТег_ = Новый Массив;
	НачОткрТега_ = ЛексемаНачОткрТега();
	НачЗакрТега_ = ЛексемаНачЗакрТега();
	КонТега_ = ЛексемаКонТега();
	ДлНачЗакрТега_ = СтрДлина(НачЗакрТега_);
	ДлНачКонЗакрТега_ = ДлНачЗакрТега_ + СтрДлина(КонТега_);
	ИдФразы_ = ИдФразыОткрТег();
	Индекс_ = ПозицииФразыЗакрТег.Количество();
	Пока Не 0 = Индекс_ Цикл
		ПозЗакрТег_ = ПозицииФразыЗакрТег[Индекс_ - 3];
		ДлЗакрТег_ = ПозицииФразыЗакрТег[Индекс_ - 1];
		// Извлечем из стека открывающие теги, которые идут после текущего закрывающего.
		РазмерСтека_ = СтекФразОткрТег_.Количество();
		Пока Не 0 = РазмерСтека_ И СтекФразОткрТег_[РазмерСтека_ - 2] > ПозЗакрТег_ Цикл
			ПозицииФразыОткрТег_.Добавить(СтекФразОткрТег_[РазмерСтека_ - 2]);
			ПозицииФразыОткрТег_.Добавить(ИдФразы_);
			ПозицииФразыОткрТег_.Добавить(СтекФразОткрТег_[РазмерСтека_ - 1]);
			СтекФразОткрТег_.Удалить(РазмерСтека_ - 1);
			СтекФразОткрТег_.Удалить(РазмерСтека_ - 2);
			РазмерСтека_ = РазмерСтека_ - 2;
		КонецЦикла;
		ИмяТега_ = Сред(Шаблон, ПозЗакрТег_ + ДлНачЗакрТега_, ДлЗакрТег_ - ДлНачКонЗакрТега_);
		ОткрТег_ = СтрШаблон("%1%2%3", НачОткрТега_, ИмяТега_, КонТега_);
		ПозОткр_ = СтрНайти(Шаблон, ОткрТег_, НаправлениеПоиска.СКонца, ПозЗакрТег_);
		Если ПозОткр_ = 0 Тогда
			
			ТекстОшибки_ = НСтр("ru = 'Не найден открывающий тег для закрывающего тега [/%1].'");
			Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозЗакрТег_, ТекстОшибки_, ИмяТега_);
			ВызватьИсключение Ошибка_;
		КонецЕсли;
		СтекФразОткрТег_.Добавить(ПозОткр_);
		СтекФразОткрТег_.Добавить(СтрДлина(ОткрТег_));
		Индекс_ = Индекс_ - 3;
	КонецЦикла;
	
	// Извлечем из стека оставшиеся открывающие теги, которые идут после текущего закрывающего.
	Пока Не 0 = СтекФразОткрТег_.Количество() Цикл
		РазмерСтека_ = СтекФразОткрТег_.Количество();
		ПозицииФразыОткрТег_.Добавить(СтекФразОткрТег_[РазмерСтека_ - 2]);
		ПозицииФразыОткрТег_.Добавить(ИдФразы_);
		ПозицииФразыОткрТег_.Добавить(СтекФразОткрТег_[РазмерСтека_ - 1]);
		СтекФразОткрТег_.Удалить(РазмерСтека_ - 1);
		СтекФразОткрТег_.Удалить(РазмерСтека_ - 2);
	КонецЦикла;
	
	// Осталось развернуть массив позиций фраз.
	РазвернутьПозицииФразы(ПозицииФразыОткрТег_, ИдФразы_);
	
	Возврат ПозицииФразыОткрТег_;
	
КонецФункции

Процедура РазвернутьПозицииФразы(МассивПозиций, ИдФразы)
	
	// Будем обменивать значения указателей, двигающихся от концов массива к центру.
	Лев_ = 0;
	Прав_ = МассивПозиций.Количество();
	// Для фраз [Имя] и [/Имя] при развороте надо менять не только позиции, но и длины,
	// так как они могут быть различными. Ну а идентификаторы фраз - это константа.
	Если ИдФразы = ИдФразыЗакрТег() Или ИдФразы = ИдФразыОткрТег() Тогда
		Пока Лев_ < Прав_ Цикл
			Прав_ = Прав_ - 3;
			Врем_ = МассивПозиций[Лев_];
			МассивПозиций[Лев_] = МассивПозиций[Прав_];
			МассивПозиций[Прав_] = Врем_;
			Врем_ = МассивПозиций[Лев_ + 2];
			МассивПозиций[Лев_ + 2] = МассивПозиций[Прав_ + 2];
			МассивПозиций[Прав_ + 2] = Врем_;
			Лев_ = Лев_ + 3;
		КонецЦикла;
	Иначе
		Пока Лев_ < Прав_ Цикл
			Прав_ = Прав_ - 3;
			Врем_ = МассивПозиций[Лев_];
			МассивПозиций[Лев_] = МассивПозиций[Прав_];
			МассивПозиций[Прав_] = Врем_;
			Лев_ = Лев_ + 3;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ШаблонОшибки, Арг1 = "", Арг2 = "")
	
	// Определим номер строки шаблона, где обнаружена ошибка.
	НомерСтроки_ = СтрЧислоСтрок(Сред(Шаблон, 1, ПозНач));
	
	// Определим номер символа в строке, где обнаружена ошибка.
	Поз_ = СтрНайти(Шаблон, Символы.ПС, НаправлениеПоиска.СКонца, ПозНач);
	НомерПозиции_ = ПозНач - Поз_;
	
	// Сформируем текст ошибки.
	
	ШаблонСообщения_ = НСтр(
		"ru = 'Ошибка в шаблоне: строка %1, позиция %2.
		|%3'"
	);
	ТекстОшибки_ = СтрШаблон(ШаблонСообщения_, НомерСтроки_, НомерПозиции_, ШаблонОшибки);
	
	// Подставим параметры в сообщение.
	ТекстОшибки_ = СтрЗаменить(ТекстОшибки_, "%1", Арг1);
	ТекстОшибки_ = СтрЗаменить(ТекстОшибки_, "%2", Арг2);
	
	Возврат ТекстОшибки_;
	
КонецФункции

/// Подстановка параметров в подстроку
//
// Параметры:
//   Строка - Строка -
//     Шаблон, в который подставляются параметры.
//   ПозНач - Число -
//     Позиция начала подстроки в шаблоне.
//     Этот параметр также является возвращаемым.
//     После вызова функции в нем будет позиция,
//     с которой начинается еще не обработанная часть шаблона.
//   ПозицииТокенов - Массив -
//     Массив, на четных индексах которых стоит позиция в шаблоне,
//     с которой начинается токен, а на нечетных - идентификатор токена.
//   ИндексПозицииТокена - Число -
//     Индекс массиве ПозицииТокенов, соответствующий
//     ближайшему левому незакрытому токену от ПозНач.
//     Этот параметр также является возвращаемым.
//     После вызова функции в нем будет позиция
//     ближайшего левого незакрытого токена от изменного значения ПозНач.
//   Параметры - Соответствие -
//     Множество значений параметров для подстановки в шаблон.
//     Это множество может пополняться случайно сгенерированными параметрами.
//   Пропускать - Булево -
//     Если Истина, то обработка начнется с позиции токена
//     с индексом ИндексПозицииТокена в массиве ПозицииТокенов,
//     а символы от ПозНач до этой позиции будут пропущены.
//   Строго - Булево -
//     Если Истина, то при обнаружении незаполненных параметров
//     будет возбуждено исключение.
//   ВерхнийУровень - Булево -
//     Если Ложь, значит функция вызвана рекурсивно.
//   ЗабытыеПараметры - Соответствие -
//     Множество для хранения незаполненных параметров.
///
Функция ОбработатьПодстроку(Шаблон, ПозНач, ПозицииФраз, ИндексПозицииФразы, Параметры, Пропускать, Строго, ВерхнийУровень, ЗабытыеПараметры)
	
	// Запомним идентификаторы фраз.
	ИдФразыСтарт_ = ИдФразыСтарт();
	ИдФразыИначе_ = ИдФразыИначе();
	ИдФразыФиниш_ = ИдФразыФиниш();
	ИдФразыОткрТег_ = ИдФразыОткрТег();
	ИдФразыЗакрТег_ = ИдФразыЗакрТег();
	
	// Запомним некоторые лексемы.
	НачОткрТега_ = ЛексемаНачОткрТега();
	НачЗакрТега_ = ЛексемаНачЗакрТега();
	КонТега_ = ЛексемаКонТега();
	НачПарам_ = ЛексемаНачПарам();
	КонПарам_ = ЛексемаКонПарам();
	
	// Запомним длины некоторых лексем.
	ДлНачОткрТега_ = СтрДлина(НачОткрТега_);
	ДлНачЗакрТега_ = СтрДлина(НачЗакрТега_);
	ДлКонТега_ = СтрДлина(КонТега_);
	
	// По ходу дела будем добавлять вспомогательные параметры.
	ВспомогательныеПараметры_ = Новый Соответствие;
	
	// Подстроки для обработки.
	// Этот массив будет заполняться при последовательной обработке Шаблона.
	ПодстрокиДляОбработки_ = Новый Массив;
	
	Пока ИндексПозицииФразы < ПозицииФраз.Количество() Цикл
		
		// Возьмем позицию очередной фразы, её дескриптор и длину.
		ПозФразы_ = ПозицииФраз[ИндексПозицииФразы];
		ИдФразы_ = ПозицииФраз[ИндексПозицииФразы + 1];
		ДлФразы_ = ПозицииФраз[ИндексПозицииФразы + 2];
		
		// Если функция работает не в режииме пропуска (сработало условие, а мы в }иначе{ или наоборот),
		// добавим подстроку в массив для обработки.
		Если Не Пропускать Тогда
			ПодстрокиДляОбработки_.Добавить(Сред(Шаблон, ПозНач, ПозФразы_ - ПозНач));
		КонецЕсли;
		
		// Сдвигаем указатель текущей обрабатываемой позиции.
		ПозНач = ПозФразы_;
		
		// Если очередная фраза не стартовая, прерываемся и ограничиваем строку позицией Фразы.
		Если ПринадлежитМножеству(ИдФразы_, ИдФразыИначе_, ИдФразыФиниш_, ИдФразыЗакрТег_) Тогда
			Прервать;
		КонецЕсли;
		
		// Если это тег "{{", обработаем всю структуру.
		Если ИдФразы_ = ИдФразыСтарт_ Тогда
			ПропускатьВложенные_ = Пропускать;
			Пока Истина Цикл
				
				// Переходим к следующей позиции в строке и к следующему токену.
				ИдФразы_ = ПозицииФраз[ИндексПозицииФразы + 1];
				ДлФразы_ = ПозицииФраз[ИндексПозицииФразы + 2];
				ПозНач = ПозНач + ДлФразы_;
				ИндексПозицииФразы = ИндексПозицииФразы + 3;
				
				// Если это был финишный токен, завершаем цикл.
				Если ИдФразы_ = ИдФразыФиниш_ Тогда
					Прервать;
				КонецЕсли;
				
				// Рекурсивно обработаем часть.
				РезультатОбработки_ = ОбработатьПодстроку(
					Шаблон,
					ПозНач,
					ПозицииФраз,
					ИндексПозицииФразы,
					Параметры,
					ПропускатьВложенные_,
					Строго,
					Ложь, // ВерхнийУровень
					ЗабытыеПараметры
				);
				
				__ПРОВЕРКА__(РезультатОбработки_ = Ложь Или ТипЗнч(РезультатОбработки_) = Тип("Строка"), "85e6bd38-74e5-11ec-a759-c783754afe9e");
				
				// Результатом обработки может быть значение Ложь или строка.
				// Строку вставляем даже пустую. Но в качестве параметра, только непустую.
				ПропускатьВложенные_ = Истина;
				Если Ложь = РезультатОбработки_ Тогда
					// Содержимое следующих условий }иначе{ не пропускаем,
					// ждем, когда оно не станет равным Истина.
					ПропускатьВложенные_ = Ложь;
					
				ИначеЕсли Не ЗначениеЗаполнено(РезультатОбработки_) Тогда
					// Добавим эту строку в массив для обработки без трюка с параметром,
					// поскольку внутри этой строки ничего обрабатываемого нет.
					// А если бы мы добавили её в виде параметра, то соответствующий блок
					// {{}} мог бы быть исключен.
					ПодстрокиДляОбработки_.Добавить(РезультатОбработки_);
					
				Иначе
					// Обработанную часть повторно обрабатывать не нужно.
					// Поэтому используем такой трюк. Полученный результат
					// сохраним как значение случайно сгенерированного параметра.
					ИмяПараметра_ = "П" + СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
					ВспомогательныеПараметры_.Вставить(ИмяПараметра_, РезультатОбработки_);
					// И вместо собственно результата обработки подставим этот параметр.
					ПодстрокиДляОбработки_.Добавить(СтрШаблон("%1%2%3", НачПарам_, ИмяПараметра_, КонПарам_));
					
				КонецЕсли;
				
			КонецЦикла;
			
		// Если это тег [Имя], который завершается тегом [/Имя], то обработаем его как массив.
		ИначеЕсли ИдФразы_ = ИдФразыОткрТег_ Тогда
			// Извлечем имя параметра.
			ИмяПараметра_ = Сред(Шаблон, ПозНач + ДлНачОткрТега_, ДлФразы_ - ДлНачОткрТега_ - ДлКонТега_);
			
			// Результатом обработки массива будет конкатенация результатов.
			РезультатОбработки_ = Новый Массив;
			
			// Может оказаться, что массив пуст, тогда просто найдем позицию за закрывающим
			// тегом и на этом остановимся.
			Если Не ЗначениеЗаполнено(Параметры[ИмяПараметра_]) Тогда
				Если Строго И Не Тип("Массив") = ТипЗнч(Параметры[ИмяПараметра_]) Тогда
					
					ТекстОшибки_ = НСтр("ru = 'Параметр шаблона [%1] должен быть массивом.'");
					Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ТекстОшибки_, ИмяПараметра_);
					ВызватьИсключение Ошибка_;
				КонецЕсли;
				ЗакрТег_ = СтрШаблон("%1%2%3", НачЗакрТега_, ИмяПараметра_, КонТега_);
				ИндексПозицииФразыВложенный_ = ИндексПозицииФразы + 3;
				Пока Не ИндексПозицииФразыВложенный_ = ПозицииФраз.Количество() Цикл
					ПозНачВложенное_ = ПозицииФраз[ИндексПозицииФразыВложенный_];
					ДлФразы_ = ПозицииФраз[ИндексПозицииФразыВложенный_ + 2];
					Если Сред(Шаблон, ПозНачВложенное_, ДлФразы_) = ЗакрТег_ Тогда
						Прервать;
					КонецЕсли;
					ИндексПозицииФразыВложенный_ = ИндексПозицииФразыВложенный_ + 3;
				КонецЦикла;
				__ПРОВЕРКА__(Не ИндексПозицииФразыВложенный_ = ПозицииФраз.Количество(), "57748598-2aa3-11ec-91cf-3b7ba551d38a");
				
			// Если параметр - не пустой массив, обработаем его.
			ИначеЕсли Тип("Массив") = ТипЗнч(Параметры[ИмяПараметра_]) Тогда
			
				Для Каждого ПодПараметр_ Из Параметры[ИмяПараметра_] Цикл
					ПозНачВложенное_ = ПозНач + ДлФразы_;
					ИндексПозицииФразыВложенный_ = ИндексПозицииФразы + 3;
					ПараметрыВложенные_ = СформироватьСоответствеПараметров(ПодПараметр_, Параметры);
					
					// Рекурсивно обработаем часть.
					РезультатОбработкиВложенный_ = ОбработатьПодстроку(
						Шаблон,
						ПозНачВложенное_,
						ПозицииФраз,
						ИндексПозицииФразыВложенный_,
						ПараметрыВложенные_,
						Пропускать,
						Строго,
						ВерхнийУровень, // Это не "{{", так что оставляем, как есть.
						ЗабытыеПараметры
					);
					
					// Добавим полученный результат к результату обработки.
					Если Не Ложь = РезультатОбработкиВложенный_ Тогда
						РезультатОбработки_.Добавить(РезультатОбработкиВложенный_);
					КонецЕсли;
					
				КонецЦикла;
				
			// В противном случае сообщим пользователю об ошибке путем возбуждения исключения.
			Иначе
				
				ТекстОшибки_ = НСтр("ru = 'Параметр шаблона [%1] должен быть массивом.'");
				Ошибка_ = СформироватьОшибкуВШаблоне(Шаблон, ПозНач, ТекстОшибки_, ИмяПараметра_);
				ВызватьИсключение Ошибка_;
				
			КонецЕсли;
				
			// Теперь обязательно должны оказаться заполнеными
			// переменные ПозНачВложенное_ И ИндексПозицииТокенаВложенный_.
			__ПРОВЕРКА__(ЗначениеЗаполнено(ПозНачВложенное_) И ЗначениеЗаполнено(ИндексПозицииФразыВложенный_), "ab92ee5e-29e9-11ec-a799-eba533919160");
			// И имена открывающего и закрывающего тегов должны совпадать.
			__ПРОВЕРКА__(Сред(Шаблон, ПозицииФраз[ИндексПозицииФразы] + ДлНачОткрТега_, СтрДлина(ИмяПараметра_) + ДлКонТега_) = Сред(Шаблон, ПозицииФраз[ИндексПозицииФразыВложенный_] + ДлНачЗакрТега_, СтрДлина(ИмяПараметра_) + ДлКонТега_), "69b1c5cc-29ea-11ec-b74b-ffd51e95aef8");
			
			// Запишем измененные значения во вложенных вызовах в исходные переменные.
			ПозНач = ПозНачВложенное_ + ПозицииФраз[ИндексПозицииФразыВложенный_ + 2];
			ИндексПозицииФразы = ИндексПозицииФразыВложенный_ + 3;
			
			__ТИП__(РезультатОбработки_, "Массив", "e422a41e-74ec-11ec-8f62-47dcf449ce23");
			
			Если ЗначениеЗаполнено(РезультатОбработки_) Тогда
				// Обработанную часть повторно обрабатывать не нужно.
				// Поэтому используем такой трюк. Полученный результат
				// сохраним как значение случайно сгенерированного параметра.
				ИмяПараметра_ = "П" + СтрЗаменить(Новый УникальныйИдентификатор, "-", "");
				ВспомогательныеПараметры_.Вставить(ИмяПараметра_, СтрСоединить(РезультатОбработки_, ""));
				// И вместо собственно результата обработки подставим этот параметр.
				ПодстрокиДляОбработки_.Добавить(СтрШаблон("%1%2%3", НачПарам_, ИмяПараметра_, КонПарам_));
			КонецЕсли;
			
		Иначе
			// Ошибки шаблона должны были быть найдены ранее, на этапе проверки вложимости тегов.
			__ПРОВЕРКА__(Ложь, "5984d548-30d2-11eb-aaf4-bb0af01db3c7");
		
		КонецЕсли;
		
	КонецЦикла;
	
	// Обработаем конец строки.
	// Он может быть только на верхнем уровне, а значит, не может быть пропущен.
	Если ИндексПозицииФразы = ПозицииФраз.Количество() Тогда
		ПодстрокиДляОбработки_.Добавить(Сред(Шаблон, ПозНач));
		ПозНач = СтрДлина(Шаблон) + 1;
	КонецЕсли;
	
	// Соединим все подстроки в одну и будем подставлять в нее параметры.
	Подстрока_ = СтрСоединить(ПодстрокиДляОбработки_, "");
	
	// Подстроки между параметрами и значения параметров будем собирать в массив,
	// чтобы в дальнейшем использовать СтрСоединить. Последовательное использование
	// СтрЗаменить может приводить к неправильному результату, если значения
	// параметров будут содержать квадратные скобки. Поэтому не будем использовать
	// СтрЗаменить, а будем использовать СтрСоединить.
	ПодстрокиРезультата_ = Новый Массив;
	
	// Если один из параметров пуст и у нас не верхний уровень, а мы находимся внутри
	// тегов "{{" "}}", то результатом должна быть пустая строка, а точнее значение Ложь.
	ВозвратитьЛожь_ = Ложь;
	
	// Определим позиции вхождений параметров в Подстроку_.
	ПозицииПараметров_ = ПозицииФразы(Подстрока_, ИдФразыПарам(), НачПарам_, КонПарам_, Строго, Ложь);
	
	// Строки между параметрами просто складываем в массив ПодстрокиРезультата_,
	// а параметры заменяем на их значения.
	Поз_ = 1;
	ИндексПозицииПарам_ = 0;
	ДлНачПарам_ = СтрДлина(НачПарам_);
	ДлНачКонПарам_ = ДлНачПарам_ + СтрДлина(КонПарам_);
	Пока Не ИндексПозицииПарам_ = ПозицииПараметров_.Количество() Цикл
		
		// Возьмем позицию очередной фразы, её дескриптор и длину.
		ПозПарам_ = ПозицииПараметров_[ИндексПозицииПарам_];
		ДлПарам_ = ПозицииПараметров_[ИндексПозицииПарам_ + 2];
		
		// Вычленим имя параметра.
		ИмяПараметра_ = Сред(Подстрока_, ПозПарам_ + ДлНачПарам_, ДлПарам_ - ДлНачКонПарам_);
		
		// Закинем в массив подстрок результата строку между параметрами.
		ПодстрокиРезультата_.Добавить(Сред(Подстрока_, Поз_, ПозПарам_ - Поз_));
		
		// Инкремент для следующей итерации цикла.
		ИндексПозицииПарам_ = ИндексПозицииПарам_ + 3;
		Поз_ = ПозПарам_ + ДлПарам_;
		
		// Перед именем параметра может стоять дополнительный символ: ! (отрицание).
		ЭтоОтрицание_ = Ложь;
		Если СтрНачинаетсяС(ИмяПараметра_, "!") Тогда
			ЭтоОтрицание_ = Истина;
			ИмяПараметра_ = Сред(ИмяПараметра_, 2);
		КонецЕсли;
		
		// Проверим наличие параметра в списке.
		ЗначениеПараметра_ = Параметры[ИмяПараметра_];
		Если Неопределено = ЗначениеПараметра_ Тогда
			ЗначениеПараметра_ = ВспомогательныеПараметры_[ИмяПараметра_];
		КонецЕсли;
		
		ЗначениеЗаполнено_ = ЗначениеЗаполнено(ЗначениеПараметра_)
			// Булево Ложь считается заполненным значением, а нам нужно, чтобы считалось незаполненным.
			И (Не ТипЗнч(ЗначениеПараметра_) = Тип("Булево") Или ЗначениеПараметра_ = Истина)
		;
		
		// Числа преобразуем в строки без разделителей разрядов.
		Если ТипЗнч(ЗначениеПараметра_) = Тип("Число") Тогда
			ЗначениеПараметра_ = АлгоритмыСтроковые.УдалитьРазделительГрупп(ЗначениеПараметра_);
		КонецЕсли;
		
		Если Неопределено = ЗначениеПараметра_ Тогда
			// Параметра нет, оставляем его без изменений, то есть в квадратных скобках.
			ПодстрокиРезультата_.Добавить(Сред(Подстрока_, ПозПарам_, ДлПарам_));
			// Если имя параметра начинается с цифры, пропустим, возможно это комментарий в XML.
			// А остальные поместим во множество забытых параметров.
			Если 0 = СтрНайти("0123456789", Сред(ИмяПараметра_, 1, 1)) Тогда
				ЗабытыеПараметры[ИмяПараметра_] = Истина;
			КонецЕсли;
			
		ИначеЕсли ЭтоОтрицание_ Тогда
			ВозвратитьЛожь_ = ВозвратитьЛожь_ Или ЗначениеЗаполнено_;
			
		ИначеЕсли ТипЗнч(ЗначениеПараметра_) = Тип("Булево") Тогда
			ВозвратитьЛожь_ = ВозвратитьЛожь_ Или Не ЗначениеЗаполнено_;
			
		Иначе
			ПодстрокиРезультата_.Добавить(ЗначениеПараметра_);
			ВозвратитьЛожь_ = ВозвратитьЛожь_ Или Не ЗначениеЗаполнено_;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПодстрокиРезультата_.Добавить(Сред(Подстрока_, Поз_));
	
	Если ВозвратитьЛожь_ И Не ВерхнийУровень Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Соединим подстроки в одну и вернем.
	Результат_ = СтрСоединить(ПодстрокиРезультата_, "");
	
	Возврат Результат_;
	
КонецФункции

/// Формирование параметров в виде соответствия
//
// Параметры:
//   Параметры - Массив, Соответствие -
//     Параметры для шаблона.
//   НаследуемыеПараметры - Неопределено, ФиксированноеСоответствие -
//     Наследуемые параметры при обработке параметров-массивов,
//     то есть конструкций [ИмяПараметра]...[/ИмяПараметра].
//
// Возвращаемое значение:
//   Соответствие - параметры, собранные в одно соответствие.
//   Это соответствие ни в каком случае не является ссылкой на Параметры.
///
Функция СформироватьСоответствеПараметров(Знач Параметры, Знач НаследуемыеПараметры = Неопределено)
	
	// Если Параметры уже соответствие, а НаследуемыеПараметры не заполнены,
	// то вернем Параметры в качестве результата. Но есть один нюанс.
	// Если значение параметра равно Неопределено, его не отличить от отсутствующего
	// параметра. Поэтому, если есть хотя бы один параметр со значением Неопределено,
	// будем обрабатывать как общий случай.
	ЕстьПараметрСоЗначениемНеопределено_ = Ложь;
	Если ТипЗнч(Параметры) = Тип("Соответствие") И Не ЗначениеЗаполнено(НаследуемыеПараметры) Тогда
		Для Каждого КлючИЗначение_ Из Параметры Цикл
			Если КлючИЗначение_.Значение = Неопределено Тогда
				ЕстьПараметрСоЗначениемНеопределено_ = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Не ЕстьПараметрСоЗначениемНеопределено_ Тогда
			Возврат Параметры;
		КонецЕсли;
	КонецЕсли;
	
	// Аналогично поступив в симметричном случае.
	Если ЗначениеЗаполнено(НаследуемыеПараметры) И Не ЗначениеЗаполнено(Параметры) Тогда
		Возврат НаследуемыеПараметры;
	КонецЕсли;
	
	// Теперь к копии наследуемых параметров будетм добавлять Параметры.
	Если ЗначениеЗаполнено(НаследуемыеПараметры) Тогда
		Врем_ = Новый ФиксированноеСоответствие(НаследуемыеПараметры);
		СоответствиеПараметров_ = Новый Соответствие(Врем_);
	Иначе
		СоответствиеПараметров_ = Новый Соответствие;
	КонецЕсли;
	
	// Если Параметры не заполнены, то вернем, что получилось.
	Если Не ЗначениеЗаполнено(Параметры) Тогда
		Возврат СоответствиеПараметров_;
	КонецЕсли;
	
	// Для удобства упакуем параметры в массив, если они еще им не являются.
	Если Не ТипЗнч(Параметры) = Тип("Массив") Тогда
		Параметры = АлгоритмыДляКоллекций.СоздатьМассив(Параметры);
	КонецЕсли;
	
	// Следующие переменные пригодятся в теле цикла.
	НачПарам_ = ЛексемаНачПарам();
	КонПарам_ = ЛексемаКонПарам();
	ДлНачПарам_ = СтрДлина(НачПарам_);
	ДлНачКонПарам_ = ДлНачПарам_ + СтрДлина(КонПарам_);
	
	// Теперь дополним СоответствиеПараметров_ данными из соответствий из массива Параметры.
	// Если в Параметрах переопределены какие-то НаследуемыеПараметры,
	// то эти параметры будут взяты из Параметров, причем если Параметры - это массив,
	// то приоритет имеют параметры, определенные ближе к концу массива.
	Для Каждого КонтейнерПараметров_ Из Параметры Цикл
		Для Каждого КлючИЗначение_ Из КонтейнерПараметров_ Цикл
			Ключ_ = КлючИЗначение_.Ключ;
			Если СтрНачинаетсяС(Ключ_, НачПарам_) И СтрЗаканчиваетсяНа(Ключ_, КонПарам_) Тогда
				Ключ_ = Сред(Ключ_, 1 + ДлНачПарам_, СтрДлина(Ключ_) - ДлНачКонПарам_);
			КонецЕсли;
			Значение_ = КлючИЗначение_.Значение;
			Если Значение_ = Неопределено Тогда
				// В соответствии трудно определить есть ли ключ со значением Неопределено,
				// или нет такого ключа. Поэтому заменим на пустую строку.
				// С точки зрения шаблонизатора это одно и то же.
				Значение_ = "";
			КонецЕсли;
			СоответствиеПараметров_[Ключ_] = Значение_;
		КонецЦикла;
	КонецЦикла;
	
	Возврат СоответствиеПараметров_;
	
КонецФункции

#КонецОбласти

#КонецОбласти

