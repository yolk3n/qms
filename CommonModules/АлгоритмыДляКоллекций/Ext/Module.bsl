
#Область ПрограммныйИнтерфейс


//////////////////////////////////////////////////////////////////////////////
//
// АЛГОРИТМЫ НАД МАССИВАМИ И ТАБЛИЦАМИ
//
//////////////////////////////////////////////////////////////////////////////

/// Копирование элементов массива Массив2 в конец массива Массив1
//
// Параметры:
//   Массив1 - Массив -
//     Массив, в который добавляются элементы.
//   Массив2 - Массив, Неопределено -
//     Массив, элементы которого добавляются.
///
Процедура Присоединить(Массив1, Массив2) Экспорт
	
	Если Не ЗначениеЗаполнено(Массив2) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Элемент_ Из Массив2 Цикл
		Массив1.Добавить(Элемент_);
	КонецЦикла;
	
КонецПроцедуры

////  
// Процедура: ПрисоединитьУникальные
//   Процедура копирует уникальные элементы массива Массив2 в конец массива Массив1.
// Параметры:
 //   Массив1 {Массив}
 //     Массив, в который добавляются элементы.
 //   Массив2 {Массив}
 //     Массив, элементы которого добавляются.
///
Процедура ПрисоединитьУникальные(Массив1, Массив2) Экспорт
	Для Каждого Элемент_ Из Массив2 Цикл
		ДобавитьУникальное(Массив1, Элемент_);
	КонецЦикла;
КонецПроцедуры

/// Нижняя граница (двоичный поиск)
//


//


//
//
// Параметры:
//   Массив - Массив, ТаблицаЗначений, ДанныеФормыКоллекция, Табличная часть -
//     Контейнер для поиска.
//   Значение - Произвольный, Структура -
//     Искомое значение.
//     Если задана структура, то поиск осуществляется по значениям в колонках,
//     совпадающих с ключами структуры. ИмяКолонки в этом случае должно быть пустым.
//   ИмяКолонки - Строка -
//     Имя колонки, по которой выполняется поиск. По умолчанию - пустая строка.
//   Начало - Число - 
//     Индекс, начиная с которого осуществляется поиск.
//     По умолчанию равен 0.
//   Конец - Число, Неопределено -
//     Первый индекс, который не должен участвовать в поиске.
//     Если не заполнен, то считается равным Массив.Количество().
//   Шаг - Число -
//     В поиске будут участвовать только элементы массива, индексы которых
//     равны НачальныйИндекс + k*Шаг, для некоторого неотрицательного k.
//     По умолчанию равен 1.
//
// Возвращаемое значение:
//   Число - число i, такое что (i - Начало) кратно Шаг, и выполнено одно из:
//     1) i = Начало И Начало > КонечныйИндекс // Пустой массив
//     2) i = Начало + Шаг * Потолок((Конец - Начало)/Шаг) И Массив[i-Шаг] < Значение // Все меньше
//     3) i = Начало И Значение <= Массив[i] И i < Конец // Все не больше
//     4) Массив[i-Шаг] < Значение <= Массив[i] И i-Шаг >= Начало И i < Конец // Основной
///
Функция НижняяГраница(Массив, Значение, ИмяКолонки = "", Знач Начало = 0, Знач Конец = Неопределено, Шаг = 1) Экспорт
	
	Если Неопределено = Конец Тогда
		Конец = Массив.Количество();
	КонецЕсли;
	
	Если Конец <= Начало Тогда
		Возврат Начало;
	КонецЕсли;
	
	Невязка_ = (Конец - Начало) % Шаг;
	Если Не 0 = Невязка_ Тогда
		Конец = Конец + Шаг - Невязка_;
	КонецЕсли;
	
	Если Не ПустаяСтрока(ИмяКолонки) Тогда
		Возврат НижняяГраницаВТаблице(Массив, Значение, ИмяКолонки, Начало, Конец, Шаг);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура") Тогда
		
		// Пройдемся по структуре, исключая послений элемент.
		Индекс_ = Значение.Количество();
		Для Каждого КлючИЗначение_ Из Значение Цикл
			
			// Запомним ключ и значение.
			ИмяКолонки_ = КлючИЗначение_.Ключ;
			ЗначениеКолонки_ = КлючИЗначение_.Значение;
			
			// Это последний элемент структуры?
			Индекс_ = Индекс_ - 1;
			Если 0 = Индекс_ Тогда
				Прервать;
			КонецЕсли;
			
			// Определим субинтервал дальнейшего поиска.
			Диапазон_ = ИнтервалРавныхВТаблице(Массив, ЗначениеКолонки_, ИмяКолонки_, Начало, Конец, Шаг);
			Начало = Диапазон_.Начало;
			Конец = Диапазон_.Конец;
			
		КонецЦикла;
		
		// В последнем субинтервале выполним двоичный поиск.
		Возврат НижняяГраницаВТаблице(Массив, ЗначениеКолонки_, ИмяКолонки_, Начало, Конец, Шаг);
		
	КонецЕсли;
	
	Возврат НижняяГраницаВМассиве(Массив, Значение, Начало, Конец, Шаг);
	
КонецФункции

/// Верхняя граница (двоичный поиск)
//


//
// Параметры:
//   Массив - Массив, ТаблицаЗначений, ДанныеФормыКоллекция, Табличная часть -
//     Контейнер для поиска.
//   Значение - Произвольный, Структура -
//     Искомое значение.
//     Если задана структура, то поиск осуществляется по значениям в колонках,
//     совпадающих с ключами структуры. ИмяКолонки в этом случае должно быть пустым.
//   ИмяКолонки - Строка -
//     Имя колонки, по которой выполняется поиск. По умолчанию - пустая строка.
//   Начало - Число - 
//     Индекс, начиная с которого осуществляется поиск.
//     По умолчанию равен 0.
//   Конец - Число, Неопределено -
//     Первый индекс, который не должен участвовать в поиске.
//     Если не заполнен, то считается равным Массив.Количество().
//   Шаг - Число -
//     В поиске будут участвовать только элементы массива, индексы которых
//     равны НачальныйИндекс + k*Шаг, для некоторого неотрицательного k.
//     По умолчанию равен 1.
//
// Возвращаемое значение:
//   Число - число i, такое что (i - Начало) кратно Шаг, и выполнено одно из:
//     1) i = Начало И Начало > КонечныйИндекс // Пустой массив
//     2) i = Начало + Шаг * Потолок((Конец - Начало)/Шаг) И Массив[i-Шаг] <= Значение // Все не больше
//     3) i = Начало И Значение < Массив[i] И i < Конец // Все меньше
//     4) Массив[i-Шаг] <= Значение < Массив[i] И i-Шаг >= Начало И i < Конец // Основной
///
Функция ВерхняяГраница(Массив, Значение, ИмяКолонки = "", Начало = 0, Знач Конец = Неопределено, Шаг = 1) Экспорт
	
	Если Неопределено = Конец Тогда
		Конец = Массив.Количество();
	КонецЕсли;
	
	Если Конец <= Начало Тогда
		Возврат Начало;
	КонецЕсли;
	
	Невязка_ = (Конец - Начало) % Шаг;
	Если Не 0 = Невязка_ Тогда
		Конец = Конец + Шаг - Невязка_;
	КонецЕсли;
	
	Если Не ПустаяСтрока(ИмяКолонки) Тогда
		Возврат ВерхняяГраницаВТаблице(Массив, Значение, ИмяКолонки, Начало, Конец, Шаг);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура") Тогда
		
		// Пройдемся по структуре, исключая послений элемент.
		Индекс_ = Значение.Количество();
		Для Каждого КлючИЗначение_ Из Значение Цикл
			
			// Запомним ключ и значение.
			ИмяКолонки_ = КлючИЗначение_.Ключ;
			ЗначениеКолонки_ = КлючИЗначение_.Значение;
			
			// Это последний элемент структуры?
			Индекс_ = Индекс_ - 1;
			Если 0 = Индекс_ Тогда
				Прервать;
			КонецЕсли;
			
			// Определим субинтервал дальнейшего поиска.
			Диапазон_ = ИнтервалРавныхВТаблице(Массив, ЗначениеКолонки_, ИмяКолонки_, Начало, Конец, Шаг);
			Начало = Диапазон_.Начало;
			Конец = Диапазон_.Конец;
			
		КонецЦикла;
		
		// В последнем субинтервале выполним двоичный поиск.
		Возврат ВерхняяГраницаВТаблице(Массив, ЗначениеКолонки_, ИмяКолонки_, Начало, Конец, Шаг);
		
	КонецЕсли;
	
	Возврат ВерхняяГраницаВМассиве(Массив, Значение, Начало, Конец, Шаг);
	
КонецФункции

/// Аналог функции std::equal_range для таблицы
//


//
// Параметры:
//   Массив - Массив, ТаблицаЗначений, ДанныеФормыКоллекция, Табличная часть -
//     Контейнер для поиска.
//   Значение - Произвольный, Структура -
//     Искомое значение.
//     Если задана структура, то поиск осуществляется по значениям в колонках,
//     совпадающих с ключами структуры. ИмяКолонки в этом случае должно быть пустым.
//   ИмяКолонки - Строка -
//     Имя колонки, по которой выполняется поиск. По умолчанию - пустая строка.
//   Начало - Число - 
//     Индекс, начиная с которого осуществляется поиск.
//     По умолчанию равен 0.
//   Конец - Число, Неопределено -
//     Первый индекс, который не должен участвовать в поиске.
//     Если не заполнен, то считается равным Массив.Количество().
//   Шаг - Число -
//     В поиске будут участвовать только элементы массива, индексы которых
//     равны НачальныйИндекс + k*Шаг, для некоторого неотрицательного k.
//     По умолчанию равен 1.
//
// Возвращаемое значение:
//   Структура - Структура с полями Начало и Конец, при этом
//     Начало = НижняяГраница(Массив, Значение, Начало, Конец, Шаг),
//     Конец = ВерхняяГраница(Массив, Значение, Начало, Конец, Шаг).
///
Функция ИнтервалРавных(Массив, Значение, ИмяКолонки = "", Знач Начало = 0, Знач Конец = Неопределено, Шаг = 1) Экспорт
	
	Если Неопределено = Конец Тогда
		Конец = Массив.Количество();
	КонецЕсли;
	
	Если Конец <= Начало Тогда
		Возврат Начало;
	КонецЕсли;
	
	Невязка_ = (Конец - Начало) % Шаг;
	Если Не 0 = Невязка_ Тогда
		Конец = Конец + Шаг - Невязка_;
	КонецЕсли;
	
	Если Не ПустаяСтрока(ИмяКолонки) Тогда
		Возврат ИнтервалРавныхВТаблице(Массив, Значение, ИмяКолонки, Начало, Конец, Шаг);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура") Тогда
		Диапазон_ = Новый Структура("Начало, Конец", Начало, Конец);
		Для Каждого КлючИЗначение_ Из Значение Цикл
			// Определим субинтервал дальнейшего поиска.
			Диапазон_ = ИнтервалРавныхВТаблице(
				Массив, КлючИЗначение_.Значение, КлючИЗначение_.Ключ, Диапазон_.Начало, Диапазон_.Конец, Шаг
			);
		КонецЦикла;
		Возврат Диапазон_;
	КонецЕсли;
	
	Возврат ИнтервалРавныхВМассиве(Массив, Значение, Начало, Конец, Шаг);
	
КонецФункции

#Область Реализация

/// Вспомогательная функция для функции НижняяГраница для массива
Функция НижняяГраницаВМассиве(Массив, Значение, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Массив[Середина_] < Значение Тогда
			Начало = Середина_ + Шаг;
		Иначе
			Конец = Середина_;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Начало;
	
КонецФункции

/// Вспомогательная функция для функции НижняяГраница для таблицы
Функция НижняяГраницаВТаблице(Таблица, Значение, ИмяКолонки, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Таблица[Середина_][ИмяКолонки] < Значение Тогда
			Начало = Середина_ + Шаг;
		Иначе
			Конец = Середина_;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Начало;
	
КонецФункции

/// Вспомогательная функция для функции ВерхняяГраница для массива
Функция ВерхняяГраницаВМассиве(Массив, Значение, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Значение < Массив[Середина_] Тогда
			Конец = Середина_;
		Иначе
			Начало = Середина_ + Шаг;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Начало;
	
КонецФункции

/// Вспомогательная функция для функции ВерхняяГраница для таблиц
Функция ВерхняяГраницаВТаблице(Таблица, Значение, ИмяКолонки, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Значение < Таблица[Середина_][ИмяКолонки] Тогда
			Конец = Середина_;
		Иначе
			Начало = Середина_ + Шаг;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Начало;
	
КонецФункции

/// Вспомогательная функция для функции ИнтервалРавных для массива
Функция ИнтервалРавныхВМассиве(Массив, Значение, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Массив[Середина_] < Значение Тогда
			Начало = Середина_ + Шаг;
		ИначеЕсли Значение < Массив[Середина_] Тогда
			Конец = Середина_;
		Иначе
			Начало = НижняяГраницаВМассиве(Массив, Значение, Начало, Середина_, Шаг);
			Конец = ВерхняяГраницаВМассиве(Массив, Значение, Середина_ + Шаг, Конец, Шаг);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Начало, Конец", Начало, Конец);
	
КонецФункции

/// Вспомогательная функция для функции ИнтервалРавных для таблицы
Функция ИнтервалРавныхВТаблице(Таблица, Значение, ИмяКолонки, Знач Начало, Знач Конец, Шаг)
	
	Пока Начало < Конец Цикл
		Середина_ = Начало + Шаг * Цел((Конец - Начало) / 2 / Шаг);
		Если Таблица[Середина_][ИмяКолонки] < Значение Тогда
			Начало = Середина_ + Шаг;
		ИначеЕсли Значение < Таблица[Середина_][ИмяКолонки] Тогда
			Конец = Середина_;
		Иначе
			Начало = НижняяГраницаВТаблице(Таблица, Значение, ИмяКолонки, Начало, Середина_, Шаг);
			Конец = ВерхняяГраницаВТаблице(Таблица, Значение, ИмяКолонки, Середина_ + Шаг, Конец, Шаг);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Начало, Конец", Начало, Конец);
	
КонецФункции

#КонецОбласти

/// ВАЖНО!!! Не следует использовать эту функцию! Хотя бы в цикле.
//
// Процедура крайне неэффективна при использовании в цикле.
// В цикле лучше поместить элементы в соответствие, а затем преобразовать его в массив.
// См. функции МассивВСоответствие и ПолучитьКлючиВМассиве.
//
// Процедура: ДобавитьУникальное
//   Процедура добавляет Значение в конец массива Массив1, если его нет в массиве.
// Параметры:
//   Массив - Массив -
//     Массив, в который добавляются элементы.
//   Значение - Произвольный -
//     Добавляемое значение.
///
Процедура ДобавитьУникальное(Массив, Значение) Экспорт
	Если Массив.Найти(Значение) = Неопределено Тогда
		Массив.Добавить(Значение);
	КонецЕсли;
КонецПроцедуры

/// Слияние двух отсортированных массивов
//
// Параметры:
//   Массив1 - Массив -
//     Первый массив для слияния.
//   Массив2 - Массив -
//     Второй массив для слияния.
//
// Возвращаемое значение:
//   Массив - Массив, полученный слиянием массивов Массив1 и Массив2.
///
Функция Слияние(Массив1, Массив2) Экспорт
	Перем СлитыйМассив, Индекс1, Индекс2, Индекс, СчетчикЦикла;
	
	// Проверка параметров
	__ПРОВЕРКА__(ТипЗнч(Массив1) = Тип("Массив"), "Слияние: Несоответствие типа 1-го аргумента: " + ТипЗнч(Массив1) + ".");
	__ПРОВЕРКА__(ТипЗнч(Массив2) = Тип("Массив"), "Слияние: Несоответствие типа 2-го аргумента: " + ТипЗнч(Массив2) + ".");
	__ПРОВЕРКА__(Неубывающий(Массив1), "Слияние: Неотсортирован 1-й аргумент.");
	__ПРОВЕРКА__(Неубывающий(Массив2), "Слияние: Неотсортирован 2-й аргумент.");
	
	// Создаем массив с заданным числом элементов
	СлитыйМассив = Новый Массив(Массив1.Количество() + Массив2.Количество());
	
	// Инициализируем переменные цикла
	Индекс1 = Массив1.Количество();
	Индекс2 = Массив2.Количество();
	Индекс = СлитыйМассив.Количество();
	
	// Цикл слияния
	Пока Не Индекс = 0 Цикл
		Индекс = Индекс - 1;
		__ПРОВЕРКА___ЦИКЛА(СчетчикЦикла, Массив1.Количество() + Массив2.Количество(), "Слияние: Зацикливание.");
		
		Если Не Индекс1 = 0 И (Индекс2 = 0 Или Не Массив1[Индекс1-1] < Массив2[Индекс2-1]) Тогда
			Индекс1 = Индекс1 - 1;
			СлитыйМассив[Индекс] = Массив1[Индекс1];
		ИначеЕсли Не Индекс2 = 0 И (Индекс1 = 0 Или Массив1[Индекс1-1] < Массив2[Индекс2-1]) Тогда
			Индекс2 = Индекс2 - 1;
			СлитыйМассив[Индекс] = Массив2[Индекс2];
		Иначе
			__ПРОВЕРКА__(Ложь, "Слияние: Ошибка в реализации алгоритма.");
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка постусловия
	__ПРОВЕРКА__(Неубывающий(СлитыйМассив), "Слияние: Ошибка при проверке постусловия.");
	
	// Возвращаем результат
	Возврат СлитыйМассив;
	
КонецФункции

/// Многопутевое слияние отсортированных массивов
//
// В текущей реализации функции предполагается, что число массивов невелико,
// поэтому для поиска минимального ключа по множеству массивов используется
// перебор. При необходимости, для поиска минимального ключа можно использовать
// более эффективные алгоритмы, например очередь с приоритетом на основе кучи,
// реализация которой есть в общем модуле Куча.
//
// Параметры:
//   МассивМассивов - Массив -
//     Массив отсортированных по неубыванию ключей массивов. Ключами являются элементы,
//     индексы которых нацело делятся на Шаг. Остальные элементы - вагончики паровозика,
//     локомотивом которого является ключ. Например, если i - это индекс ключа, то
//     паровозиком будет подмассив элементов с индексами i, i+1, i+2, ..., i+Шаг-1.
//   Шаг - Число -
//     Ключевыми элементами массивов, то есть элементами, по которым выполняется сравнение
//     является элементы, индекс которых нацело делится на шаг. Остальные, просто копируются
//     в результат. Более формально, если в результат должен попасть i-й элемент j-го массива,
//     причем (i % Шаг = 0), то в реузльтат добавляется не только i-й элемент j-го массива,
//     но и элементы j-го массива с индексами i+1, i+2, ... i+Шаг-1.
//   Политики - Число -
//     Флаги, определяющие поведение функции.
//     0x01: Если установлен, то подразумевается, что массивы и результат
//           отсортированы по невозрастанию.
//     0x02: Если установлен, то в случае, когда все, кроме быть может одного, массивы пусты,
//           в качестве результата будет возвращен один из переданных массивов.
//     0x04: Если установлен, то разрешено изменять содержимое МассиваМассивов.
//           Данный флаг имеет смысл устанавливать, если МассивМассивов в вызывающей функции
//           не планируется больше использовать.
//
// Возвращаемое значение:
//   Массив - Массив, в котором содержатся все ключи и соответствующие им данные,
//     цепляемые паровозиком при Шаге > 1, из всех массивов, отсортированные
//     в неубывающем порядке.
///
Функция МногопутевоеСлияние(МассивМассивов, Шаг = 1, Политики = 0) Экспорт
	
	__ПРОВЕРКА__(0 = ПобитовоеИ(Политики, 1), "Многопутевое слияние невозрастающих массивов не реализовано.");
	
	// Подсчитаем количество элементов в результирующем массиве.
	КолВо_ = 0;
	Для Каждого Массив_ Из МассивМассивов Цикл
		КолВо_ = КолВо_ + Массив_.Количество();
	КонецЦикла;
	
	// Если все массивы пусты, кроме, быть может, одного, вернем его.
	Если Не 0 = ПобитовоеИ(Политики, 2) Тогда
		Для Каждого Массив_ Из МассивМассивов Цикл
			Если Массив_.Количество() = КолВо_ Тогда
				Возврат Массив_;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Если МассивМассивов пуст, вернем пустой массив.
	Если КолВо_ = 0 Тогда
		Возврат Новый Массив;
	КонецЕсли;
	
	// Подготовим массив для хранения результата.
	Результат_ = Новый Массив(КолВо_);
	
	// Скопируем МассивМассивов в отдельную переменную, чтобы можно было её изменять,
	// и оставим в ней только массивы ненулевого размера.
	Массивы_ = МассивМассивов;
	Если 0 = ПобитовоеИ(Политики, 4) Тогда
		Массивы_ = Новый Массив;
		Для Каждого Массив_ Из МассивМассивов Цикл
			Если 0 = Массив_.Количество() Тогда
				Массивы_.Добавить(Массив_);
			КонецЕсли;
		КонецЦикла;
	Иначе
		ИндексМассива_ = Массивы_.Количество();
		Пока Не 0 = ИндексМассива_ Цикл
			ИндексМассива_ = ИндексМассива_ - 1;
			Если 0 = Массивы_[ИндексМассива_].Количество() Тогда
				Массивы_.Удалить(ИндексМассива_);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	// Создадим массив индексов, которые будут пробегать по каждому массиву.
	// В дальнейшем при достижении конца одного из массивов, соответствующй
	// элемент будем удалять из массивов Индексы_ и Массивы_.
	Индексы_ = Новый Массив(МассивМассивов.Количество());
	Для ИндексМассива_ = 0 По МассивМассивов.Количество() - 1 Цикл
		Индексы_[ИндексМассива_] = 0;
	КонецЦикла;
	
	ИндексРезультата_ = 0;
	Пока Не ИндексРезультата_ = КолВо_ Цикл
		
		// Найдем индекс массива с минимальной текущей позицией.
		// Можно было использовать кучу, но быстрее перебор пяти элементов.
		ИндексМин_ = 0;
		МинЗнач_ = Массивы_[ИндексМин_][Индексы_[ИндексМин_]];
		Для ИндексМассива_ = 1 По Индексы_.Количество() - 1 Цикл
			Если Массивы_[ИндексМассива_][Индексы_[ИндексМассива_]] < МинЗнач_ Тогда
				ИндексМин_ = ИндексМассива_;
				МинЗнач_ = Массивы_[ИндексМин_][Индексы_[ИндексМин_]];
			КонецЕсли;
		КонецЦикла;
		
		// Для удобства введем переменные
		Массив_ = Массивы_[ИндексМин_];
		ИндексВМассиве_ = Индексы_[ИндексМин_];
		Для Смещение_ = 0 По Шаг - 1 Цикл
			Результат_[ИндексРезультата_ + Смещение_] = Массив_[ИндексВМассиве_ + Смещение_];
		КонецЦикла;
		
		// Сделаем приращение индексов на шаг.
		ИндексРезультата_ = ИндексРезультата_ + Шаг;
		ИндексВМассиве_ = ИндексВМассиве_ + Шаг;
		
		// Если дошли до конца одного из массивов, удалим его из рассмотрения.
		// В противном случае запишем новое значение индекса в этом массиве.
		Если ИндексВМассиве_ = Массив_.Количество() Тогда
			Индексы_.Удалить(ИндексМин_);
			Массивы_.Удалить(ИндексМин_);
		Иначе
			Индексы_[ИндексМин_] = ИндексВМассиве_;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат_;
	
КонецФункции

///
// Функция: Пересечение
//   Производит пересечение двух массивов.
//
// Параметры:
//   Массив1 {Массив}
//     Первый массив для пересечения.
//   Массив2 {Массив}
//     Второй массив для пересечения.
//
// Возврат: {Массив}
//   Массив, содержащий только общие элементы из Массив1 и Массив2.
///
Функция Пересечение(Массив1, Массив2) Экспорт
	Перем СлитыйМассив, Индекс1, Индекс2, Индекс, СчетчикЦикла;
	
	// Проверка параметров
	__ПРОВЕРКА__(ТипЗнч(Массив1) = Тип("Массив"), "Пересечение: Несоответствие типа 1-го аргумента: " + ТипЗнч(Массив1) + ".");
	__ПРОВЕРКА__(ТипЗнч(Массив2) = Тип("Массив"), "Пересечение: Несоответствие типа 2-го аргумента: " + ТипЗнч(Массив2) + ".");
	
	Пересечение = Новый Соответствие();
	МассивПересечения = Новый Массив();
	
	Для Каждого Элемент Из Массив1 Цикл
		Если Пересечение.Получить(Элемент) = Неопределено Тогда
			Пересечение.Вставить(Элемент, ИСТИНА);
		КонецЕсли;
	КонецЦикла;
	Для Каждого Элемент Из Массив2 Цикл
		Если Пересечение.Получить(Элемент) = ИСТИНА Тогда
			МассивПересечения.Добавить(Элемент);
			Пересечение.Вставить(Элемент, ЛОЖЬ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивПересечения;
	
КонецФункции

/// Массив элементов первого контейнера, не встечащихся во втором
Функция Разность(Контейнер1, Контейнер2) Экспорт
	
	__ПРОВЕРКА__(ТипЗнч(Контейнер1) = ТипЗнч(Контейнер2), "67e859ea-723a-11ea-8ae2-eb0c4a1a8d03");
	
	Если ТипЗнч(Контейнер1) = Тип("ТаблицаЗначений") Тогда
		
		Результат_ = Новый Массив;
		
		ИменаКолонок_ = Новый Массив;
		Для Каждого Колонка_ Из Контейнер1.Колонки Цикл
			Если Не Неопределено = Контейнер2.Колонки.Найти(Колонка_.Имя) Тогда
				ИменаКолонок_.Добавить(Колонка_.Имя);
			КонецЕсли;
		КонецЦикла;
		Отбор_ = Новый Структура(СтрСоединить(ИменаКолонок_, ","));
		
		Для Каждого ЭлементКонтейнера_ Из Контейнер1 Цикл
			ЗаполнитьЗначенияСвойств(Отбор_, ЭлементКонтейнера_);
			Если 0 = Контейнер2.НайтиСтроки(Отбор_).Количество() Тогда
				Результат_.Добавить(ЭлементКонтейнера_);
			КонецЕсли;
		КонецЦикла;
		
		Возврат Результат_;
			
	КонецЕсли;
		
	__ПРОВЕРКА__(Ложь, "3e5a34a4-723a-11ea-96a7-5324abc294cc");
	
КонецФункции

// Формирует новый массив уникальных элементов исходного сортированного массива.
//
// Параметры:
//   СортированныйМассив - Массив - Отсортированный массив.
//
// Возвращаемое значение:
//   Массив - Новый массив, содержащий неповторяющиеся элементы исходного массива в том же порядке.
//
Функция ПолучитьУникальные(СортированныйМассив) Экспорт
	Если 0 = СортированныйМассив.Количество() Тогда
		Возврат Новый Массив;
	КонецЕсли;
	// Сначала определим количество элементов в результирующем массиве,
	// исходя из того, что изменение размера массива может выполняться не за константное время.
	КоличествоРазличных_ = 1;
	Для Индекс_ = 1 По СортированныйМассив.Количество() - 1 Цикл
		Если Не СортированныйМассив[Индекс_ - 1] = СортированныйМассив[Индекс_] Тогда
			КоличествоРазличных_ = 1 + КоличествоРазличных_;
		КонецЕсли;
	КонецЦикла;
	МассивУникальных_ = Новый Массив(КоличествоРазличных_);
	МассивУникальных_[0] = СортированныйМассив[0];
	ИндексМассиваУникальных_ = 1;
	Для Индекс_ = 1 По СортированныйМассив.Количество() - 1 Цикл
		Если Не СортированныйМассив[Индекс_ - 1] = СортированныйМассив[Индекс_] Тогда
			МассивУникальных_[ИндексМассиваУникальных_] = СортированныйМассив[Индекс_];
			ИндексМассиваУникальных_ = 1 + ИндексМассиваУникальных_;
		КонецЕсли;
	КонецЦикла;
	Возврат МассивУникальных_;
КонецФункции

////
 // Функция: Неубывающий
 //   Проверяет, что элементы в контейнере расположены в неубывающем порядке.
 //
 // Параметры:
 //   Контейнер {Массив, Табличная часть}
 //     Контейнер, который нужно проверить.
 //   Колонка {Строка}
 //     Имя колонки, по которой нужно производить проверку,
 //     если контейнер - табличная часть.
 //
 // Возврат: {Булево}
 //   Истина, если элементы в контейнере расположены в неубывающем порядке,
 //   Ложь, в противном случае.
 ///
Функция Неубывающий(Контейнер, Колонка = Неопределено) Экспорт
	Если ТипЗнч(Контейнер) = Тип("Массив") И Колонка = Неопределено Тогда
		Возврат НеубывающийМассив(Контейнер);
	ИначеЕсли ТипЗнч(Колонка) = Тип("Строка") Тогда
		// Считаем, что это табличная часть
		Возврат НеубывающийТабличнаяЧасть(Контейнер, Колонка);
	КонецЕсли;
	
	__ПРОВЕРКА__(Ложь, "Неубывающий: Неопределенный тип контейнера: " + ТипЗнч(Контейнер) + ".");
	Возврат Ложь;
	
КонецФункции

////
 // Функция: НеубывающийМассив
 //   Проверяет, что элементы в массиве расположены в неубывающем порядке.
 //
 // Параметры:
 //   Массив {Массив}
 //     Массив, который нужно проверить.
 //
 // Возврат:
 //   Истина, если элементы в массиве расположены в неубывающем порядке,
 //   Ложь, в противном случае.
 ///
Функция НеубывающийМассив(Массив)
	Перем Индекс;
	
	// Проверка параметров
	__ПРОВЕРКА__(ТипЗнч(Массив) = Тип("Массив"), "Неубывающий: Несоответствие типа 1-го аргумента.");
	
	// Проверяем в цикле
	Индекс = Массив.Количество();
	Пока Индекс > 1 Цикл
		Индекс = Индекс - 1;
		
		// Непорядок?
		Если Не Массив[Индекс - 1] <= Массив[Индекс] Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	// Все в порядке
	Возврат Истина;
	
КонецФункции

////
 // Функция: НеубывающийТабличнаяЧасть
 //   Проверяет, что элементы в колонке табличной части расположены
 //   в неубывающем порядке.
 //
 // Параметры:
 //   ТабличнаяЧасть {Табличная часть}
 //     ТабличнаяЧасть, которую нужно проверить.
 //   Колонка {Строка}
 //     Колонка, по которой нужно проверить порядок.
 //
 // Возврат:
 //   Истина, если элементы в колонке табличной части расположены
 //   в неубывающем порядке, Ложь, в противном случае.
 ///
Функция НеубывающийТабличнаяЧасть(ТабличнаяЧасть, Колонка)
	Перем Массив;
	
	// Проверка параметров
	__ПРОВЕРКА__(ТипЗнч(Колонка) = Тип("Строка"), "НеубывающийТабличнаяЧасть: Несоответствие типа 2-го аргумента: " + ТипЗнч(Колонка) + ".");
	
	Массив = ТабличнаяЧасть.ВыгрузитьКолонку(Колонка);
	
	Возврат НеубывающийМассив(Массив);
	
КонецФункции

////
 // Функция: СтрогоВозрастающий
 //   Проверяет, что элементы в массиве расположены в строго возрастающем порядке.
 //
 // Параметры:
 //   Массив {Массив}
 //     Массив, который нужно проверить.
 //
 // Возврат:
 //   Истина, если элементы в массиве расположены в неубывающем порядке, Ложь, в противном случае.
 ///
Функция СтрогоВозрастающий(Массив) Экспорт
	Перем Индекс;
	
	// Проверка параметров
	__ПРОВЕРКА__(ТипЗнч(Массив) = Тип("Массив"), "СтрогоВозрастающий: Несоответствие типа 1-го аргумента.");
	
	// Проверяем в цикле
	Индекс = Массив.Количество();
	Пока Индекс > 1 Цикл
		Индекс = Индекс - 1;
		
		// Непорядок?
		Если Не Массив[Индекс - 1] < Массив[Индекс] Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	// Все в порядке
	Возврат Истина;
	
КонецФункции

////
 // Функция: БыстраяСортировка
 //   Сортирует переданный массив
 //
 // Параметры:
 //   Массив{Массив} 
 //     массив, который необходимо отсортировать.
 //   Слева 
 //     крайний левый символ, по умолчанию 0.
 //   Справа 
 //     крайний правый символ, по умолчанию РазмерМассива-1.
 ///
Процедура БыстраяСортировкаМассива(Массив, Слева = Неопределено, Справа = Неопределено) Экспорт
	Слева = ?(Слева = Неопределено, 0, Слева);
	Справа = ?(Справа = Неопределено, Массив.Количество() - 1, Справа);
	ЛевыйИндекс_ = Слева;
	ПравыйИндекс_ = Справа;
	Если Массив.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	Значение_ = Массив[Окр((Слева + Справа) / 2, 0)];
	Пока ЛевыйИндекс_ <= ПравыйИндекс_ Цикл
		Пока Массив[ЛевыйИндекс_] < Значение_ Цикл
			ЛевыйИндекс_ = ЛевыйИндекс_ + 1;
		КонецЦикла;
		Пока  Массив[ПравыйИндекс_] > Значение_ Цикл
			ПравыйИндекс_ = ПравыйИндекс_ - 1;
		КонецЦикла;
		Если ЛевыйИндекс_ <= ПравыйИндекс_ Тогда
			Если ЛевыйИндекс_ < ПравыйИндекс_ Тогда
				ВременноеЗначение_ = Массив[ЛевыйИндекс_];
				Массив[ЛевыйИндекс_] = Массив[ПравыйИндекс_];
				Массив[ПравыйИндекс_] = ВременноеЗначение_;
			КонецЕсли;
			ЛевыйИндекс_ = ЛевыйИндекс_ + 1;
			ПравыйИндекс_ = ПравыйИндекс_ - 1;
		КонецЕсли;
	КонецЦикла;
	Если ЛевыйИндекс_ < Справа  Тогда
		БыстраяСортировкаМассива(Массив, ЛевыйИндекс_, Справа);
	КонецЕсли;
	Если Слева < ПравыйИндекс_ Тогда
		БыстраяСортировкаМассива(Массив, Слева,ПравыйИндекс_);
	КонецЕсли;	
КонецПроцедуры

////
 // Функция: БыстраяСортировка
 //   Сортирует переданный массив
 //
 // Параметры:
 //   Массив{Массив} 
 //     массив, который необходимо отсортировать.
 //   Слева 
 //     крайний левый символ, по умолчанию 0.
 //   Справа 
 //     крайний правый символ, по умолчанию РазмерМассива-1.
  //   ФункцияСортировки 
 //     номер функции, которая будет обрабатывать сравнение.
 ///
Процедура БыстраяСортировкаМассиваПереопределяемая(Массив, Слева, Справа, ФункцияСравнения=Неопределено, ДополнительныйПараметр = Неопределено) Экспорт
	Перем л_,п_;
	Если Массив.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	л_ = ?(Слева=неопределено,0,Слева);
	п_ = ?(Справа=неопределено,Массив.Количество()-1,Справа);
	х_ = Массив[Окр((Слева+Справа)/2,0)];
	Пока л_ <= п_ Цикл
		Пока ОпределитьФункциюСравнения(ФункцияСравнения,Массив[л_], х_, ДополнительныйПараметр)=-1 Цикл
			л_=л_+1;
		КонецЦикла;
		Пока ОпределитьФункциюСравнения(ФункцияСравнения,Массив[п_], х_, ДополнительныйПараметр)=1 Цикл
			п_=п_-1;
		КонецЦикла;
		Если л_ <= п_ Тогда
			Если л_ < п_ Тогда
				к_=Массив[л_];
				Массив[л_]= Массив[п_];
				Массив[п_]= к_;
			КонецЕсли;
			л_=л_+1;
			п_=п_-1;
		КонецЕсли;
	КонецЦикла;
	Если л_ < Справа  Тогда
		БыстраяСортировкаМассиваПереопределяемая(Массив, л_, Справа, ФункцияСравнения, ДополнительныйПараметр);
	КонецЕсли;
	Если Слева < п_ Тогда
		БыстраяСортировкаМассиваПереопределяемая(Массив, Слева, п_, ФункцияСравнения, ДополнительныйПараметр);
	КонецЕсли;
	
КонецПроцедуры

Процедура СортировкаПодсчетомРаспределенияПоУбыванию(МассивЦелыхЧисел) Экспорт
	
	КолВо_ = МассивЦелыхЧисел.Количество();
	
	Если КолВо_ <= 1 Тогда
		Возврат;
	КонецЕсли;
	
	// Для начала найдем границы распределения.
	Мин_ = МассивЦелыхЧисел[0];
	Макс_ = Мин_;
	ПредыдущееЧисло_ = Мин_;
	НарушениеПорядка_ = Ложь;
	Для Каждого ЦелоеЧисло_ Из МассивЦелыхЧисел Цикл
		Если Макс_ < ЦелоеЧисло_ Тогда
			Макс_ = ЦелоеЧисло_;
		ИначеЕсли ЦелоеЧисло_ < Мин_ Тогда
			Мин_ = ЦелоеЧисло_;
		КонецЕсли;
		Если Ложь = НарушениеПорядка_ И ПредыдущееЧисло_ < ЦелоеЧисло_ Тогда
			НарушениеПорядка_ = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не Истина = НарушениеПорядка_ Тогда
		// Массив уже упорядочен по убыванию.
		Возврат;
	КонецЕсли;
	
	Распределение_ = Новый Массив(Макс_ - Мин_ + 1);
	
	Для Каждого ЦелоеЧисло_ Из МассивЦелыхЧисел Цикл
		Индекс_ = ЦелоеЧисло_ - Мин_;
		Распределение_[Индекс_] = 1 + ВыбратьЗаполненное(Распределение_[Индекс_], 0);
	КонецЦикла;
	
	// Запишем числа в убывающем порядке.
	ИндексМассиваЦелыхЧисел_ = КолВо_;
	Для Индекс_ = 0 По Макс_ - Мин_ Цикл
		
		Если Не ЗначениеЗаполнено(Распределение_[Индекс_]) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Счетчик_ = 1 По Распределение_[Индекс_] Цикл
			ИндексМассиваЦелыхЧисел_ = ИндексМассиваЦелыхЧисел_ - 1;
			МассивЦелыхЧисел[ИндексМассиваЦелыхЧисел_] = Индекс_ + Мин_;
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

////
 // Функция: СравнитьЗначения
 //   Проверяет, что элементы в массиве расположены в строго возрастающем порядке.
 //
 // Параметры:
 //   Знач1 
 //     символ, который нужно сравнить.
 //   Знач2 
 //     символ, который нужно сравнить.
 // Возврат:
 //   1, если Знач1 больше Знач2, -1, если Знач1 меньше Знач2, 0, если значения равны.
 ///
Функция ОпределитьФункциюСравнения(НомерФункции = Неопределено, Знач1, Знач2, ДополнительныйПараметр = Неопределено) Экспорт
	Если НомерФункции = Неопределено Тогда
		Возврат СравнитьЗначения(Знач1, Знач2);
	КонецЕсли;
	Если НомерФункции=2 Тогда
		Возврат СравнитьЗначенияСтруктурПоПолю(Знач1,Знач2,ДополнительныйПараметр);
	КонецЕсли;
	Возврат 0;
КонецФункции

////
 // Функция: СравнитьЗначения
 //   Проверяет, что элементы в массиве расположены в строго возрастающем порядке.
 //
 // Параметры:
 //   Знач1 
 //     символ, который нужно сравнить.
 //   Знач2 
 //     символ, который нужно сравнить.
 // Возврат:
 //   1, если Знач1 больше Знач2, -1, если Знач1 меньше Знач2, 0, если значения равны.
 ///
Функция СравнитьЗначения(Знач1, Знач2) Экспорт
	Если Знач1>Знач2 Тогда
		Возврат 1;
	КонецЕсли;
	Если Знач1<Знач2 Тогда
		Возврат -1;
	КонецЕсли;
	Возврат 0;
КонецФункции

&НаСервере
////
 // Процедура: ЗаполнитьИндексыТаблицы
 //   Заполняет колонку Индекс переданной таблицы значениями индекса строки.
 //   При необходимости создает колонку Индекс.
 //
 // Параметры:
 //   Таблица_ {ТаблицаЗначений}
 //     Таблица, в которой нужно заполнить индексы.
 ///
Процедура ЗаполнитьИндексыТаблицы(Таблица_) Экспорт
	Если Таблица_.Колонки.Найти("Индекс") = Неопределено Тогда
		КвалификаторыЧисла_ = Новый КвалификаторыЧисла(5, 0, ДопустимыйЗнак.Неотрицательный);
		Таблица_.Колонки.Добавить("Индекс", Новый ОписаниеТипов("Число", КвалификаторыЧисла_));
	КонецЕсли;
	Для Каждого Строка_ Из Таблица_ Цикл
		Строка_.Индекс = Таблица_.Индекс(Строка_);
	КонецЦикла;
КонецПроцедуры

/// Случайное перемешивание элементов массива на месте
//
// Внимание! Меняется исходный массив.
//
// Параметры:
//   Массив - Массив -
//     Массив для перемешивания.
//
// Возвращаемое значение:
//   Массив - Ссылка на исходный массив, который был перемешан.
///
Функция Перемешать(Массив) Экспорт
	
	__ТИП__(Массив, "Массив", "19814f36-6661-11e9-8498-e755894b5b17");
	
	КолВо_ = Массив.Количество();
	
	Если КолВо_ <= 1 Тогда
		Возврат Массив;
	КонецЕсли;
	
	ГенераторСлучайныхЧисел_ = Новый ГенераторСлучайныхЧисел;
	
	ВременноеЗначение_ = Массив[0];
	Для Индекс_ = 0 По КолВо_ - 2 Цикл
		СлучайныйИндекс_ = ГенераторСлучайныхЧисел_.СлучайноеЧисло(Индекс_, КолВо_ - 1);
		Если СлучайныйИндекс_ = Индекс_ Тогда
			Массив[СлучайныйИндекс_] = ВременноеЗначение_;
			ВременноеЗначение_ = Массив[Индекс_ + 1];
		Иначе
			Массив[Индекс_] = Массив[СлучайныйИндекс_];
		КонецЕсли;
	КонецЦикла;
	Массив[КолВо_ - 1] = ВременноеЗначение_;
	
	Возврат Массив;
	
КонецФункции

 ////
 // Функция: СравнитьЗначенияСтруктур
 //   Проверяет все ли значений Новый Структура("совпадают", ) .
 //
 // Параметры:
 //   Структура1 
 //     структура чьи поля сравниваем.
 //   Структура2 
 //     Новый Структура("с которой стравниваем", ) .
 // Возврат:
 //   Истина, если все поля структуры1, найденные в структура2 совпадают.
 ///
Функция СравнитьЗначенияСтруктур(Структура1, Структура2) Экспорт
	ХотьОдноПолеСовпадает = Ложь;
	Для каждого Стр1 Из Структура1 Цикл
		Если Структура2.Свойство(Стр1.Ключ) Тогда
			Если Стр1.Значение = Структура2[Стр1.Ключ] Тогда
				ХотьОдноПолеСовпадает = Истина;
			Иначе
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Если ХотьОдноПолеСовпадает Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

 ////
 // Функция: СравнитьЗначенияСтруктурПоПолю
 //   Проверяет равенство значений поля в структурах.
 //
 // Параметры:
 //   Структура1 
 //     структура чьи поля сравниваем.
 //   Структура2 
 //     структура для сравнения .
 //   ИмяПоля 
 //     Ключ структуры . 
 // Возврат:
 //   1, если все поле структуры1 боле поля структуры 2, 1 если наоборот, 0 если равны.
 ///
Функция СравнитьЗначенияСтруктурПоПолю(Структура1, Структура2, ИмяПоля) Экспорт
	Если Структура1[ИмяПоля] > Структура2[ИмяПоля] Тогда
		Возврат 1;
	КонецЕсли;
	Если Структура1[ИмяПоля] < Структура2[ИмяПоля] Тогда
		Возврат -1;
	КонецЕсли;
	Возврат 0;
КонецФункции

////
 // Функция: НайтиПоПолю
 //   Поиск по значению поля в коллекции, возвращает индекс элемента в случае нахождения.
 //
 // Параметры:
 //   Коллекция
 //   ИмяПоля
 //   Значение
 //
 // Возврат: {Число, Неопределено}
 ///
Функция НайтиПоПолю(Коллекция, ИмяПоля, Значение) Экспорт
	Для Индекс_ = 0 По Коллекция.Количество() - 1 Цикл
		Элемент_ = Коллекция.Получить(Индекс_);
		Если Элемент_[ИмяПоля] = Значение Тогда
			Прервать;	
		КонецЕсли;
	КонецЦикла;
	Возврат ?(Индекс_ > Коллекция.Количество() - 1, Неопределено, Индекс_);
КонецФункции

// Найти максимальное значению по полю коллекции.
Функция Максимальный(Коллекция, ЗначениеПоУмолчанию = Неопределено, ИмяПоля = Неопределено) Экспорт
	
	Если 0 = Коллекция.Количество() Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Начальный_ = Коллекция[0];
	
	Если МагическиеКонстанты.СравнимыеТипы().СодержитТип(ТипЗнч(Начальный_)) Тогда
		Максимальный_ = Начальный_;
		Для Индекс_ = 1 По Коллекция.Количество() - 1 Цикл
			Если Максимальный_ < Коллекция[Индекс_] Тогда
				Максимальный_ = Коллекция[Индекс_];
			КонецЕсли;
		КонецЦикла;
		
		Возврат Максимальный_;
		
	КонецЕсли;
	
	Если ТипЗнч(Коллекция) = Тип("Структура") Тогда
		// Это псевдотаблица.
		Возврат Максимальный(Коллекция[ИмяПоля], ЗначениеПоУмолчанию);
	КонецЕсли;
	
	Максимальный_ = Начальный_[ИмяПоля];
	Для Индекс_ = 1 По Коллекция.Количество() - 1 Цикл
		Если Максимальный_ < Коллекция[Индекс_][ИмяПоля] Тогда
			Максимальный_ = Коллекция[Индекс_][ИмяПоля];
		КонецЕсли;
	КонецЦикла;

	Возврат Максимальный_;
	
КонецФункции

// Найти минимальное значению по полю коллекции.
Функция Минимальный(Коллекция, ЗначениеПоУмолчанию = Неопределено, ИмяПоля = Неопределено) Экспорт
	
	Если 0 = Коллекция.Количество() Тогда
		Возврат ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Начальный_ = Коллекция[0];
	
	Если МагическиеКонстанты.СравнимыеТипы().СодержитТип(ТипЗнч(Начальный_)) Тогда
		Минимальный_ = Начальный_;
		Для Индекс_ = 1 По Коллекция.Количество() - 1 Цикл
			Если Коллекция[Индекс_] < Минимальный_ Тогда
				Минимальный_ = Коллекция[Индекс_];
			КонецЕсли;
		КонецЦикла;
		
		Возврат Минимальный_;
		
	КонецЕсли;
	
	Если ТипЗнч(Коллекция) = Тип("Структура") Тогда
		// Это псевдотаблица.
		Возврат Минимальный(Коллекция[ИмяПоля], ЗначениеПоУмолчанию);
	КонецЕсли;
	
	Минимальный_ = Начальный_[ИмяПоля];
	Для Индекс_ = 1 По Коллекция.Количество() - 1 Цикл
		Если Коллекция[Индекс_][ИмяПоля] < Минимальный_ Тогда
			Минимальный_ = Коллекция[Индекс_][ИмяПоля];
		КонецЕсли;
	КонецЦикла;

	Возврат Минимальный_;
	
КонецФункции

Процедура УдалитьЗначения(Коллекция, Значение) Экспорт
	
	Индекс_ = Коллекция.Количество();
	Пока Не 0 = Индекс_ Цикл
		Индекс_ = Индекс_ - 1;
		Если Коллекция[Индекс_] = Значение Тогда
			Коллекция.Удалить(Индекс_);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Пронумеровать коллекцию по указанному полю.
Процедура Пронумеровать(Коллекция, ИмяПоля = "НомерСтроки") Экспорт
	Для Индекс_ = 0 По Коллекция.Количество() - 1 Цикл
		Коллекция[Индекс_][ИмяПоля] = 1 + Индекс_;
	КонецЦикла;
КонецПроцедуры

/// Создание соответствия
//
// Параметры:
//   Ключ01 - Строка -
//     Имя первого ключа соответствия.
//   Значение01 - Произвольный -
//     Значение первого ключа.
//   ...
//   Ключ29 - Строка -
//     Имя последнего ключа соответствия.
//   Значение29 - Произвольный -
//     Значение последнего ключа.
//
// Возвращаемое значение:
//   Соответствие с заданными ключами и значениями.
///
Функция СоздатьСоответствие // Экспорт, 58 параметров
(
	Ключ01 = '05710422152926', Значение01 = Неопределено,
	Ключ02 = '05710422152926', Значение02 = Неопределено,
	Ключ03 = '05710422152926', Значение03 = Неопределено,
	Ключ04 = '05710422152926', Значение04 = Неопределено,
	Ключ05 = '05710422152926', Значение05 = Неопределено,
	Ключ06 = '05710422152926', Значение06 = Неопределено,
	Ключ07 = '05710422152926', Значение07 = Неопределено,
	Ключ08 = '05710422152926', Значение08 = Неопределено,
	Ключ09 = '05710422152926', Значение09 = Неопределено,
	Ключ10 = '05710422152926', Значение10 = Неопределено,
	Ключ11 = '05710422152926', Значение11 = Неопределено,
	Ключ12 = '05710422152926', Значение12 = Неопределено,
	Ключ13 = '05710422152926', Значение13 = Неопределено,
	Ключ14 = '05710422152926', Значение14 = Неопределено,
	Ключ15 = '05710422152926', Значение15 = Неопределено,
	Ключ16 = '05710422152926', Значение16 = Неопределено,
	Ключ17 = '05710422152926', Значение17 = Неопределено,
	Ключ18 = '05710422152926', Значение18 = Неопределено,
	Ключ19 = '05710422152926', Значение19 = Неопределено,
	Ключ20 = '05710422152926', Значение20 = Неопределено,
	Ключ21 = '05710422152926', Значение21 = Неопределено,
	Ключ22 = '05710422152926', Значение22 = Неопределено,
	Ключ23 = '05710422152926', Значение23 = Неопределено,
	Ключ24 = '05710422152926', Значение24 = Неопределено,
	Ключ25 = '05710422152926', Значение25 = Неопределено,
	Ключ26 = '05710422152926', Значение26 = Неопределено,
	Ключ27 = '05710422152926', Значение27 = Неопределено,
	Ключ28 = '05710422152926', Значение28 = Неопределено,
	Ключ29 = '05710422152926', Значение29 = Неопределено
)
Экспорт
	
	Соответствие_ = Новый Соответствие;
	Мавлид_ = МагическиеКонстанты.НезаполненноеЗначение();
	
	Если Мавлид_ = Ключ02 Тогда
		Если Мавлид_ = Ключ01 Тогда
			Перейти ~Мекка00;
		Иначе
			Перейти ~Метка01;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ06 Тогда
		Если Мавлид_ = Ключ04 Тогда
			Если Мавлид_ = Ключ03 Тогда
				Перейти ~Метка02;
			Иначе
				Перейти ~Метка03;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ05 Тогда
			Перейти ~Метка04;
		Иначе
			Перейти ~Метка05;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ14 Тогда
		Если Мавлид_ = Ключ10 Тогда
			Если Мавлид_ = Ключ08 Тогда
				Если Мавлид_ = Ключ07 Тогда
					Перейти ~Метка06;
				Иначе
					Перейти ~Метка07;
				КонецЕсли;
			ИначеЕсли Мавлид_ = Ключ09 Тогда
				Перейти ~Метка08;
			Иначе
				Перейти ~Метка09;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ12 Тогда
			Если Мавлид_ = Ключ11 Тогда
				Перейти ~Метка10;
			Иначе
				Перейти ~Метка11;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ13 Тогда
			Перейти ~Метка12;
		Иначе
			Перейти ~Метка13;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ22 Тогда
		Если Мавлид_ = Ключ18 Тогда
			Если Мавлид_ = Ключ16 Тогда
				Если Мавлид_ = Ключ15 Тогда
					Перейти ~Метка14;
				Иначе
					Перейти ~Метка15;
				КонецЕсли;
			ИначеЕсли Мавлид_ = Ключ17 Тогда
				Перейти ~Метка16;
			Иначе
				Перейти ~Метка17;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ20 Тогда
			Если Мавлид_ = Ключ19 Тогда
				Перейти ~Метка18;
			Иначе
				Перейти ~Метка19;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ21 Тогда
			Перейти ~Метка20;
		Иначе
			Перейти ~Метка21;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ26 Тогда
		Если Мавлид_ = Ключ24 Тогда
			Если Мавлид_ = Ключ23 Тогда
				Перейти ~Метка22;
			Иначе
				Перейти ~Метка23;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Ключ25 Тогда
			Перейти ~Метка24;
		Иначе
			Перейти ~Метка25;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ28 Тогда
		Если Мавлид_ = Ключ27 Тогда
			Перейти ~Метка26;
		Иначе
			Перейти ~Метка27;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Ключ29 Тогда
		Перейти ~Метка28;
	Иначе
		Перейти ~Метка29;
	КонецЕсли;
	
	__ПРОВЕРКА__(Ложь, "АлгоритмыДляКоллекций.СоздатьСоответствие");
	
	~Метка29: Соответствие_.Вставить(Ключ29, Значение29);
	~Метка28: Соответствие_.Вставить(Ключ28, Значение28);
	~Метка27: Соответствие_.Вставить(Ключ27, Значение27);
	~Метка26: Соответствие_.Вставить(Ключ26, Значение26);
	~Метка25: Соответствие_.Вставить(Ключ25, Значение25);
	~Метка24: Соответствие_.Вставить(Ключ24, Значение24);
	~Метка23: Соответствие_.Вставить(Ключ23, Значение23);
	~Метка22: Соответствие_.Вставить(Ключ22, Значение22);
	~Метка21: Соответствие_.Вставить(Ключ21, Значение21);
	~Метка20: Соответствие_.Вставить(Ключ20, Значение20);
	~Метка19: Соответствие_.Вставить(Ключ19, Значение19);
	~Метка18: Соответствие_.Вставить(Ключ18, Значение18);
	~Метка17: Соответствие_.Вставить(Ключ17, Значение17);
	~Метка16: Соответствие_.Вставить(Ключ16, Значение16);
	~Метка15: Соответствие_.Вставить(Ключ15, Значение15);
	~Метка14: Соответствие_.Вставить(Ключ14, Значение14);
	~Метка13: Соответствие_.Вставить(Ключ13, Значение13);
	~Метка12: Соответствие_.Вставить(Ключ12, Значение12);
	~Метка11: Соответствие_.Вставить(Ключ11, Значение11);
	~Метка10: Соответствие_.Вставить(Ключ10, Значение10);
	~Метка09: Соответствие_.Вставить(Ключ09, Значение09);
	~Метка08: Соответствие_.Вставить(Ключ08, Значение08);
	~Метка07: Соответствие_.Вставить(Ключ07, Значение07);
	~Метка06: Соответствие_.Вставить(Ключ06, Значение06);
	~Метка05: Соответствие_.Вставить(Ключ05, Значение05);
	~Метка04: Соответствие_.Вставить(Ключ04, Значение04);
	~Метка03: Соответствие_.Вставить(Ключ03, Значение03);
	~Метка02: Соответствие_.Вставить(Ключ02, Значение02);
	~Метка01: Соответствие_.Вставить(Ключ01, Значение01);
	~Мекка00:
	
	Возврат Соответствие_;
	
КонецФункции

/// Создание структуры
//
// Параметры:
//   Ключ01 - Строка -
//     Имя первого ключа структуры.
//   Значение01 - Произвольный -
//     Значение первого ключа.
//   ...
//   Ключ29 - Строка -
//     Имя последнего ключа структуры.
//   Значение29 - Произвольный -
//     Значение последнего ключа.
//
// Возвращаемое значение:
//   Структура с заданными ключами и значениями.
///
Функция СоздатьСтруктуру // Экспорт, 58 параметров
(
	Ключ01 = "", Знач01 = Неопределено,
	Ключ02 = "", Знач02 = Неопределено,
	Ключ03 = "", Знач03 = Неопределено,
	Ключ04 = "", Знач04 = Неопределено,
	Ключ05 = "", Знач05 = Неопределено,
	Ключ06 = "", Знач06 = Неопределено,
	Ключ07 = "", Знач07 = Неопределено,
	Ключ08 = "", Знач08 = Неопределено,
	Ключ09 = "", Знач09 = Неопределено,
	Ключ10 = "", Знач10 = Неопределено,
	Ключ11 = "", Знач11 = Неопределено,
	Ключ12 = "", Знач12 = Неопределено,
	Ключ13 = "", Знач13 = Неопределено,
	Ключ14 = "", Знач14 = Неопределено,
	Ключ15 = "", Знач15 = Неопределено,
	Ключ16 = "", Знач16 = Неопределено,
	Ключ17 = "", Знач17 = Неопределено,
	Ключ18 = "", Знач18 = Неопределено,
	Ключ19 = "", Знач19 = Неопределено,
	Ключ20 = "", Знач20 = Неопределено,
	Ключ21 = "", Знач21 = Неопределено,
	Ключ22 = "", Знач22 = Неопределено,
	Ключ23 = "", Знач23 = Неопределено,
	Ключ24 = "", Знач24 = Неопределено,
	Ключ25 = "", Знач25 = Неопределено,
	Ключ26 = "", Знач26 = Неопределено,
	Ключ27 = "", Знач27 = Неопределено,
	Ключ28 = "", Знач28 = Неопределено,
	Ключ29 = "", Знач29 = Неопределено
)
Экспорт
	
	Если "" = Ключ02 Тогда
		Если "" = Ключ01 Тогда
			Возврат Новый Структура;
		Иначе
			Ключи_ = Ключ01;
			Возврат Новый Структура(
				Ключи_,
				Знач01
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ06 Тогда
		Если "" = Ключ04 Тогда
			Если "" = Ключ03 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2",
					Ключ01, Ключ02
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02
				);
			Иначе
				Ключи_ = СтрШаблон(
					"%1, %2, %3",
					Ключ01, Ключ02, Ключ03
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ05 Тогда
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4",
				Ключ01, Ключ02, Ключ03, Ключ04
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04
			);
		Иначе
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ14 Тогда
		Если "" = Ключ10 Тогда
			Если "" = Ключ08 Тогда
				Если "" = Ключ07 Тогда
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6",
						Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06
					);
					Возврат Новый Структура(
						Ключи_,
						Знач01, Знач02, Знач03, Знач04, Знач05, Знач06
					);
				Иначе
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7",
						Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07
					);
					Возврат Новый Структура(
						Ключи_,
						Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07
					);
				КонецЕсли;
			ИначеЕсли "" = Ключ09 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08
				);
			Иначе
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ12 Тогда
			Если "" = Ключ11 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2",
					Ключи_, Ключ10
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10
				);
			Иначе
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3",
					Ключи_, Ключ10, Ключ11
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ13 Тогда
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4",
				Ключи_, Ключ10, Ключ11, Ключ12
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12
			);
		Иначе
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ22 Тогда
		Если "" = Ключ18 Тогда
			Если "" = Ключ16 Тогда
				Если "" = Ключ15 Тогда
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7, %8, %9",
						Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
					);
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6",
						Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14
					);
					Возврат Новый Структура(
						Ключи_,
						Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
						        Знач10, Знач11, Знач12, Знач13, Знач14
					);
				Иначе
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7, %8, %9",
						Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
					);
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7",
						Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15
					);
					Возврат Новый Структура(
						Ключи_,
						Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
						        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15
					);
				КонецЕсли;
			ИначеЕсли "" = Ключ17 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8",
					Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16
				);
			Иначе
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7, %8, %9",
						Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
					);
					Ключи_ = СтрШаблон(
						"%1, %2, %3, %4, %5, %6, %7, %8, %9",
						Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
					);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ20 Тогда
			Если "" = Ключ19 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
				);
				Ключи_ = СтрШаблон(
					"%1, %2",
					Ключи_, Ключ18
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
					        Знач18
				);
			Иначе
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3",
					Ключи_, Ключ18, Ключ19
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
					        Знач18, Знач19
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ21 Тогда
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4",
				Ключи_, Ключ18, Ключ19, Ключ20
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20
			);
		Иначе
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5",
				Ключи_, Ключ18, Ключ19, Ключ20, Ключ21
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20, Знач21
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ26 Тогда
		Если "" = Ключ24 Тогда
			Если "" = Ключ23 Тогда
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6",
					Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
					        Знач18, Знач19, Знач20, Знач21, Знач22
				);
			Иначе
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7, %8, %9",
					Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
				);
				Ключи_ = СтрШаблон(
					"%1, %2, %3, %4, %5, %6, %7",
					Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23
				);
				Возврат Новый Структура(
					Ключи_,
					Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
					        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
					        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23
				);
			КонецЕсли;
		ИначеЕсли "" = Ключ25 Тогда
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8",
				Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24
			);
		Иначе
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24, Ключ25
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24, Знач25
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ28 Тогда
		Если "" = Ключ27 Тогда
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24, Ключ25
			);
			Ключи_ = СтрШаблон(
				"%1, %2",
				Ключи_, Ключ26
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24, Знач25,
				        Знач26
			);
		Иначе
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3, %4, %5, %6, %7, %8, %9",
				Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24, Ключ25
			);
			Ключи_ = СтрШаблон(
				"%1, %2, %3",
				Ключи_, Ключ26, Ключ27
			);
			Возврат Новый Структура(
				Ключи_,
				Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
				        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
				        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24, Знач25,
				        Знач26, Знач27
			);
		КонецЕсли;
	ИначеЕсли "" = Ключ29 Тогда
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24, Ключ25
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4",
			Ключи_, Ключ26, Ключ27, Ключ28
		);
		Возврат Новый Структура(
			Ключи_,
			Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
			        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
			        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24, Знач25,
			        Знач26, Знач27, Знач28
		);
	Иначе
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключ01, Ключ02, Ключ03, Ключ04, Ключ05, Ключ06, Ключ07, Ключ08, Ключ09
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключи_, Ключ10, Ключ11, Ключ12, Ключ13, Ключ14, Ключ15, Ключ16, Ключ17
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5, %6, %7, %8, %9",
			Ключи_, Ключ18, Ключ19, Ключ20, Ключ21, Ключ22, Ключ23, Ключ24, Ключ25
		);
		Ключи_ = СтрШаблон(
			"%1, %2, %3, %4, %5",
			Ключи_, Ключ26, Ключ27, Ключ28, Ключ29
		);
		Возврат Новый Структура(
			Ключи_,
			Знач01, Знач02, Знач03, Знач04, Знач05, Знач06, Знач07, Знач08, Знач09,
			        Знач10, Знач11, Знач12, Знач13, Знач14, Знач15, Знач16, Знач17,
			        Знач18, Знач19, Знач20, Знач21, Знач22, Знач23, Знач24, Знач25,
			        Знач26, Знач27, Знач28, Знач29
		);
	КонецЕсли;
	
	__ПРОВЕРКА__(Ложь, "АлгоритмыДляКоллекций.СоздатьСтруктуру");
	
КонецФункции

/// Создание массива по списку значений
//
// Параметры:
//   Значение01 - Произвольный -
//     Первый элемент массива (элемент с индексом 0).
//   ...
//   Значение29 - Произвольный -
//     29-й элемент массива (элемент с индексом 28).
//
// Возвращаемое значение:
//   Массив - Массив, содержащий переданное число значений.
///
Функция СоздатьМассив // Экспорт, 29 параметров
(
	Значение01 = '05710422152926',
	Значение02 = '05710422152926',
	Значение03 = '05710422152926',
	Значение04 = '05710422152926',
	Значение05 = '05710422152926',
	Значение06 = '05710422152926',
	Значение07 = '05710422152926',
	Значение08 = '05710422152926',
	Значение09 = '05710422152926',
	Значение10 = '05710422152926',
	Значение11 = '05710422152926',
	Значение12 = '05710422152926',
	Значение13 = '05710422152926',
	Значение14 = '05710422152926',
	Значение15 = '05710422152926',
	Значение16 = '05710422152926',
	Значение17 = '05710422152926',
	Значение18 = '05710422152926',
	Значение19 = '05710422152926',
	Значение20 = '05710422152926',
	Значение21 = '05710422152926',
	Значение22 = '05710422152926',
	Значение23 = '05710422152926',
	Значение24 = '05710422152926',
	Значение25 = '05710422152926',
	Значение26 = '05710422152926',
	Значение27 = '05710422152926',
	Значение28 = '05710422152926',
	Значение29 = '05710422152926'
)
Экспорт
	
	Мавлид_ = МагическиеКонстанты.НезаполненноеЗначение();
	
	Если Мавлид_ = Значение02 Тогда
		Если Мавлид_ = Значение01 Тогда
			Массив_ = Новый Массив;
			Перейти ~Мекка00;
		Иначе
			Массив_ = Новый Массив(1);
			Перейти ~Метка01;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение06 Тогда
		Если Мавлид_ = Значение04 Тогда
			Если Мавлид_ = Значение03 Тогда
				Массив_ = Новый Массив(2);
				Перейти ~Метка02;
			Иначе
				Массив_ = Новый Массив(3);
				Перейти ~Метка03;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение05 Тогда
			Массив_ = Новый Массив(4);
			Перейти ~Метка04;
		Иначе
			Массив_ = Новый Массив(5);
			Перейти ~Метка05;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение14 Тогда
		Если Мавлид_ = Значение10 Тогда
			Если Мавлид_ = Значение08 Тогда
				Если Мавлид_ = Значение07 Тогда
					Массив_ = Новый Массив(6);
					Перейти ~Метка06;
				Иначе
					Массив_ = Новый Массив(7);
					Перейти ~Метка07;
				КонецЕсли;
			ИначеЕсли Мавлид_ = Значение09 Тогда
				Массив_ = Новый Массив(8);
				Перейти ~Метка08;
			Иначе
				Массив_ = Новый Массив(9);
				Перейти ~Метка09;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение12 Тогда
			Если Мавлид_ = Значение11 Тогда
				Массив_ = Новый Массив(10);
				Перейти ~Метка10;
			Иначе
				Массив_ = Новый Массив(11);
				Перейти ~Метка11;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение13 Тогда
			Массив_ = Новый Массив(12);
			Перейти ~Метка12;
		Иначе
			Массив_ = Новый Массив(13);
			Перейти ~Метка13;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение22 Тогда
		Если Мавлид_ = Значение18 Тогда
			Если Мавлид_ = Значение16 Тогда
				Если Мавлид_ = Значение15 Тогда
					Массив_ = Новый Массив(14);
					Перейти ~Метка14;
				Иначе
					Массив_ = Новый Массив(15);
					Перейти ~Метка15;
				КонецЕсли;
			ИначеЕсли Мавлид_ = Значение17 Тогда
				Массив_ = Новый Массив(16);
				Перейти ~Метка16;
			Иначе
				Массив_ = Новый Массив(17);
				Перейти ~Метка17;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение20 Тогда
			Если Мавлид_ = Значение19 Тогда
				Массив_ = Новый Массив(18);
				Перейти ~Метка18;
			Иначе
				Массив_ = Новый Массив(19);
				Перейти ~Метка19;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение21 Тогда
			Массив_ = Новый Массив(20);
			Перейти ~Метка20;
		Иначе
			Массив_ = Новый Массив(21);
			Перейти ~Метка21;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение26 Тогда
		Если Мавлид_ = Значение24 Тогда
			Если Мавлид_ = Значение23 Тогда
				Массив_ = Новый Массив(22);
				Перейти ~Метка22;
			Иначе
				Массив_ = Новый Массив(23);
				Перейти ~Метка23;
			КонецЕсли;
		ИначеЕсли Мавлид_ = Значение25 Тогда
			Массив_ = Новый Массив(24);
			Перейти ~Метка24;
		Иначе
			Массив_ = Новый Массив(25);
			Перейти ~Метка25;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение28 Тогда
		Если Мавлид_ = Значение27 Тогда
			Массив_ = Новый Массив(26);
			Перейти ~Метка26;
		Иначе
			Массив_ = Новый Массив(27);
			Перейти ~Метка27;
		КонецЕсли;
	ИначеЕсли Мавлид_ = Значение29 Тогда
		Массив_ = Новый Массив(28);
		Перейти ~Метка28;
	Иначе
		Массив_ = Новый Массив(29);
		Перейти ~Метка29;
	КонецЕсли;
	
	__ТИП__(Массив_, "Массив", "АлгоритмыДляКоллекций.СоздатьМассив");
	
	~Метка29: Массив_[28] = Значение29;
	~Метка28: Массив_[27] = Значение28;
	~Метка27: Массив_[26] = Значение27;
	~Метка26: Массив_[25] = Значение26;
	~Метка25: Массив_[24] = Значение25;
	~Метка24: Массив_[23] = Значение24;
	~Метка23: Массив_[22] = Значение23;
	~Метка22: Массив_[21] = Значение22;
	~Метка21: Массив_[20] = Значение21;
	~Метка20: Массив_[19] = Значение20;
	~Метка19: Массив_[18] = Значение19;
	~Метка18: Массив_[17] = Значение18;
	~Метка17: Массив_[16] = Значение17;
	~Метка16: Массив_[15] = Значение16;
	~Метка15: Массив_[14] = Значение15;
	~Метка14: Массив_[13] = Значение14;
	~Метка13: Массив_[12] = Значение13;
	~Метка12: Массив_[11] = Значение12;
	~Метка11: Массив_[10] = Значение11;
	~Метка10: Массив_[ 9] = Значение10;
	~Метка09: Массив_[ 8] = Значение09;
	~Метка08: Массив_[ 7] = Значение08;
	~Метка07: Массив_[ 6] = Значение07;
	~Метка06: Массив_[ 5] = Значение06;
	~Метка05: Массив_[ 4] = Значение05;
	~Метка04: Массив_[ 3] = Значение04;
	~Метка03: Массив_[ 2] = Значение03;
	~Метка02: Массив_[ 1] = Значение02;
	~Метка01: Массив_[ 0] = Значение01;
	~Мекка00:
	
	Возврат Массив_;
	
КонецФункции

// Создать массив указанной длины.
Функция СоздатьМассивПоДлине(Длина) Экспорт
	__ТИП__(Длина, "Число", "Длина массива должна быть числом");
	Возврат ?(ЗначениеЗаполнено(Длина), Новый Массив(Длина), Новый Массив); 	
КонецФункции

/// Добавление элементов в массив
//
// Параметры:
//   Массив - Массив -
//     Массив, в который добавляются элементы.
//   Значение01 - Произвольный -
//     Первый добавляемый элемент.
//   ...
//   Значение29 - Произвольный -
//     29-й добавляемый элемент.
//
// Возвращаемое значение:
//   Массив - Первый параметр функцции.
///
Функция ДобавитьВМассив // Экспорт, 30 параметров
(
	Массив,
	Значение01 = '05710422152926',
	Значение02 = '05710422152926',
	Значение03 = '05710422152926',
	Значение04 = '05710422152926',
	Значение05 = '05710422152926',
	Значение06 = '05710422152926',
	Значение07 = '05710422152926',
	Значение08 = '05710422152926',
	Значение09 = '05710422152926',
	Значение10 = '05710422152926',
	Значение11 = '05710422152926',
	Значение12 = '05710422152926',
	Значение13 = '05710422152926',
	Значение14 = '05710422152926',
	Значение15 = '05710422152926',
	Значение16 = '05710422152926',
	Значение17 = '05710422152926',
	Значение18 = '05710422152926',
	Значение19 = '05710422152926',
	Значение20 = '05710422152926',
	Значение21 = '05710422152926',
	Значение22 = '05710422152926',
	Значение23 = '05710422152926',
	Значение24 = '05710422152926',
	Значение25 = '05710422152926',
	Значение26 = '05710422152926',
	Значение27 = '05710422152926',
	Значение28 = '05710422152926',
	Значение29 = '05710422152926'
)
Экспорт
	
	// Включим синтакс-помощник.
	Если 0 Тогда Массив = Новый Массив; КонецЕсли;
	
	Мавлид_ = МагическиеКонстанты.НезаполненноеЗначение();
	
	Если Мавлид_ = Значение02 Тогда
		
		Если Мавлид_ = Значение01 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение01);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение01);
	Массив.Добавить(Значение02);
	
	Если Мавлид_ = Значение06 Тогда
		
		Если Мавлид_ = Значение04 Тогда
			
			Если Мавлид_ = Значение03 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение03);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение03);
		Массив.Добавить(Значение04);
		
		Если Мавлид_ = Значение05 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение05);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение03);
	Массив.Добавить(Значение04);
	Массив.Добавить(Значение05);
	Массив.Добавить(Значение06);
	
	Если Мавлид_ = Значение14 Тогда
		
		Если Мавлид_ = Значение10 Тогда
			
			Если Мавлид_ = Значение08 Тогда
				
				Если Мавлид_ = Значение07 Тогда
					Возврат Массив;
				КонецЕсли;
				Массив.Добавить(Значение07);
				Возврат Массив;
				
			КонецЕсли;
			
			Массив.Добавить(Значение07);
			Массив.Добавить(Значение08);
			
			Если Мавлид_ = Значение09 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение09);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение07);
		Массив.Добавить(Значение08);
		Массив.Добавить(Значение09);
		Массив.Добавить(Значение10);
		
		Если Мавлид_ = Значение12 Тогда
		
			Если Мавлид_ = Значение11 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение11);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение11);
		Массив.Добавить(Значение12);
		
		Если Мавлид_ = Значение13 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение13);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение07);
	Массив.Добавить(Значение08);
	Массив.Добавить(Значение09);
	Массив.Добавить(Значение10);
	Массив.Добавить(Значение11);
	Массив.Добавить(Значение12);
	Массив.Добавить(Значение13);
	Массив.Добавить(Значение14);
	
	Если Мавлид_ = Значение22 Тогда
		
		Если Мавлид_ = Значение18 Тогда
			
			Если Мавлид_ = Значение16 Тогда
				
				Если Мавлид_ = Значение15 Тогда
					Возврат Массив;
				КонецЕсли;
				Массив.Добавить(Значение15);
				Возврат Массив;
				
			КонецЕсли;
			
			Массив.Добавить(Значение15);
			Массив.Добавить(Значение16);
			
			Если Мавлид_ = Значение17 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение17);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение15);
		Массив.Добавить(Значение16);
		Массив.Добавить(Значение17);
		Массив.Добавить(Значение18);
			
		Если Мавлид_ = Значение20 Тогда
			
			Если Мавлид_ = Значение19 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение19);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение19);
		Массив.Добавить(Значение20);
		
		Если Мавлид_ = Значение21 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение21);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение15);
	Массив.Добавить(Значение16);
	Массив.Добавить(Значение17);
	Массив.Добавить(Значение18);
	Массив.Добавить(Значение19);
	Массив.Добавить(Значение20);
	Массив.Добавить(Значение21);
	Массив.Добавить(Значение22);
		
	Если Мавлид_ = Значение26 Тогда
		
		Если Мавлид_ = Значение24 Тогда
			
			Если Мавлид_ = Значение23 Тогда
				Возврат Массив;
			КонецЕсли;
			Массив.Добавить(Значение23);
			Возврат Массив;
			
		КонецЕсли;
		
		Массив.Добавить(Значение23);
		Массив.Добавить(Значение24);
		
		Если Мавлид_ = Значение25 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение25);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение23);
	Массив.Добавить(Значение24);
	Массив.Добавить(Значение25);
	Массив.Добавить(Значение26);
	
	Если Мавлид_ = Значение28 Тогда
		
		Если Мавлид_ = Значение27 Тогда
			Возврат Массив;
		КонецЕсли;
		Массив.Добавить(Значение27);
		Возврат Массив;
		
	КонецЕсли;
	
	Массив.Добавить(Значение27);
	Массив.Добавить(Значение28);
	
	Если Мавлид_ = Значение29 Тогда
		Возврат Массив;
	КонецЕсли;
	Массив.Добавить(Значение29);
	Возврат Массив;;
	
КонецФункции

// Получить ключи коллекции в массиве.
//
// Параметры:
//  Коллекция	 - Соответствие, Структура - 
// 
// Возвращаемое значение:
//  Массив - 
//
Функция ПолучитьКлючиВМассиве(Коллекция) Экспорт
	__ТИП__(Коллекция, "Соответствие, Структура", "Неверный тип коллекции");
	
	Ключи_ = Новый Массив;
	Для Каждого ЭлементКоллекции_ Из Коллекция Цикл
		Ключи_.Добавить(ЭлементКоллекции_.Ключ);	
	КонецЦикла;
	Возврат Ключи_;
КонецФункции

// Получить значеня коллекции в массиве.
//
// Параметры:
//  Коллекция	 - Соответствие, Структура - 
// 
// Возвращаемое значение:
//  Массив - 
//
Функция ПолучитьЗначенияВМассиве(Коллекция, ТолькоУникальные = Истина) Экспорт
	__ТИП__(Коллекция, "Соответствие, Структура", "Неверный тип коллекции");
	
	Значения_ = Новый Массив;
	Для Каждого ЭлементКоллекции_ Из Коллекция Цикл
		Если ТолькоУникальные = Истина Тогда
			АлгоритмыДляКоллекций.ДобавитьУникальное(Значения_, ЭлементКоллекции_.Значение);	
		Иначе
			Значения_.Добавить(ЭлементКоллекции_.Значение);
		КонецЕсли;
	КонецЦикла;
	Возврат Значения_;
КонецФункции

// Создает массив и копирует в него значения, содержащиеся в колонке коллекции.
Функция ВыгрузитьКолонку(Коллекция, ИмяКолонки, ТолькоУникальныеЗначения = Ложь) Экспорт
	МассивЗначений_ = Новый Массив;
	
	УникальныеЗначения_ = Новый Соответствие;
	
	Для каждого Элемент_ Из Коллекция Цикл
		Значение = Элемент_[ИмяКолонки];
		Если ТолькоУникальныеЗначения И УникальныеЗначения_[Значение] <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений_.Добавить(Значение);
		УникальныеЗначения_.Вставить(Значение, Истина);
	КонецЦикла; 
	
	Возврат МассивЗначений_;
КонецФункции

// Создать список значений из массива.
Функция СоздатьСписокЗначений(МассивЗначений) Экспорт
	СписокЗначений_ = Новый СписокЗначений;
	СписокЗначений_.ЗагрузитьЗначения(МассивЗначений);
	Возврат СписокЗначений_;
КонецФункции

// Преобразование массива в соответствие
//
// Параметры:
//   Массив - Массив - Массив ключей соответствия.
//   Значение - Произвольный - Значение элементов соответствия.
//
// Возвращаемое значение:
//   Соответствие - Соответствие с ключами из массиа и значениями, равными параметру Значение.
///
Функция МассивВСоответствие(Массив, Значение = Истина) Экспорт
	
	Соответствие_ = Новый Соответствие;
	
	Для Каждого Ключ_ Из Массив Цикл
		Соответствие_[Ключ_] = Значение;
	КонецЦикла;
	
	Возврат Соответствие_;
	
КонецФункции

// Запись ключей структуры или соответствия в массив
//
// Параметры:
//   Контейнер - Соответствие, Структура - Структура или Соответствие.
//
// Возвращаемое значение:
//   Массив - Массив ключей из Контейнера.
///
Функция МассивКлючей(Контейнер) Экспорт
	
	// Включим синтакс-помощник.
	Если 0 Тогда Контейнер = Новый Соответствие; КонецЕсли;
	
	Массив_ = Новый Массив(Контейнер.Количество());
	
	Индекс_ = 0;
	Для Каждого КлючИЗначение_ Из Контейнер Цикл
		Массив_[Индекс_] = КлючИЗначение_.Ключ;
		Индекс_ = Индекс_ + 1;
	КонецЦикла;
	
	Возврат Массив_;
	
КонецФункции

//////////////////////////////////////////////////////////////////////////////
//
// АЛГОРИТМЫ ОБХОДА
//
//////////////////////////////////////////////////////////////////////////////

////
 // Функция: ОбходИерархии_СоздатьУзелДерева
 //   Выполняется обход иерархии с одновременным созданием дерева.
 //   Данная функция выполняет очередной шаг обхода.
 //
 // Параметры:
 //   ИерархическаяВыборка
 //     Выборка с сортировкой по иерархии, то есть сначала идет родитель,
 //     непосредственно за ним идут иерархии детей.
 //     В выборке должно быть поле Родитель, по которому строится иерархия.
 //   Дерево.
 //     Дерево, которое заполняется. Тип ДанныеФормыДерево.
 //   ИмяПоляСсылки.
 //     Имя поля дерева, по которому осуществляется связь полем Родитель выборки.
 //
 // Возврат:
 //   Созданный узел дерева.
 //
 // Пример:
 //   // В следующем примере происходит заполнение дерева иерархическим списком
 //   // элементов справочника Номенклатура.
 //   Запрос = Новый Запрос(
 //     "ВЫБРАТЬ
 //     |	Номенклатура.Ссылка,
 //     |	Номенклатура.Наименование,
 //     |	Номенклатура.Родитель
 //     |ИЗ
 //     |	Справочник.Номенклатура КАК Номенклатура
 //     |
 //     |УПОРЯДОЧИТЬ ПО
 //     |	Ссылка ИЕРАРХИЯ"
 //   );
 //   Выборка = Запрос.Выполнить().Выбрать();
 //   Дерево = ЭтотОбъект.Дерево; // Реквизит формы типа ДанныеФормыДерево, (ДеревоЗначений)
 //   Пока Выборка.Следующий() Цикл
 //   	УзелДерева = АлгоритмыДляКоллекций.ОбходИерархии_СоздатьУзелДерева(Выборка, Дерево);
 //   	УзелДерева.Наименование = Выборка.Наименование;
 //   КонецЦикла;
 ///
Функция ОбходИерархии_СоздатьУзелДерева(ИерархическаяВыборка, Дерево, ИмяПоляСсылки = "Ссылка") Экспорт
	Перем УзелДерева, ЭлементыДерева, Условие;
	ЭлементыДерева = Дерево.ПолучитьЭлементы();
	Если Не ЗначениеЗаполнено(ИерархическаяВыборка.Родитель) Тогда
		Возврат ЭлементыДерева.Добавить();
	КонецЕсли;
	УзелДерева = ЭлементыДерева[ЭлементыДерева.Количество() - 1];
	Пока Не УзелДерева[ИмяПоляСсылки] = ИерархическаяВыборка.Родитель Цикл
		ЭлементыДерева = УзелДерева.ПолучитьЭлементы();
		УзелДерева = ЭлементыДерева[ЭлементыДерева.Количество() - 1];
	КонецЦикла;
	Возврат УзелДерева.ПолучитьЭлементы().Добавить();
КонецФункции

////
 // Функция: ОбходСписка_СоздатьУзелДерева
 //   Выполняется обход иерархии с одновременным созданием дерева.
 //   Данная функция выполняет очередной шаг обхода.
 //
 // Параметры:
 //   ИерархическаяВыборка
 //     Выборка с сортировкой сначала группы, потом элементы, то есть сначала идут все родители,
 //     а за ним идут все детей.
 //     В выборке должно быть поле Родитель, по которому строится иерархия.
 //   Дерево.
 //     Дерево, которое заполняется. Тип ДанныеФормыДерево.
 //   ИмяПоляСсылки.
 //     Имя поля дерева, по которому осуществляется связь полем Родитель выборки.
 //
 // Возврат:
 //   Созданный узел дерева.
 //
 ///
Функция ОбходУпорядоченногоПоЭтоГруппаСписка_СоздатьУзелДерева(ИерархическаяВыборка, Дерево, ИмяПоляСсылки = "Ссылка") Экспорт
	Перем УзелДерева, ЭлементыДерева, Условие;
	ЭлементыДерева = Дерево.ПолучитьЭлементы();
	УзелДерева = Неопределено;
	Если Не ЗначениеЗаполнено(ИерархическаяВыборка.Родитель) Тогда
		Возврат ЭлементыДерева.Добавить();
	КонецЕсли;
	Пока АлгоритмыДляКоллекций.ОбходДерева_Следующий(Дерево, УзелДерева) Цикл
		Если УзелДерева[ИмяПоляСсылки] = ИерархическаяВыборка.Родитель 
		Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат УзелДерева.ПолучитьЭлементы().Добавить();
КонецФункции

////
 // Функция: ОбходДерева_Следующий
 //   Выполняет очередной шаг обхода дерева в глубину.
 //   Каждый узел обходится только один раз.
 //   Сначала обходится родитель, непосредственно за ним иерархии дочерних узлов.
 //
 // Параметры:
 //   Дерево
 //     Дерево, по которому осуществляется обход.
 //   УзелДерева.
 //     Узел дерева, полученный на предыдущем шаге. Неопределено для первого шага.
 //     В этот же параметр записывается следующий узел в порядке обхода.
 //
 // Возврат:
 //   Истина, если обход не завершен.
 //   Ложь, если обход завершен.
 //
 // Пример:
 //   // В следующем примере выполняется обход дерева в глубину.
 //   // Всем узлам, у которых поле ЭтоГруппа не равняется Истина,
 //   // поле Значение устанавливается равным нулю.
 //   УзелДерева = Неопределено;
 //   Пока АлгоритмыДляКоллекций.ОбходДерева_Следующий(ЭтотОбъект.Дерево, УзелДерева) Цикл
 //   	Если Не УзелДерева.ЭтоГруппа = Истина Тогда
 //   		УзелДерева.Значение = 0;
 //   	КонецЕсли;
 //   КонецЦикла;
 ///
Функция ОбходДерева_Следующий(Дерево, УзелДерева) Экспорт
	Перем ЭлементыДерева, Родитель, Индекс;
	ЭлементыДерева = Дерево.ПолучитьЭлементы();
	Если ЭлементыДерева.Количество() = 0 Тогда
		УзелДерева = Неопределено;
		Возврат Ложь;
	КонецЕсли;
	Если УзелДерева = Неопределено Тогда
		УзелДерева = ЭлементыДерева[0];
		Возврат Истина;
	КонецЕсли;
	ЭлементыДерева = УзелДерева.ПолучитьЭлементы();
	Если Не ЭлементыДерева.Количество() = 0 Тогда
		УзелДерева = ЭлементыДерева[0];
		Возврат Истина;
	КонецЕсли;
	Пока Не (УзелДерева = Неопределено Или УзелДерева = Дерево) Цикл
		Родитель = УзелДерева.ПолучитьРодителя();
		Если Родитель = Неопределено Или Родитель = Дерево Тогда
			ЭлементыДерева = Дерево.ПолучитьЭлементы();
		Иначе
			ЭлементыДерева = Родитель.ПолучитьЭлементы();
		КонецЕсли;
		Индекс = ЭлементыДерева.Индекс(УзелДерева);
		Если Индекс + 1 < ЭлементыДерева.Количество() Тогда
			УзелДерева = ЭлементыДерева[Индекс + 1];
			Возврат Истина;
		КонецЕсли;
		УзелДерева = Родитель;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

////
 //	Функция: НайтиВДереве
 //     Служит для поиска в дереве (данные формы) узлов по условию
 //     заданном в параметре Отбор.
 //
 //	Параметры:
 //	  Дерево
 //     Объект дерево
 //	  Отбор
 //     Структура, ключ - имя поля, значение - значение поля
 //	  УзелДерева
 //     элемент дерева с которого начнется поиск
 //	  ТолькоПервый
 //     если истина то вернет первый найденный элемент, иначе массив всех найденных.
 //	
 //	Возврат:
 //     Элемент дерева или массив элементов дерева.
 ///
Функция НайтиВДереве(Дерево, Отбор,Знач УзелДерева = Неопределено, ТолькоПервый = Ложь) Экспорт
	Если ТолькоПервый = Ложь Тогда
		Результат = Новый Массив;
	КонецЕсли;
	Пока ОбходДерева_Следующий(Дерево, УзелДерева) Цикл
		Найден = Истина;
		Для Каждого Условие Из Отбор Цикл
			Если УзелДерева[Условие.Ключ] <> Условие.Значение Тогда
				Найден = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Найден Тогда
			Если ТолькоПервый Тогда
				Возврат УзелДерева;
			Иначе
				Результат.Добавить(УзелДерева);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ?(ТолькоПервый, Неопределено, Результат);
КонецФункции

// Поиск в дереве по родительскому элементу.
//
Функция НайтиВДеревеПоРодителю(Дерево, Отбор, Родитель = Неопределено, ТолькоПервый = Ложь) Экспорт
	Если ТолькоПервый = Ложь Тогда
		НайденныеУзлы_ = Новый Массив;
	КонецЕсли;
	Узлы_ = ?(Родитель = Неопределено, Дерево.ПолучитьЭлементы(), Родитель.ПолучитьЭлементы());
	Для Каждого Узел_ Из Узлы_ Цикл
		Найден_ = Истина;
		Для Каждого Условие_ Из Отбор Цикл
			Если Узел_[Условие_.Ключ] <> Условие_.Значение Тогда
				Найден_ = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если Найден_ Тогда
			Если ТолькоПервый Тогда
				Возврат Узел_;
			Иначе
				НайденныеУзлы_.Добавить(Узел_);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ?(ТолькоПервый, Неопределено, НайденныеУзлы_);
КонецФункции	
	
//////////////////////////////////////////////////////////////////////////////
//
// ИТЕРАЦИИ
//
//////////////////////////////////////////////////////////////////////////////

////
 // Функция: ИтерацияИсключаяКонец
 //   Осуществляет итерацию начала интервала до конца интервала, не включая конец,
 //   с указанным шагом с изменением счетчика.
 //   При первом вызове функции значение счетчика должно быть Неопределено.
 //   По окончании итераций значение счетчика будет Неопределено.
 //
 // Параметры:
 //   Счетчик {Число, Дата}
 //     Переменная, по которой происходит итерация.
 //   Начало {Число, Дата}
 //     Начало интервала.
 //   Конец {Число, Дата}
 //     Конец интервала, не входит в сам интервал.
 //   Шаг {Число, Дата, Неопределено}
 //     Приращение счетчика на каждой итерации.
 //     Значением типа Дата интерпретируется как время прошедшее от '00010101'
 //     и может применяться только если Начало и Конец имеют тип Дата.
 //     Неопределенное значение указывает на то, что приращение равняется 1.
 //
 // Возврат: {Булево}
 //   Истина, если еще не достигли конца интервала, Ложь, в противном случае.
 ///
Функция ИтерацияИсключаяКонец(Счетчик, Начало, Конец, Шаг = Неопределено) Экспорт
	Перем Приращение, Направление, ЭтоПустойИнтервал, ЭтоКонец;
	
	// Проверка параметров
	__ПРОВЕРКА__(Счетчик = Неопределено Или ТипЗнч(Счетчик) = Тип("Дата") Или ТипЗнч(Счетчик) = Тип("Число"), "ИтерацияИсключаяКонец: Несоответствие типа 1-го аргумента.");
	__ПРОВЕРКА__(ТипЗнч(Начало) = Тип("Число") Или ТипЗнч(Начало) = Тип("Дата"), "ИтерацияИсключаяКонец: Несоответствие типа 2-го аргумента.");
	__ПРОВЕРКА__(ТипЗнч(Конец) = Тип("Число") Или ТипЗнч(Конец) = Тип("Дата"), "ИтерацияИсключаяКонец: Несоответствие типа 3-го аргумента.");
	__ПРОВЕРКА__(Шаг = Неопределено Или ТипЗнч(Шаг) = Тип("Дата") Или ТипЗнч(Шаг) = Тип("Число"), "ИтерацияИсключаяКонец: Несоответствие типа 4-го аргумента.");
	__ПРОВЕРКА__(ТипЗнч(Начало) = ТипЗнч(Конец), "ИтерацияИсключаяКонец: Несоответствие типа 2-го аргумента типу 3-го аргумента.");
	__ПРОВЕРКА__(Счетчик = Неопределено Или ТипЗнч(Счетчик) = ТипЗнч(Начало), "ИтерацияИсключаяКонец: Несоответствие типа 1-го аргумента типу 2-го аргумента.");
	__ПРОВЕРКА__(Шаг = Неопределено Или ТипЗнч(Шаг) = Тип("Число") Или ТипЗнч(Шаг) = ТипЗнч(Начало), "ИтерацияИсключаяКонец: Несоответствие типа 4-го аргумента типу 2-го аргумента.");
	
	// Уточняем шаг (приращение) итерации
	Приращение = ?(Шаг = Неопределено, 1, ?(ТипЗнч(Шаг) = Тип("Дата"), Шаг - '00010101', Шаг));
	__ПРОВЕРКА__(ТипЗнч(Приращение) = Тип("Число") И Не Приращение = 0, "ИтерацияИсключаяКонец: Некорректный шаг итерации.");
	
	// Определяем, есть ли в интервале элементы
	ЭтоПустойИнтервал = ?(0 < Приращение, Начало < Конец, Конец < Начало);
	
	// Начало итерации
	Если Счетчик = Неопределено И Не ЭтоПустойИнтервал Тогда
		Счетчик = Начало;
		Возврат Истина;
	КонецЕсли;
	
	// Шаг итерации
	Если Не Счетчик = Неопределено Тогда
		Счетчик = Счетчик + Приращение;
		ЭтоКонец = ?(0 < Приращение, Счетчик < Конец, Конец < Счетчик);
		__ПРОВЕРКА__(Не ЭтоПустойИнтервал, "ИтерацияИсключаяКонец: Интервал изменился между итерациями.");
	КонецЕсли;
	
	// Середина итерации
	Если Не Счетчик = Неопределено И Не ЭтоКонец Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Конец итерации
	__ПРОВЕРКА__(Счетчик = Неопределено Или ЭтоКонец, "ИтерацияИсключаяКонец: Неожиданное окончание интервала.");
	Счетчик = Неопределено;
	Возврат Ложь;
	
КонецФункции

////
 // Функция: ИтерацияПоДням
 //   Осуществляет итерацию даты от даты начала до даты окончания по дням,
 //   включая обе границы.
 //   При первом вызове функции значение переменной Дата должно быть Неопределено.
 //   По окончании итераций значение переменной Дата будет Неопределено.
 //
 // Параметры:
 //   Дата {Дата}
 //     Переменная, по которой происходит итерация.
 //   ДатаНачала {Дата}
 //     Первая дата в последовательности, должна быть выровнена по началу дня.
 //   ДатаОкончания {Дата}
 //     Последняя дата в последовательности, должна быть выровнена по началу дня.
 //
 // Возврат: {Булево}
 //   Истина, если еще не достигли конца последовательности, Ложь, в противном случае.
 ///
Функция ИтерацияПоДнямВключаяКонец(Дата, ДатаНачала, ДатаОкончания) Экспорт
	Перем ОдниСутки;
	
	// Проверка параметров
	__ПРОВЕРКА__(Дата = Неопределено Или ТипЗнч(Дата) = Тип("Дата"), "ИтерацияПоДням: Несоответствие типа 1-го аргумента.");
	__ПРОВЕРКА__(ТипЗнч(ДатаНачала) = Тип("Дата"), "ИтерацияПоДням: Несоответствие типа 2-го аргумента.");
	__ПРОВЕРКА__(ТипЗнч(ДатаОкончания) = Тип("Дата"), "ИтерацияПоДням: Несоответствие типа 3-го аргумента.");
	__ПРОВЕРКА__(Дата = Неопределено Или НачалоДня(Дата) = Дата И ДатаНачала <= Дата И Дата <= ДатаОкончания, "ИтерацияПоДням: Некорректное значение 1-го аргумента.");
	__ПРОВЕРКА__(НачалоДня(ДатаНачала) = ДатаНачала, "ИтерацияПоДням: Некорректное значение 2-го аргумента.");
	__ПРОВЕРКА__(НачалоДня(ДатаОкончания) = ДатаОкончания, "ИтерацияПоДням: Некорректное значение 3-го аргумента.");
	
	// Перенаправление к другой функции
	ОдниСутки = '00010102' - '00010101';
	Возврат ИтерацияИсключаяКонец(Дата, ДатаНачала, ДатаОкончания + ОдниСутки, ОдниСутки);
	
КонецФункции

#Область Алгоритмы_для_отрезков

/// Объединение отрезков
//
// Основные положения
// 1. Пересекающиеся отрезки объединяются в один.
// 2. Отрезок задается началом и концом. Начала и концы хранятся в разных массивах.
// 3. Отрезки отсортированы по возрастанию начал.
// 4. Объединение выполняется на месте, то есть в тех же массивах, размер может уменьшиться.
//
// Параметры:
//   МассивНачал - Массив -
//     Массив начал отрезков.
//   МассивКонцов - Массив -
//     Массив концов отрезков.
///
Процедура ОбъединитьОтрезки(МассивНачал, МассивКонцов) Экспорт
	
	// Включим синтакс-помощник.
	Если Ложь Тогда МассивНачал = Новый Массив; МассивКонцов = Новый Массив; КонецЕсли;
	
	// Сначала пропустим первые непересекающиеся интервалы.
	Для Индекс_ = 1 По МассивНачал.Количество() - 1 Цикл
		Если Не МассивКонцов[Индекс_ - 1] < МассивНачал[Индекс_] Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// Интервалы не пересекаются, делать ничего не нужно.
	Если Не Индекс_ < МассивНачал.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	// Теперь, собственно, выолним объединение отрезков.
	РазмерРезультата_ = Индекс_;
	ПоследнийКонец_ = МассивКонцов[Индекс_ - 1];
	Для Индекс_ = Индекс_ По МассивНачал.Количество() - 1 Цикл
		Если ПоследнийКонец_ < МассивНачал[Индекс_] Тогда
			ПоследнийКонец_ = МассивКонцов[Индекс_];
			МассивНачал[РазмерРезультата_] = МассивНачал[Индекс_];
			МассивКонцов[РазмерРезультата_] = МассивКонцов[Индекс_];
			РазмерРезультата_ = РазмерРезультата_ + 1;
		ИначеЕсли ПоследнийКонец_ < МассивКонцов[Индекс_] Тогда
			ПоследнийКонец_ = МассивКонцов[Индекс_];
			МассивКонцов[РазмерРезультата_ - 1] = ПоследнийКонец_;
		КонецЕсли;
	КонецЦикла;
	
	// Удалим оставшиеся ненужные элементы массивов.
	КолВо_ = МассивНачал.Количество();
	Пока РазмерРезультата_ < КолВо_ Цикл
		КолВо_ = КолВо_ - 1;
		МассивНачал.Удалить(КолВо_);
		МассивКонцов.Удалить(КолВо_);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

//////////////////////////////////////////////////////////////////////////////
//
// МАТЕМАТИЧЕСКИЕ ФУНКЦИИ
//
//////////////////////////////////////////////////////////////////////////////

/// Наибольший общий делитель
//
// Параметры:
//   НатуральноеЧисло1 - Число -
//     Первый аргумент.
//   НатуральноеЧисло2 - Число -
//     Второй аргумент.
//
// Возвращаемое значение:
//   Число - Наибольший общий делитель чисел НатуральноеЧисло1 и НатуральноеЧисло2.
///
Функция НОД(НатуральноеЧисло1, НатуральноеЧисло2) Экспорт
	Если НатуральноеЧисло2 = 0 Тогда
		Возврат НатуральноеЧисло1;
	КонецЕсли;
	Возврат НОД(НатуральноеЧисло2, НатуральноеЧисло1 % НатуральноеЧисло2);
КонецФункции

/// Наибольший общий делитель чисел в массиве
//
// Параметры:
//   МассивНатуральныхЧисел - Массив -
//     Массив натуральных чисел.
//
// Возвращаемое значение:
//   Число - Наибольший общий делитель чисел из массива МассивНатуральныхЧисел.
///
Функция НОДМассива(МассивНатуральныхЧисел) Экспорт
	
	НОД_ = МассивНатуральныхЧисел[0];
	
	Для Индекс_ = 1 По МассивНатуральныхЧисел.Количество() - 1 Цикл
		
		НОД_ = НОД(НОД_, МассивНатуральныхЧисел[Индекс_]);
		
	КонецЦикла;
	
	Возврат НОД_;
	
КонецФункции

/// Наименьшее общее кратное
//
// Параметры:
//   НатуральноеЧисло1 - Число -
//     Первый аргумент.
//   НатуральноеЧисло2 - Число -
//     Второй аргумент.
//
// Возвращаемое значение:
//   Число - Наименьшее общее кратное чисел НатуральноеЧисло1 и НатуральноеЧисло2.
///
Функция НОК(НатуральноеЧисло1, НатуральноеЧисло2) Экспорт
	
	Возврат НатуральноеЧисло1 * НатуральноеЧисло2 / НОД(НатуральноеЧисло1, НатуральноеЧисло2);
	
КонецФункции

/// Наименьшее общее кратное чисел в массиве
//
// Параметры:
//   МассивНатуральныхЧисел - Массив -
//     Массив натуральных чисел.
//
// Возвращаемое значение:
//   Число - Наименьшее общее кратное чисел из массива МассивНатуральныхЧисел.
///
Функция НОКМассива(МассивНатуральныхЧисел) Экспорт
	
	НОК_ = МассивНатуральныхЧисел[0];
	
	Для Индекс_ = 1 По МассивНатуральныхЧисел.Количество() - 1 Цикл
		
		НОК_ = НОК(НОК_, МассивНатуральныхЧисел[Индекс_]);
		
	КонецЦикла;
	
	Возврат НОК_;
	
КонецФункции

////
 // Функция: Потолок
 //
 // Параметры:
 //   Арг - число
 ///
Функция Потолок(Арг) Экспорт
	Рез_ = Цел(Арг);
	Возврат Рез_ + ?(Арг = Рез_, 0, 1);
КонецФункции

// Сумма указанных элементов массива
//
// Возвращаемое значение:
//   Число
// 
Функция Сумма(Массив, Знач НачальныйИндекс = 0, Знач ЧислоЭлементов = 0) Экспорт
	ЧислоЭлементов = ?(ЗначениеЗаполнено(ЧислоЭлементов), ЧислоЭлементов, Массив.Количество());
	Сумма_ = 0;
	Для Индекс_ = НачальныйИндекс По НачальныйИндекс + ЧислоЭлементов - 1 Цикл
		Сумма_ = Сумма_ + Массив[Индекс_];	
	КонецЦикла;
	Возврат Сумма_;
КонецФункции

// Среднее аримметическое указанных элементов массива
//
// Возвращаемое значение:
//   Число
// 
Функция СреднееАрифметическое(Массив, Знач НачальныйИндекс = 0, Знач ЧислоЭлементов = 0) Экспорт
	ЧислоЭлементов = ?(ЗначениеЗаполнено(ЧислоЭлементов), ЧислоЭлементов, Массив.Количество());
	Возврат Сумма(Массив, НачальныйИндекс, ЧислоЭлементов) / ЧислоЭлементов;
КонецФункции

// Логическое И указанных элементов массива
//
// Возвращаемое значение:
//   Булево
// 
Функция ЛогическоеИ(Массив, Знач НачальныйИндекс = 0, Знач ЧислоЭлементов = 0) Экспорт
	ЧислоЭлементов = ?(ЗначениеЗаполнено(ЧислоЭлементов), ЧислоЭлементов, Массив.Количество());
	Результат_ = Истина;
	Для Индекс_ = НачальныйИндекс По НачальныйИндекс + ЧислоЭлементов - 1 Цикл
		Результат_ = Результат_ И Массив[Индекс_];	
	КонецЦикла;
	Возврат Результат_;
КонецФункции

// Преобразовать двоичное представление в число.
Функция ПреобразоватьДвоичноеПредставлениеВЧисло(Знач ДвоичноеПредставление) Экспорт
	Результат_ = 0;
	
	ДвоичноеПредставление = СокрЛП(ДвоичноеПредставление);
	Для Позиция_ = 1 По СтрДлина(ДвоичноеПредставление) Цикл
		Результат_ = Результат_ * 2 + Число(Сред(ДвоичноеПредставление, Позиция_, 1));
	КонецЦикла;
	
	Возврат Результат_;
КонецФункции

// Преобразование числа в двоичное представление.
Функция ПреобразоватьЧислоВДвоичноеПредставление(Знач Число) Экспорт
	Результат_ = "";
	
	Шаблон_ = "01";
	Нотация_ = СтрДлина(Шаблон_);
	Пока Число > 0 Цикл
		Результат_ = Сред(Шаблон_, Число % Нотация_ + 1, 1) + Результат_;
		Число = Цел(Число / Нотация_) ;
	КонецЦикла;
	 
	 Возврат Результат_;
КонецФункции

//////////////////////////////////////////////////////////////////////////////
//
// РАБОТА СО СТРОКАМИ
//
//////////////////////////////////////////////////////////////////////////////

////
 // Процедура: ПолучитьСтрокуПоШаблонуИЗначениямПолей
 //   получает строку по шаблону, исходя из полученных старых и новых значений полей
 //   Параметры:
 //		СтруктураСтарыхЗначений(Структура)
 //			Структура с названием параметра шаблона в ключе.
 //			Должна содержать данные до изменения.
 //     СтруктураНовыхЗначений(Структура)
 //			Структура с названием параметра шаблона в ключе.
 //			Должна содержать данные после изменения.
 //     УдаляемыеПараметрамиСимволы(Структура)
 //			Структура с названием параметра шаблона в ключе.
 //			Должна содержать данные о символах которые надо удалить, если параметр пустой.
 //		Шаблон(Строка)
 //        Текстовый шаблон с параметрами для замены
 //		ТекущееНаименование(Строка)
 //        Строка с наименованием, которое было сформирована ранее, до изменения.
 //	  Возврат:
 //		Строка
 //			Полученная из шаблона строка
 ///
Функция ПолучитьСтрокуПоШаблонуИЗначениямПолей(СтруктураСтарыхЗначений, 
													 СтруктураНовыхЗначений, 
													 УдаляемыеПараметрамиСимволы , 
													 Шаблон, 
													 ТекущееНаименование) Экспорт
	Перем НовоеНаименование, СтароеНаименование, ВозвращаемоеНаименование;
	
	
	// формируем шаблону исходя из удаляемых символов
	ШаблонСтарыхпараметров = Шаблон;
	ШаблонНовыхпараметров = Шаблон;
	Для Каждого ЭлементСтруктуры Из УдаляемыеПараметрамиСимволы Цикл
		// разложим удаляемые символы в массив
		МассивУдаления = СтрРазделить(ЭлементСтруктуры.Значение, ",");
		Если СтруктураСтарыхЗначений.Свойство(ЭлементСтруктуры.Ключ) И
			 ПустаяСтрока(СтруктураСтарыхЗначений[ЭлементСтруктуры.Ключ]) Тогда
			Для Каждого Мас из МассивУдаления Цикл
				ШаблонСтарыхпараметров = СтрЗаменить(ШаблонСтарыхпараметров,Мас,"");
			КонецЦикла;
		КонецЕсли;	
		Если СтруктураНовыхЗначений.Свойство(ЭлементСтруктуры.Ключ) И
			 ПустаяСтрока(СтруктураНовыхЗначений[ЭлементСтруктуры.Ключ]) Тогда
			Для Каждого Мас из МассивУдаления Цикл
				ШаблонНовыхпараметров = СтрЗаменить(ШаблонНовыхпараметров,Мас,"");
			КонецЦикла;
		КонецЕсли;	
	КонецЦикла;
		
	// формируем новое наименование по шаблону
	НовоеНаименование = ШаблонНовыхпараметров;
	Для Каждого ЭлементСтруктуры Из СтруктураНовыхЗначений Цикл
		НовоеНаименование = СтрЗаменить(НовоеНаименование,ЭлементСтруктуры.Ключ,ЭлементСтруктуры.Значение);
	КонецЦикла;
	НовоеНаименование = СокрЛП(НовоеНаименование);	

	МодульСообщенияПользователю = Неопределено;
	#Если Клиент Тогда
		Если ОбщегоНазначенияКлиент.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
			МодульСообщенияПользователю = ОбщегоНазначенияКлиент.ОбщийМодуль("СообщенияПользователю");
		КонецЕсли;
	#КонецЕсли
	#Если Сервер Тогда
		Если ОбщегоНазначения.ПодсистемаСуществует("ФункциональныеПодсистемы.СообщенияПользователю") Тогда
			МодульСообщенияПользователю = ОбщегоНазначения.ОбщийМодуль("СообщенияПользователю");
		КонецЕсли;
	#КонецЕсли

	Если НовоеНаименование = Шаблон Тогда
		Если МодульСообщенияПользователю <> Неопределено Тогда
			МодульСообщенияПользователю.ПоказатьСВыводомВЖурналРегистрации(
				"ПервоначальноеЗаполнение_НевозможноСформироватьНовыеДанные"
			);
		Иначе
			Сообщить("Невозможно сформировать новые данные по шаблону.");
			
	
			ОбщиеМеханизмы.ЗаписатьСообщениеДляЖурналаРегистрации(
					"Ошибка проведения",
					"Предупреждение",
					Неопределено,
					"Невозможно сформировать новые данные по шаблону."
				);
		КонецЕсли;
		Возврат ТекущееНаименование;
	КонецЕсли;
	// формируем текущее наименование используя шаблн
	СтароеНаименование = ШаблонСтарыхпараметров;
	Для Каждого ЭлементСтруктуры Из СтруктураСтарыхЗначений Цикл
		СтароеНаименование = СтрЗаменить(СтароеНаименование,ЭлементСтруктуры.Ключ,ЭлементСтруктуры.Значение);
	КонецЦикла;	
	СтароеНаименование = СокрЛП(СтароеНаименование);	
	Если СтароеНаименование = Шаблон Тогда
		Если МодульСообщенияПользователю <> Неопределено Тогда
			МодульСообщенияПользователю.ПоказатьСВыводомВЖурналРегистрации(
				"Настройки_НевозможноСформироватьНовыеДанные"
			);
		Иначе
			Сообщить("Невозможно сформировать новые данные по шаблону.");
			
	
			ОбщиеМеханизмы.ЗаписатьСообщениеДляЖурналаРегистрации(
					"Ошибка проведения",
					"Предупреждение",
					Неопределено,
					"Невозможно сформировать новые данные по шаблону."
				);
		КонецЕсли;
		Возврат ТекущееНаименование;
	КонецЕсли;

	// если текущее нименование заполнено по шаблону или не заполнено
	Если ПустаяСтрока(ТекущееНаименование) ИЛИ СтароеНаименование =  ТекущееНаименование Тогда
		Возврат НовоеНаименование;
	Иначе
		// если не по шаблону, то попытаемся найти и заменить новые значения
		ВозвращаемоеНаименование = ТекущееНаименование;
		Для Каждого ЭлементСтруктуры Из СтруктураСтарыхЗначений Цикл
			// если в новых полях есть старое поле с другим значением
			Если СтруктураНовыхЗначений.Свойство(ЭлементСтруктуры.Ключ) И 
				ЭлементСтруктуры.Значение <> СтруктураНовыхЗначений[ЭлементСтруктуры.Ключ] Тогда
				ВозвращаемоеНаименование = СтрЗаменить(
														ВозвращаемоеНаименование,
														ЭлементСтруктуры.Значение,
														СтруктураНовыхЗначений[ЭлементСтруктуры.Ключ]
											);
			КонецЕсли;
		КонецЦикла;
		Возврат СокрЛП(ВозвращаемоеНаименование);
	КонецЕсли;
КонецФункции  //ПолучитьСтрокуПоШаблонуИЗначениямПолей()

&НаСервере
////
// Функция: РазбитьСтрокуПоВерхнемуРегистру
//     Функция разбития строк по верхнему регистру(как синонимы)
//
// Параметры
//  СтрокаРазбиения  - стркоа до разбиения
//                 
//  Разделитель  - символ разделяющий строку
//                 
// Возвращаемое значение:
//   Строка   - строка разбитая по алгоритму.
///
Функция РазбитьСтрокуПоВерхнемуРегистру(СтрокаРазбиения = "", Разделитель = " ") Экспорт
	Перем  Синоним;
	Синоним = "";
	Если СтрДлина(СтрокаРазбиения) = 0 Тогда
		Возврат Синоним;
	КонецЕсли;
	// первый символ не проверяем и переводим в верхний регистр
	Синоним = ВРег(Лев(СтрокаРазбиения, 1));
	Итератор = 1;
	Пока Итератор < СтрДлина(СтрокаРазбиения) Цикл
		СледующийСимвол = Сред(СтрокаРазбиения, Итератор+ 1, 1);
		Если СледующийСимвол <> НРег(СледующийСимвол) Тогда
			Синоним = Синоним + Разделитель;;
		КонецЕсли;
		Синоним = Синоним + НРег(СледующийСимвол);
		Итератор = Итератор + 1;
	КонецЦикла;
	Возврат Синоним;
КонецФункции // РазбитьСтрокуПоВерхнемуРегистру() 

////
 // Функция: СогласоватьЧислительное
 //
 // Параметры:
 //   Число
 //   что1 - строка
 //   чего2 - строка
 //   чего5 - строка
 ///
Функция СогласоватьЧислительное(Число, что1, чего2, чего5) Экспорт
	Ост100_ = Число % 100;
	Если 10 < Ост100_ И Ост100_ < 20 Тогда
		Возврат "" + Число + " " + чего5;
	КонецЕсли;
	Ост10_ = Число % 10;
	Если 1 = Ост10_ Тогда
		Возврат "" + Число + " " + что1;
	ИначеЕсли 1 < Ост10_ И Ост10_ < 5 Тогда
		Возврат "" + Число + " " + чего2;
	КонецЕсли;
	Возврат "" + Число + " " + чего5;
КонецФункции

// Получить следующий код на основе предыдущего. Код должен содержать только цифры, 
// буквы латинского или кириллического алфавита.
//
// Параметры:
//  ПредыдущийКод - Строка - 
// 
// Возвращаемое значение:
//  Строка - Код
//
Функция ПолучитьСледующийКод(ПредыдущийКод) Экспорт
	ПредыдущиеСимволы_ = "0123456789";
	СледующиеСимволы_ = "1234567890";
	ПредыдущиеСимволы_ = ПредыдущиеСимволы_ + "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";
	СледующиеСимволы_ = СледующиеСимволы_ + "бвгдежжзийклмнопрстуфхцчшщъыьэюяа";
	ПредыдущиеСимволы_ = ПредыдущиеСимволы_ + "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	СледующиеСимволы_ = СледующиеСимволы_ + "БВГДЕЖЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯА";
	ПредыдущиеСимволы_ = ПредыдущиеСимволы_ + "abcdefghijklmnopqrstuvwxyz";
	СледующиеСимволы_ = СледующиеСимволы_ + "bcdefghijklmnopqrstuvwxyza";
	ПредыдущиеСимволы_ = ПредыдущиеСимволы_ + "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	СледующиеСимволы_ = СледующиеСимволы_ + "BCDEFGHIJKLMNOPQRSTUVWXYZA";
	КонечныеСимволы_ = "9ЯяZz";
	
	СледующийКодСформирован_ = Ложь;
	СледующийКод_ = Строка(ПредыдущийКод);
	Индекс_ = СтрДлина(СледующийКод_);
	Пока Индекс_ > 0 И СледующийКодСформирован_ = Ложь Цикл
		Символ_ = Сред(СледующийКод_, Индекс_, 1);
		Позиция_ = СтрНайти(ПредыдущиеСимволы_, Символ_);
		Если Позиция_ <> 0 Тогда
			СледующийКод_ = Сред(СледующийКод_, 1, Индекс_ - 1) + 
				Сред(СледующиеСимволы_, Позиция_, 1) + 
				Сред(СледующийКод_, Индекс_ + 1);
			Если Не СтрНайти(КонечныеСимволы_, Символ_) Тогда
				СледующийКодСформирован_ = Истина;
			КонецЕсли;
		КонецЕсли;
		Индекс_ = Индекс_ - 1;
	КонецЦикла;
	Возврат СледующийКод_;
КонецФункции

// Разбиение исходной строки на строку требуемой длины с учетом слов.
//
// Параметры:
//  ИсходнаяСтрока - Строка - 
//  ТребуемаяДлина - Число - 
// 
// Возвращаемое значение:
//  Массив - Пустой массив или массив из одной или двух строк.
//
Функция РазбитьСтрокуСУчетомСлов(Знач ИсходнаяСтрока, ТребуемаяДлина) Экспорт
	ИтоговыеСтроки_ = Новый Массив;
	Если ТребуемаяДлина < СтрДлина(ИсходнаяСтрока) Тогда
		ЛеваяЧасть_ = Лев(ИсходнаяСтрока, ТребуемаяДлина + 1);
		ПозицияПробела_ = СтрНайти(ЛеваяЧасть_, " ", НаправлениеПоиска.СКонца);
		Если ПозицияПробела_ > 0 Тогда
			ИтоговыеСтроки_.Добавить(Лев(ИсходнаяСтрока, ПозицияПробела_));
			ИтоговыеСтроки_.Добавить(СокрЛ(Сред(ИсходнаяСтрока, ПозицияПробела_ + 1)));
		КонецЕсли;
	Иначе
		ИтоговыеСтроки_.Добавить(ИсходнаяСтрока);
	КонецЕсли;
	Возврат ИтоговыеСтроки_;
КонецФункции

#Область КлючиСтроки

// Возвращает новый уникальный ключ строки для таблицы
//
// Параметры:
//   Таблица - Данные формы коллекция, ТаблицаЗначений -
//     Табличная часть, таблица значений, коллекция,
//     для которой нужно создать новый ключ строки.
//   ИмяКолонкиКлючаСтроки - Строка - 
//     Имя колонки, в которой расположен ключ строки, по умолчанию "КлючСтроки"
//
// Возврат:
//  Число - Новый ключ строки, число, уникальное в колонке ключа строки.
///
Функция НовыйКлючСтроки(Таблица, ИмяКолонкиКлючаСтроки = "КлючСтроки") Экспорт
	Перем МаксКлюч, СтрокаТаблицы;
	
	МаксКлюч = 0;
	
	Для Каждого СтрокаТаблицы из Таблица Цикл
		Если СтрокаТаблицы[ИмяКолонкиКлючаСтроки] > МаксКлюч Тогда
			МаксКлюч = СтрокаТаблицы[ИмяКолонкиКлючаСтроки];
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксКлюч + 1;
	
КонецФункции

// Выполняет в таблице поиск строки с заданным ключом строки.
//
// Параметры:
//   КлючСтроки
//     Значение ключа строки, которое необходимо найти.
//   Таблица.
//     Табличная часть, таблица значений, коллекция,
//     для которой нужно создать новый ключ строки.
//   ИмяКолонкиКлючаСтроки
//     Имя колонки, в которой расположен ключ строки, по умолчанию "КлючСтроки"
//
// Возврат:
//   Строка, с заданным ключом строки или Неопределено.
///
Функция НайтиСтрокуПоКлючу(КлючСтроки, Таблица, ИмяКолонкиКлючаСтроки = "КлючСтроки") Экспорт
	Перем СтрокаТаблицы;
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		Если СтрокаТаблицы[ИмяКолонкиКлючаСтроки] = КлючСтроки Тогда
			Возврат СтрокаТаблицы;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
КонецФункции

#КонецОбласти
//////////////////////////////////////////////////////////////////////////////
//
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
//
//////////////////////////////////////////////////////////////////////////////

////
 // Процедура: __ПРОВЕРКА___ЦИКЛА
 //   Выполняет проверку на количество итераций цикла.
 //
 // Параметры:
 //   СчетчикЦикла {Число, Неопределено}
 //     Переменная, хранящая число итераций цикла.
 //   МаксимальноеЧислоИтераций {Число}
 //     Максимальное число итераций, допустимое для цикла.
 //   Сообщение {Строка}
 //     Сообщение, которое выводится, если проверка обнаруживает ошибку.
 ///
Процедура __ПРОВЕРКА___ЦИКЛА(СчетчикЦикла, МаксимальноеЧислоИтераций, Сообщение)
	
	ОбщиеМеханизмыКлиентСервер.__ПРОВЕРКА___ЦИКЛА(
		СчетчикЦикла,
		МаксимальноеЧислоИтераций,
		"ОбщийМодуль.АлгоритмыДляКоллекций." + Сообщение
	);
	
КонецПроцедуры

#КонецОбласти

#Область ЮнитТесты

Процедура __ТЕСТ__(ПроверкаНаличияПроцедуры = Ложь) Экспорт
	
	#Область ДобавитьВМассив
	
		Массив_ = Новый Массив;
		Массив_.Добавить(1);
		Эталон_ = Новый Массив;
		Эталон_.Добавить(1);
		
		Массив_ = ДобавитьВМассив(Массив_);
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1);
		Для Элемент_ = 1 По 1 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2);
		Для Элемент_ = 1 По 2 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3);
		Для Элемент_ = 1 По 3 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4);
		Для Элемент_ = 1 По 4 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5);
		Для Элемент_ = 1 По 5 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6);
		Для Элемент_ = 1 По 6 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7);
		Для Элемент_ = 1 По 7 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8);
		Для Элемент_ = 1 По 8 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9);
		Для Элемент_ = 1 По 9 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		Для Элемент_ = 1 По 10 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11);
		Для Элемент_ = 1 По 11 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
		Для Элемент_ = 1 По 12 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
		Для Элемент_ = 1 По 13 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
		Для Элемент_ = 1 По 14 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);
		Для Элемент_ = 1 По 15 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
		Для Элемент_ = 1 По 16 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17);
		Для Элемент_ = 1 По 17 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18);
		Для Элемент_ = 1 По 18 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19);
		Для Элемент_ = 1 По 19 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
		Для Элемент_ = 1 По 20 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21);
		Для Элемент_ = 1 По 21 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22);
		Для Элемент_ = 1 По 22 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23);
		Для Элемент_ = 1 По 23 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24);
		Для Элемент_ = 1 По 24 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25);
		Для Элемент_ = 1 По 25 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26);
		Для Элемент_ = 1 По 26 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28);
		Для Элемент_ = 1 По 28 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
		Массив_ = ДобавитьВМассив(Массив_, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29);
		Для Элемент_ = 1 По 29 Цикл Эталон_.Добавить(Элемент_); КонецЦикла;
		__ПРОВЕРКА__(СтрСоединить(Массив_, ";") = СтрСоединить(Эталон_, ";"));
		
	#КонецОбласти
	
КонецПроцедуры

#КонецОбласти
