#Область СлужебныеПроцедурыИФункции

// Определяет тип объекта по текстовому представлению.
//
// Параметры:
//  ОписаниеТипаОбъекта - Строка - текстовое представление типа объекта.
//
// Возвращаемое значение:
//  Строка - тип справочника.
//
Функция ТипОбъекта(ОписаниеТипаОбъекта) Экспорт
	
	ТипОбъекта = Неопределено;
	
	ИмяПрикладногоСправочника = ОбщегоНазначенияБЭД.ИмяПрикладногоСправочника(ОписаниеТипаОбъекта);
	Если ЗначениеЗаполнено(ИмяПрикладногоСправочника) Тогда
		ТипОбъекта = "СправочникСсылка." + ИмяПрикладногоСправочника;
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

Процедура ЗаполнитьПараметрыОбработкиОшибокВСтрокеДерева(СтрокаДерева, ПараметрыОбработкиОшибок) Экспорт
	
	Если ТипЗнч(ПараметрыОбработкиОшибок) = Тип("Структура") Тогда
		ПараметрыОбработкиОшибок.Свойство("ТекстОшибки", СтрокаДерева.ТекстОшибки);
		ПараметрыОбработкиОшибок.Свойство("КлючСообщения", СтрокаДерева.КлючСообщения);
		ПараметрыОбработкиОшибок.Свойство("ПутьКДаннымСообщения", СтрокаДерева.ПутьКДаннымСообщения);
		ПараметрыОбработкиОшибок.Свойство("НавигационнаяСсылка", СтрокаДерева.НавигационнаяСсылка);
		ПараметрыОбработкиОшибок.Свойство("ИмяФормы", СтрокаДерева.ИмяФормы);
		ПараметрыОбработкиОшибок.Свойство("ПараметрыФормы", СтрокаДерева.ПараметрыФормы);
	ИначеЕсли ТипЗнч(ПараметрыОбработкиОшибок) = Тип("Строка") Тогда
		СтрокаДерева.ТекстОшибки = ПараметрыОбработкиОшибок;
	КонецЕсли;

КонецПроцедуры

// Формирует дерево данных для заполнения или чтения прикладным решением.
//
// Параметры:
//  Макет - Макет - Макет с описанием структуры дерева (см. Обработка.ОбменСКонтрагентами.Макеты).
//
// Возвращаемое значение:
//  ДеревоЗначений - Дерево документа.
//
Функция ДеревоЭлектронногоДокумента(Макет) Экспорт
	
	ВысотаТаблицы = Макет.ВысотаТаблицы;
	ШиринаТаблицы = Макет.ШиринаТаблицы;
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	// Считаем колонки из макета и добавим их в таблицу значений.
	Для НомерКолонки = 1 По ШиринаТаблицы Цикл
		ОбластьШапки = Макет.Область(5,НомерКолонки);
		Если Не ЗначениеЗаполнено(ОбластьШапки.Текст) Тогда
			ОбластьШапки = Макет.Область(4,НомерКолонки);
		КонецЕсли;
		НазваниеКолонки = ОбластьШапки.Текст;
		ТаблицаЗначений.Колонки.Добавить(НазваниеКолонки);
	КонецЦикла;
	
	// Считаем все перечисленные в макете реквизиты и добавим в таблицу значений.
	Для НомерСтроки = 7 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаЗначений.Добавить();
		Для НомерКолонки = 0 По ШиринаТаблицы-1 Цикл
			НоваяСтрока.Установить(НомерКолонки, Макет.Область(НомерСтроки, НомерКолонки + 1).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаЗначений, НоваяСтрока, Макет);
	КонецЦикла;
	
	// Добавим служебные колонки, не описанные в макете.
	ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаЗначений);
	
	// Добавим некоторые колонки при необходимости (для совместимости с макетами старого формата).
	КолонкиДереваДокумента = КолонкиДереваДокумента();
	Для Каждого Колонка Из КолонкиДереваДокумента Цикл
		Если ТаблицаЗначений.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаЗначений.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	КолУровней = 0;
	
	// Перенесем колонки в дерево значений и заодно вычислим максимальный уровень.
	ДеревоЗначений = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ДеревоЗначений.Колонки.Добавить(Колонка.Имя);
		Если СтрНайти(Колонка.Имя, "Уровень") > 0 Тогда
			НомерУровня = Число(Сред(Колонка.Имя, 8, 2));
			Если НомерУровня > КолУровней Тогда
				КолУровней = НомерУровня;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Рекурсивно заполним дерево по таблице.
	ПолныйПуть = "";
	РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, 1, КолУровней, ПолныйПуть, ТаблицаЗначений, 0);
	
	Возврат ДеревоЗначений;
	
КонецФункции

// Возвращает список колонок, добавляемых в дерево данных электронного документа помимо объявленных в макете.
// 
// Возвращаемое значение:
//  ФиксированныйМассив - массив колонок.
//
Функция КолонкиДереваДокумента()

	СписокКолонок = Новый Массив;
	
	// Колонки с уровнями не описываем, так как их число динамическое.
	
	СписокКолонок.Добавить("Обязательное");
	СписокКолонок.Добавить("ПараметрыОбработкиОбязательны");
	СписокКолонок.Добавить("ОписаниеОграничений");
	СписокКолонок.Добавить("КодПредставления");
	СписокКолонок.Добавить("Признак");
	СписокКолонок.Добавить("Типы");
	СписокКолонок.Добавить("КвалификаторыЧисла");
	СписокКолонок.Добавить("КвалификаторыСтроки");
	СписокКолонок.Добавить("КвалификаторыДаты");
	
	Возврат Новый ФиксированныйМассив(СписокКолонок);

КонецФункции 

Процедура РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, Знач НомерУровня, КолУровней, Знач ПолныйПутьВДереве, ТЗ, НомерСтрокиТЗ)
	
	ЛокальныйПуть = ПолныйПутьВДереве;
	СтрокаТекУровня = Неопределено;
	Пока НомерСтрокиТЗ < ТЗ.Количество() Цикл
		СтрокаТЗ = ТЗ[НомерСтрокиТЗ];
		Для Сч = НомерУровня По КолУровней Цикл
			ИдТекУровня = "Уровень" + Сч;
			Если ТЗ.Колонки.Найти(ИдТекУровня) <> Неопределено И ЗначениеЗаполнено(СтрокаТЗ[ИдТекУровня]) Тогда
				Если НомерУровня < Сч Тогда
					РекурсивноЗаполнитьСтрокиДерева(СтрокаТекУровня, Сч, КолУровней, ЛокальныйПуть, ТЗ, НомерСтрокиТЗ);
				ИначеЕсли НомерУровня = Сч Тогда
					СтрокаТекУровня = ДеревоЗначений.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаТекУровня, СтрокаТЗ);
					СтрокаТекУровня.ТипЗначения = ОписаниеТипаПоПараметрам(СтрокаТЗ.Типы, СтрокаТЗ.КвалификаторыЧисла, СтрокаТЗ.КвалификаторыСтроки, СтрокаТЗ.КвалификаторыДаты);
					ЛокальныйПуть = ?(ПолныйПутьВДереве = "", "", ПолныйПутьВДереве + ".") + СтрокаТекУровня["Уровень" + Сч];
					СтрокаТекУровня.ПолныйПуть = ЛокальныйПуть;
				КонецЕсли;
				НомерСтрокиТЗ = НомерСтрокиТЗ + 1;
				Прервать;
			КонецЕсли;
			Если Сч >= КолУровней Тогда
				НомерСтрокиТЗ = НомерСтрокиТЗ - 1;
				Возврат;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Преобразует текстовое описание типа в объект ОписаниеТипов.
//
// Параметры:
//  Типы			 - Массив, Строка - см. ОписаниеТипов().
//  ОписаниеЧисла	 - Строка - см. КвалификаторыЧислаПоОписанию().
//  ОписаниеСтроки	 - Строка - см. КвалификаторыСтрокиПоОписанию().
//  ОписаниеДаты	 - Строка - см. КвалификаторыДатыПоОписанию().
// 
// Возвращаемое значение:
//  ОписаниеТипов - сформированное описание типов.
//
Функция ОписаниеТипаПоПараметрам(Типы, ОписаниеЧисла, ОписаниеСтроки, ОписаниеДаты)

	Результат = Новый ОписаниеТипов();
	
	Если ЗначениеЗаполнено(Типы) Тогда
	
		КвалификаторыЧисла = КвалификаторыЧислаПоОписанию(ОписаниеЧисла);
		КвалификаторыСтроки = КвалификаторыСтрокиПоОписанию(ОписаниеСтроки);
		КвалификаторыДаты = КвалификаторыДатыПоОписанию(ОписаниеДаты);
		
		Результат = Новый ОписаниеТипов(Типы, КвалификаторыЧисла, КвалификаторыСтроки, КвалификаторыДаты);
	
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Формирует квалификатор строки по текстовому описанию.
//
// Параметры:
//  ОписаниеСтроки	 - Строка - содержит значения параметров конструктора "КвалификаторыСтроки", перечисленные через
//                              запятую. В качестве допустимого знака указывается имя одного из значений системного
//                              перечисления "ДопустимаяДлина". Пример: "100, Переменная".
// 
// Возвращаемое значение:
//  КвалификаторыСтроки - сформированный квалификатор.
//
Функция КвалификаторыСтрокиПоОписанию(ОписаниеСтроки) 

	Результат = Неопределено;
	
	Если ЗначениеЗаполнено(ОписаниеСтроки) Тогда
		ПараметрыОписания = СтрРазделить(ОписаниеСтроки, ",", Истина);
		
		ДлинаСтроки = 0;
		ДопустимаяДлинаКвалификатора = ДопустимаяДлина.Переменная;
		
		// Получим длину строки
		Если ПараметрыОписания.Количество() > 0 Тогда
			ОписаниеДлиныСтроки = СокрЛП(ПараметрыОписания[0]);
			Если ЗначениеЗаполнено(ОписаниеДлиныСтроки) Тогда
				ДлинаСтроки = Число(ОписаниеДлиныСтроки);
			КонецЕсли;
		КонецЕсли;
		
		// Получим описание допустимого знака.
		Если ПараметрыОписания.Количество() > 1 Тогда
			ОписаниеДопустимойДлины = СокрЛП(ПараметрыОписания[1]);
			Если ЗначениеЗаполнено(ОписаниеДопустимойДлины) Тогда
				ДопустимаяДлинаКвалификатора = ДопустимаяДлина[ОписаниеДопустимойДлины];
			КонецЕсли;
		КонецЕсли;
		
		Результат = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлинаКвалификатора);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Формирует квалификатор даты по текстовому описанию.
//
// Параметры:
//  ОписаниеДаты	 - Строка - содержит значения параметров конструктора "КвалификаторыДаты", перечисленные через
//                              запятую. В качестве допустимого знака указывается имя одного из значений системного
//                              перечисления "ЧастиДаты". Пример: "ДатаВремя".
// 
// Возвращаемое значение:
//  КвалификаторыДаты - сформированный квалификатор.
//
Функция КвалификаторыДатыПоОписанию(ОписаниеДаты) 

	Результат = Неопределено;
	
	Если ЗначениеЗаполнено(ОписаниеДаты) Тогда
		ПараметрыОписания = СтрРазделить(ОписаниеДаты, ",", Истина);
		
		ЧастиДатыКвалификатора = ЧастиДаты.ДатаВремя;
		
		// Получим описание допустимого знака.
		Если ПараметрыОписания.Количество() > 0 Тогда
			ОписаниеЧастейДаты = СокрЛП(ПараметрыОписания[0]);
			Если ЗначениеЗаполнено(ОписаниеЧастейДаты) Тогда
				ЧастиДатыКвалификатора = ЧастиДаты[ОписаниеЧастейДаты];
			КонецЕсли;
		КонецЕсли;
		
		Результат = Новый КвалификаторыДаты(ЧастиДатыКвалификатора);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции 

// Формирует квалификатор числа по текстовому описанию.
//
// Параметры:
//  ОписаниеЧисла	 - Строка - содержит значения параметров конструктора "КвалификаторыЧисла", перечисленные через
//                              запятую. В качестве допустимого знака указывается имя одного из значений системного
//                              перечисления "ДопустимыйЗнак". Пример: "15, 3, Неотрицательный".
// 
// Возвращаемое значение:
//  КвалификаторыЧисла - сформированный квалификатор.
//
Функция КвалификаторыЧислаПоОписанию(ОписаниеЧисла)

	Результат = Неопределено;
	
	Если ЗначениеЗаполнено(ОписаниеЧисла) Тогда
		ПараметрыОписания = СтрРазделить(ОписаниеЧисла, ",", Истина);
		
		ЧислоРазрядов = 0;
		ЧислоРазрядовДробнойЧасти = 0;
		ДопустимыйЗнакКвалификатора = ДопустимыйЗнак.Любой;
		
		// Получим число разрядов.
		Если ПараметрыОписания.Количество() > 0 Тогда
			ОписаниеРазрядов = СокрЛП(ПараметрыОписания[0]);
			Если ЗначениеЗаполнено(ОписаниеРазрядов) Тогда
				ЧислоРазрядов = Число(ОписаниеРазрядов);
			КонецЕсли;
		КонецЕсли;
		
		// Получим число разрядов дробной части.
		Если ПараметрыОписания.Количество() > 1 Тогда
			ОписаниеРазрядовДробнойЧасти = СокрЛП(ПараметрыОписания[1]);
			Если ЗначениеЗаполнено(ОписаниеРазрядовДробнойЧасти) Тогда
				ЧислоРазрядовДробнойЧасти = Число(ОписаниеРазрядовДробнойЧасти);
			КонецЕсли;
		КонецЕсли;
		
		// Получим описание допустимого знака.
		Если ПараметрыОписания.Количество() > 2 Тогда
			ОписаниеДопустимогоЗнака = СокрЛП(ПараметрыОписания[2]);
			Если ЗначениеЗаполнено(ОписаниеДопустимогоЗнака) Тогда
				ДопустимыйЗнакКвалификатора = ДопустимыйЗнак[ОписаниеДопустимогоЗнака];
			КонецЕсли;
		КонецЕсли;
		
		Результат = Новый КвалификаторыЧисла(ЧислоРазрядов, ЧислоРазрядовДробнойЧасти, ДопустимыйЗнакКвалификатора);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаДерева)

	Колонки = Новый Массив;
	
	Колонки.Добавить("ТипЗначения");
	Колонки.Добавить("Значение");
	Колонки.Добавить("ПолныйПуть");
	Колонки.Добавить("ТекстОшибки");
	Колонки.Добавить("ПутьКДаннымСообщения");
	Колонки.Добавить("КлючСообщения");
	Колонки.Добавить("НавигационнаяСсылка");
	Колонки.Добавить("ИмяФормы");
	Колонки.Добавить("ПараметрыФормы");
	
	Для Каждого Колонка Из Колонки Цикл
		Если ТаблицаДерева.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаДерева.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	// Сдвинем колонки "Значение" и "ПолныйПуть" в начало для удобства отладки.
	КолонкаЗначение = ТаблицаДерева.Колонки.Найти("Значение");
	ТаблицаДерева.Колонки.Сдвинуть(КолонкаЗначение, -ТаблицаДерева.Колонки.Индекс(КолонкаЗначение));
	КолонкаПолныйПуть = ТаблицаДерева.Колонки.Найти("ПолныйПуть");
	ТаблицаДерева.Колонки.Сдвинуть(КолонкаПолныйПуть, -ТаблицаДерева.Колонки.Индекс(КолонкаПолныйПуть));

КонецПроцедуры

// См. ЭлектронноеВзаимодействие.ДанныеЭлементаДереваЭлектронногоДокумента
Функция ДанныеЭлементаДереваЭлектронногоДокумента(Знач Дерево, Знач Путь) Экспорт
	
	ЭлементДерева = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
	Если ЭлементДерева = Неопределено Тогда
		ВызватьИсключение ОбщегоНазначенияБЭД.СформироватьТекстИсключения(
			"НедопустимыеПараметрыМетода", "ДанныеЭлементаДереваЭлектронногоДокумента/НеверноеЗначениеПараметра/Путь");
	КонецЕсли;
	
	Данные = Неопределено;
	
	Если ЭлементДерева.Признак = "Таблица" Тогда
		
		Данные = ДанныеТаблицыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Группа" Тогда
		
		Данные = ДанныеГруппыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Выбор" Тогда
		
		Данные = ДанныеВыбораДереваЭлектронногоДокумента(ЭлементДерева);
		
	Иначе
		
		Данные = ДанныеЗначенияДереваЭлектронногоДокумента(ЭлементДерева);
		
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Функция ЭтоНоменклатура(СсылкаНаОбъект) Экспорт
	
	Результат = Ложь;
	Результат = ТипЗнч(СсылкаНаОбъект) = Тип(ДеревоЭлектронногоДокументаБЭД.ТипОбъекта("Номенклатура"));
	
	Если Не Результат Тогда
		НоменклатураКонтрагентов = "СправочникСсылка.НоменклатураКонтрагентов";
		Результат = ТипЗнч(СсылкаНаОбъект) = Тип(НоменклатураКонтрагентов);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеГруппыДереваЭлектронногоДокумента(Знач ГруппаДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ГруппаДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ГруппаДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеВыбораДереваЭлектронногоДокумента(Знач ВыборДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ВыборДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Если ИмяПоля <> ВыборДерева.Значение Тогда
			Продолжить;
		КонецЕсли;
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ВыборДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеТаблицыДереваЭлектронногоДокумента(Знач ТаблицаДерева)
	
	Данные = Новый ТаблицаЗначений;
	
	СтрокаНомерСтроки = ТаблицаДерева.Строки[0];
	Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
		ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
		Данные.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	Если Не ЗначениеЗаполнено(ТаблицаДерева.Значение) Тогда
		Возврат Данные;
	КонецЕсли;
	
	Для Каждого СтрокаНомерСтроки Из ТаблицаДерева.Строки Цикл
		
		НоваяСтрока = Данные.Добавить();
		
		Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
			
			ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
			НоваяСтрока[ИмяКолонки] = ДанныеЭлементаДереваЭлектронногоДокумента(СтрокаНомерСтроки, СтрокаКолонки.ПолныйПуть);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеЗначенияДереваЭлектронногоДокумента(Знач ЗначениеДерева)
	
	Значение = ЗначениеДерева.Значение;
	
	Если Не ЗначениеЗаполнено(Значение) Тогда
		
		Если ЗначениеДерева.Типы = "Строка" Тогда
			Значение = "";
		ИначеЕсли ЗначениеДерева.Типы = "Число" Тогда
			Значение = 0;
		ИначеЕсли ЗначениеДерева.Типы = "Дата" Тогда
			Значение = Дата(1, 1, 1);
		Иначе
			Значение = Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Процедура ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаМакета, СтрокаТаблицы, Макет)
	
	ИмяОбластиТипа = СтрокаТаблицы.Признак;
	
	Если Не ЗначениеЗаполнено(ИмяОбластиТипа) Тогда
		Возврат;
	КонецЕсли;
	Если Макет.Области.Найти(ИмяОбластиТипа) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МакетТипа = Макет.ПолучитьОбласть(ИмяОбластиТипа);
	
	ТаблицаТипа = ТаблицаМакета.СкопироватьКолонки();
	
	ВысотаТаблицы = МакетТипа.ВысотаТаблицы;
	ШиринаТаблицы = МакетТипа.ШиринаТаблицы;
	
	Для НомерСтроки = 1 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаТипа.Добавить();
		Для НомерКолонки = 1 По ШиринаТаблицы Цикл
			НоваяСтрока.Установить(НомерКолонки - 1, МакетТипа.Область(НомерСтроки, НомерКолонки).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаТипа, НоваяСтрока, Макет);
	КонецЦикла;
	
	СдвигУровня = 0;
	СчетчикУровня = 1;
	Пока Истина Цикл
		ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
		Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ЗначениеКолонки = СтрокаТаблицы[ИмяКолонки];
		Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
			СдвигУровня = СчетчикУровня - 1;
			Прервать;
		КонецЕсли;
		СчетчикУровня = СчетчикУровня + 1;
	КонецЦикла;
	
	// Из первой строки берем только признак.
	СтрокаТаблицы.Признак = ТаблицаТипа[0].Признак;
	
	Для НомерСтроки = 2 По ТаблицаТипа.Количество() Цикл
		
		СтрокаТаблицыТипа = ТаблицаТипа[НомерСтроки - 1];
		СтрокаТаблицыМакета = ТаблицаМакета.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыМакета, СтрокаТаблицыТипа);
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.КодПредставления)
			И ЗначениеЗаполнено(СтрокаТаблицыТипа.КодПредставления) Тогда
			СтрокаТаблицыМакета.КодПредставления = СтрШаблон("%1_%2", СтрокаТаблицы.КодПредставления, СтрокаТаблицыТипа.КодПредставления);
		КонецЕсли;
		
		// Вычислим текущий уровень.
		ТекущийУровень = 0;
		СчетчикУровня = 1;
		Пока Истина Цикл
			ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			ЗначениеКолонки = СтрокаТаблицыМакета[ИмяКолонки];
			Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
				ТекущийУровень = СчетчикУровня;
				Прервать;
			КонецЕсли;
			СчетчикУровня = СчетчикУровня + 1;
		КонецЦикла;
		// Сдвинем уровень.
		Если ЗначениеЗаполнено(СдвигУровня) Тогда
			НовыйУровень = ТекущийУровень + СдвигУровня;
			ИмяКолонкиТекущий = "Уровень" + Формат(ТекущийУровень, "ЧГ=0");
			ИмяКолонкиНовый = "Уровень" + Формат(НовыйУровень, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонкиНовый) = Неопределено Тогда
				ТаблицаМакета.Колонки.Добавить(ИмяКолонкиНовый);
			КонецЕсли;
			СтрокаТаблицыМакета[ИмяКолонкиНовый] = СтрокаТаблицыМакета[ИмяКолонкиТекущий];
			СтрокаТаблицыМакета[ИмяКолонкиТекущий] = "";
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева.
// Только для внутреннего использования.
// Параметры:
//  ДеревоДанных                            - деревоЗначений - дерево с данными.
//  Ошибки                                  - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                                     Состав структур см. в ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки().
//  ЭтоТаблица                              - Булево - если Истина, то проверяется табличная часть.
//  НомерСтроки                             - Число, Неопределено - номер проверяемой строки табличной части.
//  ПроверятьОбязательностьПараметровОшибки - Булево - определяет, нужно ли проверять, заданы ли параметры обработки ошибок
//                                                     в тех реквизитах, для которых это обязательно.
//  ДатаПоФорматуФНС                        - Булево - если установлена в Истину, значения типа "Дата" будут проверяться дополнительно
//                                                     на вхождение в диапазон лет 1900-2099 (требование схем ФНС).
//
Процедура ПроверитьЗаполнениеРеквизитовДереваДанных(ДеревоДанных, Ошибки, ЭтоТаблица,
	НомерСтроки = Неопределено, ПроверятьОбязательностьПараметровОшибки = Истина, ДатаПоФорматуФНС = Ложь) Экспорт
	
	НомерСтрокиДляПодстановки = ?(ЭтоТаблица, НомерСтроки, Неопределено);
	СтрокаДерева = Неопределено; // в этой переменной будем хранить последнюю считанную строку дерева данных
	
	Для Каждого СтрокаДерева Из ДеревоДанных.Строки Цикл
		ТекстОшибки = "";
		
		РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
		
		// Проверяем заполнение самого реквизита.
		ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
	
		Если ЗначениеЗаполнено(ТекстОшибки) Тогда
			ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки,, НомерСтрокиДляПодстановки);
			
			Продолжить;
		КонецЕсли;
		
		// Запускаем проверки подчиненных реквизитов, если это структурированное значение.
		Если СтрокаДерева.Признак = "Таблица" И (ТипЗнч(СтрокаДерева.Значение) = Тип("Число") И СтрокаДерева.Значение > 0 ИЛИ СтрокаДерева.Обязательное = "Да")Тогда
			Для Каждого СтрокаТаблицы Из СтрокаДерева.Строки Цикл
				ПроверитьЗаполнениеРеквизитовДереваДанных(СтрокаТаблицы, Ошибки, Истина, СтрокаТаблицы.Значение,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			КонецЦикла;
		ИначеЕсли СтрокаДерева.Признак = "Выбор" И (ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ СтрокаДерева.Обязательное = "Да") Тогда
			ПроверяемаяСтрока = СтрокаДерева.Строки.Найти(СтрокаДерева.ПолныйПуть + "." + СтрокаДерева.Значение, "ПолныйПуть");
			Если ЗначениеЗаполнено(ПроверяемаяСтрока) Тогда
				// Поскольку сменили текущую строку дерева, нужно проверить заполнение самого реквизита.
				ПроверитьЗаполнениеРеквизитаДереваДанных(ПроверяемаяСтрока, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
			
				Если ЗначениеЗаполнено(ТекстОшибки) Тогда
					ДобавитьОшибкуПроверкиДереваДанных(Ошибки, ПроверяемаяСтрока, ТекстОшибки,, НомерСтрокиДляПодстановки);
					
					Продолжить;
				КонецЕсли;
				
				ПроверитьЗаполнениеРеквизитовДереваДанных(ПроверяемаяСтрока, Ошибки, Ложь,,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			Иначе
				ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
				
				ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки);
			КонецЕсли;
		ИначеЕсли СтрокаДерева.Признак = "Группа" И СтрокаДерева.Значение = Истина И СтрокаДерева.Строки.Количество() > 0 Тогда
			ПроверитьЗаполнениеРеквизитовДереваДанных(СтрокаДерева, Ошибки, Ложь,,
				РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает стандартный текст ошибки для незаполненного значения дерева.
// 
// Возвращаемое значение:
//  Строка - текст ошибки.
//
Функция ТекстОшибкиНеЗаполненногоЗначенияДерева() Экспорт
	
	Возврат НСтр("ru = 'значение не заполнено'");

КонецФункции

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			 				 - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                     Состав структур см. ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки.
//  СтрокаДерева			 		 - СтрокаДереваЗначений - строка дерева электронного документа, по реквизиту которой
//                                     фиксируется ошибка.
//  ТекстОшибки				 		 - Строка - текст фиксируемой ошибки.
//  ПодставлятьИмяРеквизита	 		 - Булево - если Истина, в начало сообщения об ошибке будет подставлено
//                                     прикладное имя реквизита.
//  НомерСтрокиДанных		 		 - Число - если указана, будет подставлена в имя реквизита.
//  ПрикладноеПредставлениеРеквизита - Строка - если указано, представление реквизита не будет получаться по строке дерева - 
//                                     будет использовано указанное представление.
//
Процедура ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки, ПодставлятьИмяРеквизита = Истина,
	НомерСтрокиДанных = Неопределено, ПрикладноеПредставлениеРеквизита = "") Экспорт
	
	// Даже если по каким-то причинам не нашли строку дерева, все равно выдаем ошибку. Лучше выдать неполное сообщение
	// об ошибке, чем пропустить некорректный документ.
	Если СтрокаДерева <> Неопределено Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
		
		ПараметрыОбработкиОшибки = ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева);
	
		Если ПодставлятьИмяРеквизита Тогда
			Если Не ЗначениеЗаполнено(ПрикладноеПредставлениеРеквизита) Тогда
				ПрикладноеПредставлениеРеквизита = ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДерева, НомерСтрокиДанных);
			КонецЕсли;

			ТекстОшибки = СтрШаблон("%1: %2", ПрикладноеПредставлениеРеквизита, ТекстОшибки);
		КонецЕсли;
	Иначе
		ПараметрыОбработкиОшибки = ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки();
	КонецЕсли;
	
	ОбщегоНазначенияБЭД.ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки);

КонецПроцедуры

// Формирует прикладное представление реквизита дерева электронного документа.
//
// Параметры:
//  СтрокаДереваДанных	 - СтрокаДереваЗначений - строка реквизита дерева электронного документа.
//  НомерСтрокиДанных	 - Число - номер строки, который будет подставлен по возможности в представление.
// 
// Возвращаемое значение:
//  Строка - прикладное представление реквизита дерева.
//
Функция ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДереваДанных, НомерСтрокиДанных = Неопределено)
	
	ШаблонПрикладногоПредставления = ПрикладноеПредставлениеРеквизита(
		СтрокаДереваДанных.КодПредставления);
		
	Если НомерСтрокиДанных = Неопределено Тогда
		ПрикладноеПредставление = ШаблонПрикладногоПредставления;
	Иначе
		Если СтрНайти(ШаблонПрикладногоПредставления, "%1") > 0 Тогда
			ПрикладноеПредставление = СтрШаблон(ШаблонПрикладногоПредставления, Формат(НомерСтрокиДанных, "ЧГ="));
		Иначе
			ПрикладноеПредставление = ШаблонПрикладногоПредставления;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПрикладноеПредставление) Тогда
		ПрикладноеПредставление = СтрЗаменить(СтрокаДереваДанных.ПолныйПуть, ".", " - ");
		
		Если ЗначениеЗаполнено(НомерСтрокиДанных) Тогда
			ПрикладноеПредставление = СтрШаблон("%1(%2)", ПрикладноеПредставление, Формат(НомерСтрокиДанных, "ЧГ="));
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПрикладноеПредставление;

КонецФункции

// Прикладное представление реквизита по коду.
//
// Параметры:
//  Код - Строка - код реквизита.
// 
// Возвращаемое значение:
//  Строка - представления реквизита.
//
Функция ПрикладноеПредставлениеРеквизита(Код)
	
	СоответствиеКодовРеквизитовИПредставлений = Новый Соответствие;
	
	Макет = Обработки.ЭлектронноеВзаимодействие.ПолучитьМакет(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("ПрикладноеПредставлениеРеквизитов_%1",
		ОбщегоНазначения.КодОсновногоЯзыка()));
	ВысотаТаблицы = Макет.ВысотаТаблицы;
	Для НСтр = 1 По ВысотаТаблицы Цикл
		СоответствиеКодовРеквизитовИПредставлений.Вставить(СокрЛП(Макет.Область(НСтр, 1).Текст), СокрЛП(Макет.Область(НСтр,2).Текст));
	КонецЦикла;

	Возврат СоответствиеКодовРеквизитовИПредставлений.Получить(Код);
	
КонецФункции

Функция ПараметрыОбработкиОшибкиУказаны(СтрокаДерева)

	Результат = Ложь;
	
	Если СтрокаДерева <> Неопределено Тогда
		Результат = ЗначениеЗаполнено(СтрокаДерева.ТекстОшибки)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ПутьКДаннымСообщения) И СтрокаДерева.КлючСообщения <> Неопределено
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.НавигационнаяСсылка)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ИмяФормы);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции 

Функция ПолучитьПредставлениеТипаПоСтрокеДерева(Строка, ДатаПоФорматуФНС = Ложь)

	ОписанияСтроками = Новый Массив;
	
	ОписаниеТипа = Строка.ТипЗначения;
	Для Каждого Тип Из ОписаниеТипа.Типы() Цикл
		ПредставлениеТипа = НРег(Строка(Тип));
		
		Если Тип = Тип("Строка") Тогда
			Если ОписаниеТипа.КвалификаторыСтроки.Длина > 0 Тогда
				Если ОписаниеТипа.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда
					ПредставлениеСтроки = СтрШаблон(НСтр("ru = 'до %1 символов'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				Иначе
					ПредставлениеСтроки = СтрШаблон(НСтр("ru = '%1 символов'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				КонецЕсли;
				
				ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 %2'"), ПредставлениеТипа, ПредставлениеСтроки);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Число") Тогда
			Если ОписаниеТипа.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru = 'неотрицательное %1'"), ПредставлениеТипа);
			КонецЕсли;
			
			Если ОписаниеТипа.КвалификаторыЧисла.Разрядность > 0 Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 формата %2.%3'"), ПредставлениеТипа, 
					ОписаниеТипа.КвалификаторыЧисла.Разрядность - ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти,
					ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Дата") И ДатаПоФорматуФНС Тогда
			ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 с 01.01.1900 до 31.12.2099 г.'"), ПредставлениеТипа);
		КонецЕсли;
		
		ОписанияСтроками.Добавить(ПредставлениеТипа);
	КонецЦикла;
	
	Возврат СтрСоединить(ОписанияСтроками, " ИЛИ ");

КонецФункции

Функция ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС = Ложь)

	Результат = СтрокаДерева.ТипЗначения.ПривестиЗначение(СтрокаДерева.Значение) = СтрокаДерева.Значение;
	
	// Выполним дополнительную проверку для форматов ФНС.
	Если Результат И ДатаПоФорматуФНС И ТипЗнч(СтрокаДерева.Значение) = Тип("Дата") Тогда
		Если СтрокаДерева.Значение < Дата(1900, 1, 1) ИЛИ СтрокаДерева.Значение >= Дата(2100, 1, 1) Тогда
			Результат = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Функция ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева)

	ДанныеОшибки = ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки(СтрокаДерева.КлючСообщения,
		СтрокаДерева.ПутьКДаннымСообщения, СтрокаДерева.НавигационнаяСсылка, СтрокаДерева.ИмяФормы, 
		СтрокаДерева.ПараметрыФормы, СтрокаДерева.ТекстОшибки);
	
	Возврат ДанныеОшибки;

КонецФункции

Процедура ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева)
	
	// Если при внедрении не указали параметры обработки ошибки для реквизитов, для которых это обязательно, будет выдано исключение.
	Если НРег(СтрокаДерева.ПараметрыОбработкиОбязательны) = "да" И Не ПараметрыОбработкиОшибкиУказаны(СтрокаДерева) Тогда
		ТекстИсключения = СтрШаблон(НСтр("ru = 'Не указаны параметры обработки ошибки для реквизита %1'"),
			СтрокаДерева.ПолныйПуть);
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки)
	
	// Не проверяем, заполнены ли параметры обработки ошибок только если реквизит необязателен и не заполнен:
	// такая ситуация может возникнуть для условно-обязательных реквизитов. Для них параметры обработки ошибки могли быть
	// заданы только при заполнении реквизита. А поскольку заполнения не было, то и параметры не были указаны.
	РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
	Если ПроверятьОбязательностьПараметровОшибки И РеквизитЗаполненИлиОбязателен Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
	КонецЕсли;
	
	// Проверим строку на заполненность, если реквизит обязательный.
	Если СтрокаДерева.Обязательное = "Да" И Не ЗначениеЗаполнено(СтрокаДерева.Значение) Тогда
		
		ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
		
		// Проверим строку на соответствие типу
	ИначеЕсли ЗначениеЗаполнено(СтрокаДерева.Значение) И СтрокаДерева.ТипЗначения <> Неопределено
		И Не ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС) Тогда
		
		ШаблонОшибки = НСтр("ru = 'неверный тип значения ""%1"" (ожидаемый тип: %2)'");
		ПредставлениеТипаЗначения = ПолучитьПредставлениеТипаПоСтрокеДерева(СтрокаДерева, ДатаПоФорматуФНС);
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, СтрокаДерева.Значение,
		ПредставлениеТипаЗначения);
		
	КонецЕсли;
	
КонецПроцедуры


// Извлекает данные для сопоставления номенклатуры из строки товара дерева документа.
//
// Параметры:
//  СтрокаТовара - СтрокаДереваЗначений - строка товара дерева документа, из которой нужно извлечь данные.
//
// Возвращаемое значение:
//  Структура - информация для сопоставления товаров.
//
Функция ИзвлечьСопоставлениеНоменклатурыИзДереваДокумента(Знач СтрокаТовара) Экспорт
	
	ПутьКСопоставлению = СтрокаТовара.ПолныйПуть + ".Сопоставление";
	
	ЕстьСопоставление = ДеревоЭлектронногоДокументаБЭД.ЗначениеРеквизитаВДереве(
		СтрокаТовара, ПутьКСопоставлению, Ложь);
		
	Если ЕстьСопоставление = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Сопоставление = Новый Структура;
	Сопоставление.Вставить("Идентификатор");
	Сопоставление.Вставить("Наименование");
	Сопоставление.Вставить("Характеристика");
	Сопоставление.Вставить("ЕдиницаИзмерения");
	Сопоставление.Вставить("ЕдиницаИзмеренияКод");
	Сопоставление.Вставить("Артикул");
	Сопоставление.Вставить("СтавкаНДС");
	Сопоставление.Вставить("Штрихкод");
	Сопоставление.Вставить("НоменклатураИБ");
	Сопоставление.Вставить("ХарактеристикаИБ");
	Сопоставление.Вставить("УпаковкаИБ");
	
	Для Каждого Элемент Из Сопоставление Цикл
		
		Значение = ДеревоЭлектронногоДокументаБЭД.ЗначениеРеквизитаВДереве(
			СтрокаТовара, ПутьКСопоставлению + "." + Элемент.Ключ, Ложь);
		Если ЗначениеЗаполнено(Значение) Тогда
			Сопоставление.Вставить(Элемент.Ключ, Значение);
		Иначе
			Сопоставление.Удалить(Элемент.Ключ);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Сопоставление;
	
КонецФункции

Процедура ДобавитьСсылкуНаОбъект(СсылкиНаОбъектыПоИндексам, СсылкаНаОбъект, ИндексСтроки) Экспорт
	
	Если СсылкиНаОбъектыПоИндексам <> Неопределено Тогда
		СсылкиНаОбъектыПоИндексам.Вставить(ИндексСтроки, СсылкаНаОбъект);
	КонецЕсли;
	
КонецПроцедуры

Функция ЭтоСсылочныйОбъект(ТипОбъекта) Экспорт
	
	Если ТипОбъекта = "Штамп" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция СтруктураКолонокТаблицыДерева(Дерево, НазваниеТаблицы) Экспорт
	
	СтруктураВозврата = Новый Структура;
	
	СтрокаДерева = Дерево.Строки.Найти(НазваниеТаблицы + ".НомерСтроки", "ПолныйПуть", Истина);
	Для Каждого Подстрока Из СтрокаДерева.Строки Цикл
		НазваниеКолонки = НазваниеКолонки(Подстрока.ПолныйПуть);
		Если НазваниеКолонки = "ДопДанные" Тогда
			СтруктураВозврата.Вставить("ДопДанныеПодписанные");
			СтруктураВозврата.Вставить("ДопДанныеНеПодписанные");
		Иначе
			СтруктураВозврата.Вставить(НазваниеКолонки);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтруктураВозврата;
	
КонецФункции

// Возвращает название реквизита из полного пути
//
// Параметры:
//  ПолныйПуть - Строка - Полный путь до реквизита в дереве.
//
// Возвращаемое значение:
//  Строка - Название реквизита
//
Функция НазваниеКолонки(ПолныйПуть) Экспорт
	
	ПозицияРазделителя = СтрНайти(ПолныйПуть, ".", НаправлениеПоиска.СКонца);
	Если ПозицияРазделителя = 0 Тогда
		Результат = СокрЛП(ПолныйПуть);
	Иначе
		Результат = СокрЛП(Сред(ПолныйПуть, ПозицияРазделителя + 1));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ДанныеШапкиДерева(ДеревоДанных) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, ДеревоДанных.Строки);
	
	Возврат ТаблицаВозврата;
	
КонецФункции

Функция ДанныеТаблицыДерева(ДеревоДанных, НазваниеТаблицы) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	СтрокаТаблицы = ДеревоДанных.Строки.Найти(НазваниеТаблицы, "ПолныйПуть");
	НомерСтроки = СтрокаТаблицы.Строки[0];
	Для Каждого Строка Из НомерСтроки.Строки Цикл
		ТаблицаВозврата.Колонки.Добавить(НазваниеКолонки(Строка.ПолныйПуть));
	КонецЦикла;
	
	Для Каждого Строка Из СтрокаТаблицы.Строки Цикл
		НовСтрока = ТаблицаВозврата.Добавить();
		Для Каждого СтрокаРеквизита Из Строка.Строки Цикл
			ИмяКолонки = НазваниеКолонки(СтрокаРеквизита.ПолныйПуть);
			Если СтрокаРеквизита.Признак = "Таблица" Тогда
				НовСтрока[ИмяКолонки] = ДанныеТаблицыДерева(Строка, СтрокаРеквизита.ПолныйПуть);
			Иначе
				НовСтрока[ИмяКолонки] = СтрокаРеквизита.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
		
	Возврат ТаблицаВозврата;
	
КонецФункции

Процедура СкопироватьСтрокиДереваДляТаблицыРекурсивно(СтрокаПолучатель, СтрокаИсточник) Экспорт
	
	СлужебныеСвойства = "ТекстОшибки, ПутьКДаннымСообщения, КлючСообщения, НавигационнаяСсылка, ИмяФормы, ПараметрыФормы";
	
	Для Каждого Реквизит Из СтрокаИсточник.Строки Цикл
		Если НазваниеКолонки(Реквизит.ПолныйПуть) = "НомерСтроки" И ТипЗнч(Реквизит.Значение) = Тип("Число")
				И Реквизит.Значение > 1 Тогда
			Прервать;
		КонецЕсли;
		НовСтрока = СтрокаПолучатель.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НовСтрока, Реквизит,, СлужебныеСвойства);
		НовСтрока.Значение = "";
		Если Реквизит.Строки.Количество() > 0 Тогда
			СкопироватьСтрокиДереваДляТаблицыРекурсивно(НовСтрока, Реквизит);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Возвращает строку дерева значений для заполнения в прикладном решении
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево с данными
//  НазваниеПоля - Строка - название поля в дереве, содержащее полный путь к реквизиту
//  НайтиРекурсивно - Булево, Истина - если требуется рекурсивный поиск.
//
// Возвращаемое значение:
//  Строка таблицы значений - содержит строку дерева.
//
Функция СтрокаДерева(ДеревоДанных, НазваниеПоля, НайтиРекурсивно = Ложь) Экспорт
	
	СтрокаВозврата = ДеревоДанных.Строки.Найти(НазваниеПоля, "ПолныйПуть", НайтиРекурсивно);
	Если СтрокаВозврата.Признак = "Группа" Тогда
		СтрокаВозврата.Значение = Истина;
	КонецЕсли;
	Возврат СтрокаВозврата;

КонецФункции

// В процедуре происходит добавление данных из СтруктурыДанных в ДеревоЗначений.
//
// Параметры:
//  СтрокаДерева - ДеревоЗначений, СтрокаДереваЗначений - содержит данные.
//  СтруктураДопДанных - Структура - данные, которые необходимо поместить в дерево.
//  ЮридическиЗначимый - Булево - если Истина - то текущие данные необходимо по возможности поместить в основной ЭД.
//  ДобавлятьНовыеСтроки - Булево - если Истина - разрешает добавление строк с одинаковым путем в дерево.
//
Процедура ДобавитьДопДанныеВДерево(СтрокаДерева, СтруктураДопДанных, ЮридическиЗначимый = Ложь, ДобавлятьНовыеСтроки = Ложь) Экспорт
	
	Если СтруктураДопДанных.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если СтрокаДерева.Строки.Родитель = Неопределено Тогда
		СтрокаДереваЗначений = СтрокаДерева(СтрокаДерева, "ДопДанные");
		Если ЮридическиЗначимый Тогда
			СтрокаДопДанные = СтрокаДереваЗначений.Строки.Найти("ДопДанные.Подписанные", "ПолныйПуть");
		Иначе
			СтрокаДопДанные = СтрокаДереваЗначений.Строки.Найти("ДопДанные.НеПодписанные", "ПолныйПуть");
		КонецЕсли;
	ИначеЕсли НазваниеКолонки(СтрокаДерева.ПолныйПуть) = "ДопДанныеПодписанные"
			ИЛИ НазваниеКолонки(СтрокаДерева.ПолныйПуть) = "ДопДанныеНеПодписанные" Тогда
		СтрокаДопДанные = СтрокаДерева;
	Иначе
		СтрокаДерева.Значение = Истина;
		СтрокаДопДанные = СтрокаДерева.Строки[?(ЮридическиЗначимый, 0 ,1)];
	КонецЕсли;
	СтрокаДопДанные.Значение = Истина;
	
	Для Каждого Элемент Из СтруктураДопДанных Цикл
		
		Если ТипЗнч(Элемент) = Тип("СтрокаТаблицыЗначений") Тогда
			Ключ = Элемент.Идентификатор;
			Значение = Элемент.Значение;
		Иначе
			Ключ = Элемент.Ключ;
			Значение = Элемент.Значение;
		КонецЕсли;
		
		СтруктураДанныхДерева = Новый Структура;
		СтруктураДанныхДерева.Вставить("Идентификатор", Ключ);
		СтруктураДанныхДерева.Вставить("Значение", Значение);

		ДеревоЭлектронногоДокументаБЭД.ДобавитьЗаписьВТаблицуДерева(СтрокаДопДанные.Родитель, СтруктураДанныхДерева, СтрокаДопДанные.ПолныйПуть);
	КонецЦикла;
	
КонецПроцедуры

// Записывает данные из таблицы значений в дерево значений.
//
// Параметры:
//  Дерево - ДеревоЗначений - дерево данных, в котором необходимо сохранить данные.
//  ТаблицаДанных - таблицаЗначений - записываемые в дерево данные. Таблица может предварительно дополняться данными
//                                    для обработки ошибок:
//                                    см. ЭлектронноеВзаимодействие.ДобавитьВТаблицуОбработкуОшибкиЧерезСообщениеПользователю,
//                                    ЭлектронноеВзаимодействие.ДобавитьВТаблицуОбработкуОшибкиЧерезНавигационнуюСсылку,
//                                    ЭлектронноеВзаимодействие.ДобавитьВТаблицуОбработкуОшибкиЧерезОткрытиеФормы.
//  
//  НазваниеТаблицы - Строка - название таблицы в дереве.
//
Процедура ЗагрузитьТаблицуВДерево(Дерево, ТаблицаДанных, НазваниеТаблицы) Экспорт
	
	СтрокаТаблицы = Дерево.Строки.Найти(НазваниеТаблицы, "ПолныйПуть", Истина);
	НомерСтроки = 0;
	Для Каждого СтрокаДанных Из ТаблицаДанных Цикл
		НомерСтроки = НомерСтроки + 1;
		Если НомерСтроки = 1 Тогда
			ТекСтрока = СтрокаТаблицы.Строки[0];
		Иначе
			ПерваяСтрока = СтрокаТаблицы.Строки[0];
			ТекСтрока = СтрокаТаблицы.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(ТекСтрока, ПерваяСтрока);
			ДеревоЭлектронногоДокументаБЭДСлужебный.СкопироватьСтрокиДереваДляТаблицыРекурсивно(ТекСтрока, ПерваяСтрока);
		КонецЕсли;
		ТекСтрока.Значение = НомерСтроки;
		Для Каждого Колонка Из ТаблицаДанных.Колонки Цикл
			Если Колонка.Имя = "НаборПараметровОбработкиОшибок" Тогда
				// Для каждого реквизита, для которого заданы параметры обработки ошибок, запишем их в соответствующую
				// строку дерева (строку реквизита).
				НаборПараметровОбработкиОшибок = СтрокаДанных[Колонка.Имя];
				Если НаборПараметровОбработкиОшибок <> Неопределено Тогда
					Для Каждого ЭлементНабораОбработкиОшибок Из НаборПараметровОбработкиОшибок Цикл
						ПолныйПуть = НазваниеТаблицы + ".НомерСтроки." + ЭлементНабораОбработкиОшибок.ИмяКолонки;
						СтрокаРеквизита = ТекСтрока.Строки.Найти(ПолныйПуть, "ПолныйПуть", Истина);
						
						Если СтрокаРеквизита <> Неопределено Тогда
							ДеревоЭлектронногоДокументаБЭДСлужебный.ЗаполнитьПараметрыОбработкиОшибокВСтрокеДерева(СтрокаРеквизита,
								ЭлементНабораОбработкиОшибок.ПараметрыОбработкиОшибок);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			Иначе
				ПолныйПуть = НазваниеТаблицы + ?(Колонка.Имя = "НомерСтроки", ".", ".НомерСтроки.") + Колонка.Имя;
				СтрокаРеквизита = ТекСтрока.Строки.Найти(ПолныйПуть, "ПолныйПуть");
				ДеревоЭлектронногоДокументаБЭДСлужебный.ОбработатьРеквизитДереваСУчетомПризнака(СтрокаДанных, ТекСтрока, СтрокаРеквизита,
					Колонка.Имя, ПолныйПуть);
			КонецЕсли;
		КонецЦикла
		
	КонецЦикла;
	СтрокаТаблицы.Значение = ТаблицаДанных.Количество();
	
	МассивРеквизитов = ОбщегоНазначенияКлиентСервер.РазложитьСтрокуПоТочкамИСлэшам(НазваниеТаблицы);
	Если МассивРеквизитов.Количество() = 1 Тогда
		Возврат;
	КонецЕсли;
	Путь = "";
	Для Каждого Элемент Из МассивРеквизитов Цикл
		Путь = ?(ЗначениеЗаполнено(Путь), Путь + "." + Элемент, Элемент);
		
		СтрокаДерева = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
		Если СтрокаДерева <> Неопределено Тогда
			Если СтрокаДерева.Признак = "Группа" Тогда
				СтрокаДерева.Значение = Истина;
			ИначеЕсли СтрокаДерева.Признак = "Выбор" Тогда
				ТекИндекс = МассивРеквизитов.Найти(Элемент);
				СтрокаДерева.Значение = МассивРеквизитов[ТекИндекс+1];
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Записывает данные из структуры в группу дерева значений
//
// Параметры:
//  Дерево - ДеревоЗначений - дерево данных, в котором необходимо сохранить данные
//  СтруктураДанных - Структура - данные, которые должны быть загружены в группу
//  Путь - Строка - название группы в дереве.
//
Процедура ЗагрузитьСтруктуруВГруппуДерева(Дерево, СтруктураДанных, Путь) Экспорт
	
	СтрокаТаблицы = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
	Для Каждого Элемент Из СтруктураДанных Цикл
		ПолныйПуть = Путь + "." + Элемент.Ключ;
		СтрокаРеквизита = СтрокаТаблицы.Строки.Найти(ПолныйПуть, "ПолныйПуть");
		ДеревоЭлектронногоДокументаБЭДСлужебный.ОбработатьРеквизитДереваСУчетомПризнака(СтруктураДанных, СтрокаТаблицы, СтрокаРеквизита,
			Элемент.Ключ, ПолныйПуть);
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьРеквизитДереваСУчетомПризнака(СтрокаДанных, ТекущаяСтрока, СтрокаРеквизита,
		ИмяКолонки, ПолныйПуть) Экспорт
	
	Если СтрокаРеквизита = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если СтрокаРеквизита.Признак = "Таблица"
		
		И Не СтрокаДанных[ИмяКолонки] = Неопределено Тогда
		ЗагрузитьТаблицуВДерево(ТекущаяСтрока, СтрокаДанных[ИмяКолонки], ПолныйПуть);
		
	ИначеЕсли СтрокаРеквизита.Признак = "Группа"
		
		И Не СтрокаДанных[ИмяКолонки] = Неопределено Тогда
		ЗагрузитьСтруктуруВГруппуДерева(ТекущаяСтрока, СтрокаДанных[ИмяКолонки], ПолныйПуть);
		СтрокаРеквизита.Значение = Истина;
		
	ИначеЕсли СтрокаРеквизита.Признак = "Выбор"
		И Не СтрокаДанных[ИмяКолонки] = Неопределено Тогда
		
		Для Каждого СтрокаРеквизитаПодчиненная Из СтрокаРеквизита.Строки Цикл
			
			ИмяКолонкиПодчиненной = Прав(СтрокаРеквизитаПодчиненная.ПолныйПуть,
			СтрДлина(СтрокаРеквизитаПодчиненная.ПолныйПуть) - СтрНайти(СтрокаРеквизитаПодчиненная.ПолныйПуть,
			".", НаправлениеПоиска.СКонца));
			
			Если (ТипЗнч(СтрокаДанных[ИмяКолонки]) = Тип("ТаблицаЗначений")
				И СтрокаДанных.Владелец().Колонки.Найти(ИмяКолонкиПодчиненной) = Неопределено)
				Или (ТипЗнч(СтрокаДанных[ИмяКолонки]) = Тип("Структура")
				И Не СтрокаДанных[ИмяКолонки].Свойство(ИмяКолонкиПодчиненной)) Тогда
				Продолжить;
			КонецЕсли;
			
			ТекущаяСтрокаПодчиненная = ТекущаяСтрока.Строки.Найти(ПолныйПуть, "ПолныйПуть");
			
			Если ТекущаяСтрокаПодчиненная = Неопределено Тогда
				Возврат;
			КонецЕсли;
			
			ОбработатьРеквизитДереваСУчетомПризнака(СтрокаДанных[ИмяКолонки], ТекущаяСтрокаПодчиненная,
				СтрокаРеквизитаПодчиненная, ИмяКолонкиПодчиненной, СтрокаРеквизитаПодчиненная.ПолныйПуть);
			
			МассивРеквизитов = ОбщегоНазначенияКлиентСервер.РазложитьСтрокуПоТочкамИСлэшам(СтрокаРеквизитаПодчиненная.ПолныйПуть);
			
			Если МассивРеквизитов.Количество() = 1 Тогда
				Возврат;
			КонецЕсли;
			
			Путь = "";
			Дерево = ТекущаяСтрока.Владелец();
			
			Для Каждого Элемент Из МассивРеквизитов Цикл
				
				Путь = ?(ЗначениеЗаполнено(Путь), Путь + "." + Элемент, Элемент);
				
				Если Путь = ПолныйПуть Тогда
					СтрокаДерева = ТекущаяСтрока.Строки.Найти(Путь, "ПолныйПуть", Истина);
				Иначе
					СтрокаДерева = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
				КонецЕсли;
				
				Если СтрокаДерева <> Неопределено Тогда
					Если СтрокаДерева.Признак = "Группа" Тогда
						СтрокаДерева.Значение = Истина;
					ИначеЕсли СтрокаДерева.Признак = "Выбор" Тогда
						ТекущийИндекс = МассивРеквизитов.Найти(Элемент);
						СтрокаДерева.Значение = МассивРеквизитов[ТекущийИндекс + 1];
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	Иначе
		
		Если СтрокаРеквизита.Признак <> "Выбор" Тогда
			
			СтрокаРеквизита.Значение = СтрокаДанных[ИмяКолонки];
			
			Если ЗначениеЗаполнено(СтрокаРеквизита.Родитель)
				И СтрокаРеквизита.Родитель.Признак = "Группа" Тогда
				СтрокаРеквизита.Родитель.Значение = Истина;
			КонецЕсли;
			
		КонецЕсли;
	
	КонецЕсли
	
КонецПроцедуры

Процедура ПодготовитьВходныеПараметрыДляДобавленияОбработкиОшибки(СтрокиТаблицы, НаборСтрок) Экспорт
	
	// Получим единую типизацию.
	Если ТипЗнч(СтрокиТаблицы) = Тип("Массив") Тогда
		ТаблицаДанных = СтрокиТаблицы[0].Владелец();
		НаборСтрок = СтрокиТаблицы;
	ИначеЕсли ТипЗнч(СтрокиТаблицы) = Тип("СтрокаТаблицыЗначений") Тогда
		ТаблицаДанных = СтрокиТаблицы.Владелец();
		НаборСтрок = Новый Массив;
		НаборСтрок.Добавить(СтрокиТаблицы);
	Иначе // таблица значений
		ТаблицаДанных = СтрокиТаблицы;
		НаборСтрок = СтрокиТаблицы;
	КонецЕсли;
	
	// Если в таблице нет служебной колонки, добавим ее.
	Если ТаблицаДанных.Колонки.Найти("НаборПараметровОбработкиОшибок") = Неопределено Тогда
		ТаблицаДанных.Колонки.Добавить("НаборПараметровОбработкиОшибок");
	КонецЕсли;

КонецПроцедуры

Процедура ДобавитьПараметрыОбработкиОшибкиВНабор(СтрокаТаблицыДанных, ПолеТаблицы, ПараметрыОбработкиОшибки) Экспорт
	
	ЭлементНабораПараметров = Новый Структура("ИмяКолонки, ПараметрыОбработкиОшибок",
		ПолеТаблицы, ПараметрыОбработкиОшибки);
	СтрокаТаблицыДанных.НаборПараметровОбработкиОшибок.Добавить(ЭлементНабораПараметров);

КонецПроцедуры

Функция ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, Значение, СтрокаПоСсылке = Неопределено) Экспорт
	
	НайденнаяСтрока = Неопределено;
	
	ЗначениеСтрокой = Строка(Значение);
	
	Если СтрНайти(ЗначениеСтрокой, "_") > 0 Тогда
		НайденнаяСтрока = ДеревоРазбора.Строки.Найти(ЗначениеСтрокой, "ИндексСтроки", Истина);
		СтрокаПоСсылке = НайденнаяСтрока;
	КонецЕсли;
	
	Возврат ?(НайденнаяСтрока = Неопределено, Ложь, Истина);
	
КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, НазваниеТаблицы = Неопределено)
	
	Для Каждого Строка Из СтрокиДерева Цикл
		Если НЕ Строка.Признак = "Таблица" Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
			Если Строка.Строки.Количество()>0 Тогда
				ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Строка.Строки);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти