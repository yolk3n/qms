//++ Локализация

#Область ПрограммныйИнтерфейс

#Область ДляВызоваИзДругихПодсистем

// КлиентЭДО

// Возвращает хеш сумму строки по алгоритму MD5.
//
// Параметры:
//  Данные - Строка - строка, по которой необходимо вычислить хеш.
//
// Возвращаемое значение:
//  Число - хеш, максимальная длина 20.
//
Функция Хеш_MD5_64(Знач Данные) Экспорт
	
	// Вычисляем хеш сумму по алгоритму MD5. Размер - 128 бит или 16 байт.
	Хеш = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеш.Добавить(Данные);
	ДвоичныеДанныеХешСуммы = Хеш.ХешСумма;
	
	// Заберем 8 байт из середины.
	Поток = ДвоичныеДанныеХешСуммы.ОткрытьПотокДляЧтения();
	ЧтениеДанных = Новый ЧтениеДанных(Поток);
	
	// Первые 4 байта не нужны, пропускаем.
	ЧтениеДанных.Пропустить(4);
	
	// Преобразует двоичные данные в int 64.
	Результат = ЧтениеДанных.ПрочитатьЦелое64(ПорядокБайтов.BigEndian);
	
	// Освобождаем память.
	ЧтениеДанных.Закрыть();
	Поток.Закрыть();
	
	Возврат Результат;
	
КонецФункции

// Конец КлиентЭДО

#КонецОбласти

#КонецОбласти

//-- Локализация

#Область СлужебныйПрограммныйИнтерфейс

#Область Блокировки

// Устанавливает управляемую блокировку по значениям полей.
//
// Параметры:
//  Пространство - Строка - пространство блокировки.
//  Поля - Структура - ключ задает имя поля пространства блокировки, а значение:
//                     1. Источник задан: соответствующее поле источника, содержащее значения для блокировки.
//                     2. Источник не задан: непосредственно значение для блокировки.
//  Источник - РезультатЗапроса, ТабличнаяЧасть, ТаблицаЗначений  - источник данных.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Неопределено - значение по умолчанию "Исключительный".
//
Процедура УстановитьУправляемуюБлокировку(Знач Пространство, Знач Поля = Неопределено, Знач Источник = Неопределено, Знач Режим = Неопределено) Экспорт
	
	Если Режим = Неопределено Тогда
		Режим = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Если Поля = Неопределено Тогда
		Поля = Новый Структура;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(Пространство);
	Если Источник = Неопределено Тогда
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.УстановитьЗначение(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	Иначе
		ЭлементБлокировки.ИсточникДанных = Источник;
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	ЭлементБлокировки.Режим = Режим;
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Устанавливает управляемую блокировку по ссылке на объект.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, по которой нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
Процедура УстановитьУправляемуюБлокировкуПоСсылке(Знач Ссылка, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура("Ссылка", Ссылка);
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

// Устанавливает управляемую блокировку по набору записей.
// Используются установленные отборы в наборе.
//
// Параметры:
//  Набор - РегистрСведенийНаборЗаписей, РегистрНакопленияНаборЗаписей - набор, по которому нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
Процедура УстановитьУправляемуюБлокировкуПоНаборуЗаписей(Знач Набор, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Набор.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура;
	Для каждого ЭлементОтбора Из Набор.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			Поля.Вставить(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

#КонецОбласти

#Область ЖурналРегистрации

// Возвращает параметры записи в журнал регистрации, см. ЗаписатьВЖурналРегистрации.
// 
// Возвращаемое значение:
// 	Структура - Описание:
// * ОбъектМетаданных - ОбъектМетаданных - см. синтакс-помощник к методу ЗаписьЖурналаРегистрации
// * Данные - Произвольный - см. синтакс-помощник к методу ЗаписьЖурналаРегистрации
// * РежимТранзакции - РежимТранзакцииЗаписиЖурналаРегистрации - см. синтакс-помощник к методу ЗаписьЖурналаРегистрации
Функция НовыеПараметрыЗаписиВЖурналРегистрации() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбъектМетаданных", Неопределено);
	Параметры.Вставить("Данные", Неопределено);
	Параметры.Вставить("РежимТранзакции", Неопределено);
	
	Возврат Параметры;
	
КонецФункции

// Данная процедура используется для стандартизации всех записей событий подсистемы ЭлектронноеВзаимодействие
// в журнал регистрации. В результате в журнал добавляется группировка записей с иерархией.
//  Электронное взаимодействие:
//    |_ Общая подсистема
//    |_ Обмен с банками
//    |_ Обмен с контрагентами
//    |_ Обмен с сайтами
//    |_ Регламентные задания
//    |_ Бизнес-сеть.
// Параметры:
//   Комментарий - Строка - см. синтакс-помощник к методу ЗаписьЖурналаРегистрации
//   Подсистема - Строка - имя подсистемы, см. ПодсистемыБЭД, будет добавлена к имени события
//   Уровень - УровеньЖурналаРегистрации - см. синтакс-помощник к методу ЗаписьЖурналаРегистрации, значение по
//                                         умолчанию УровеньЖурналаРегистрации.Ошибка.
//   ПараметрыЗаписи - см. НовыеПараметрыЗаписиВЖурналРегистрации
Процедура ЗаписатьВЖурналРегистрации(Комментарий, Подсистема, Уровень = Неопределено,
	ПараметрыЗаписи = Неопределено) Экспорт
	
	Если ПараметрыЗаписи = Неопределено Тогда
		ПараметрыЗаписи = НовыеПараметрыЗаписиВЖурналРегистрации();
	КонецЕсли;
	
	ПредставлениеОбщаяПодсистема = НСтр("ru = 'Общая подсистема'", ОбщегоНазначения.КодОсновногоЯзыка());
	
	Если Подсистема = "ЭлектронноеВзаимодействие" Тогда
		ПредставлениеПодсистемы = ПредставлениеОбщаяПодсистема;
	Иначе
		Если ОбщегоНазначения.ПодсистемаСуществует(Подсистема) Тогда
			ПолноеИмяПодсистемы = "Подсистема." + СтрЗаменить(Подсистема, ".", ".Подсистема.");
			ОбъектМетаданныхПодсистема = Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
			ПредставлениеПодсистемы = СтрШаблон(НСтр("ru = '%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
				ОбщегоНазначения.ПредставлениеОбъекта(ОбъектМетаданныхПодсистема));
		Иначе
			ПредставлениеПодсистемы = ПредставлениеОбщаяПодсистема;
		КонецЕсли;
	КонецЕсли;
	
	УровеньВажностиСобытия = ?(ТипЗнч(Уровень) = Тип("УровеньЖурналаРегистрации"),
		Уровень, УровеньЖурналаРегистрации.Ошибка);
		
	ПолноеИмяСобытия = СтрШаблон(НСтр("ru = 'Электронное взаимодействие.%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
		ПредставлениеПодсистемы);
	
	ЗаписьЖурналаРегистрации(ПолноеИмяСобытия, УровеньВажностиСобытия, ПараметрыЗаписи.ОбъектМетаданных,
		ПараметрыЗаписи.Данные, Комментарий, ПараметрыЗаписи.РежимТранзакции);
	
КонецПроцедуры

#КонецОбласти

#Область ПредставлениеОшибки

// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
// 
// Возвращаемое значение:
//  Строка
Функция КраткоеПредставлениеИнформацииОбОшибке(ИнформацияОбОшибке) Экспорт
	Возврат КраткоеПредставлениеОшибки(ИнформацияОбОшибке)
КонецФункции

// Параметры:
//  ИнформацияОбОшибке - ИнформацияОбОшибке
// 
// Возвращаемое значение:
//  Строка
Функция ПодробноеПредставлениеИнформацииОбОшибке(ИнформацияОбОшибке) Экспорт
	Возврат ПодробноеПредставлениеОшибки(ИнформацияОбОшибке)
КонецФункции

#КонецОбласти

//++ Локализация

#Область Запросы

// Конструктор описания запроса, используемого для последующего соединения с другими запросами
// 
// Возвращаемое значение:
// 	Структура - описание запроса:
// * СлужебныеПараметры - Структура - позволяет передать значения параметров запроса. В качестве ключа указывается имя
//    параметра, в качестве значения - его значение.
// * Текст - Строка - текст запроса.
Функция НовоеОписаниеЗапроса() Экспорт
	
	ОписаниеЗапроса = Новый Структура;
	ОписаниеЗапроса.Вставить("Текст", "");
	ОписаниеЗапроса.Вставить("СлужебныеПараметры", Новый Структура);
	
	Возврат ОписаниеЗапроса;
	
КонецФункции

// Соединяет запросы из переданных описаний в единый пакет.
// 
// Параметры:
// 	ОсновнойЗапрос - Запрос - объект запроса, в текст которого будут добавлены запросы из переданного списка описаний.
// 	ОписаниеДополнительныхЗапросов - Массив Из см. ОбщегоНазначенияБЭД.НовоеОписаниеЗапроса() - массив описаний добавляемых запросов.  
// Возвращаемое значение:
// 	Запрос - запрос, включающий все переданные пакеты.
Функция СоединитьЗапросы(ОсновнойЗапрос, Знач ОписаниеДополнительныхЗапросов) Экспорт
	
	Запрос = Новый Запрос;
	ТекстыЗапросов = Новый Массив;
	Сч = 1;
	Для каждого ОписаниеЗапроса Из ОписаниеДополнительныхЗапросов Цикл
		ПрефиксПараметров = "Запрос" + Сч;
		Для каждого Параметр Из ОписаниеЗапроса.СлужебныеПараметры Цикл
			НовоеИмяПараметра = ПрефиксПараметров + "_" + Параметр.Ключ;
			ОписаниеЗапроса.Текст = СтрЗаменить(ОписаниеЗапроса.Текст, Параметр.Ключ, НовоеИмяПараметра);
			Запрос.Параметры.Вставить(НовоеИмяПараметра, Параметр.Значение);
		КонецЦикла; 
		ТекстыЗапросов.Добавить(ОписаниеЗапроса.Текст);
		Сч = Сч + 1;
	КонецЦикла;
	
	ТекстыЗапросов.Добавить(ОсновнойЗапрос.Текст);
	
	Запрос.Текст = СтрСоединить(ТекстыЗапросов, ОбщегоНазначения.РазделительПакетаЗапросов());
	
	Возврат Запрос;
	
КонецФункции

// Формирует текст запроса по заданному шаблону.
// 
// Параметры:
// 	ТекстЗапроса - Строка - текст шаблона запроса. Может содержать переменные:
// 		&ВыбираемыеПоля - в это место будут вставляться поля, переданные в параметре ВыбираемыеПоля 
// 		&ПоляУсловия    - в это место будут вставляться условия, переданные в параметре ПоляУсловия
// 		&ИмяВременнойТаблицы - в это место будет вставлено имя временной таблицы.
// 	ИмяВременнойТаблицы - Строка - имя временной таблицы, которое будет задано в запросе.
// 	ВыбираемыеПоля      - Строка - перечисленные через запятую поля, которые необходимо выбрать.
// 						- Массив Из Строка - массив из имен полей.
// 	ПоляУсловия         - Строка - текст условия.
// 						- Массив Из Строка - массив текстов условий запросов.
// 	ПсевдонимТаблицы - Строка - псевдоним, который будет задан таблице.
// Возвращаемое значение:
// 	Строка - Текст запроса.
Функция ТекстЗапросаИзШаблона(ТекстЗапроса, ИмяВременнойТаблицы, ВыбираемыеПоля, ПоляУсловия, ПсевдонимТаблицы = "") Экспорт
	
	Если ПсевдонимТаблицы = "" Тогда
		ПсевдонимТаблицы = ИмяВременнойТаблицы;
	КонецЕсли;
	ТекстВыбираемыеПоля = ОбщегоНазначенияБЭДСлужебный.ТекстПолейДляЗапроса(ВыбираемыеПоля, ПсевдонимТаблицы, Ложь);
	ТекстПоляУсловия = ОбщегоНазначенияБЭДСлужебный.ТекстПолейДляЗапроса(ПоляУсловия, ПсевдонимТаблицы, Истина);
	
	Если ТекстПоляУсловия = "" Тогда
		ТекстПоляУсловия = "ИСТИНА";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыбираемыеПоля", ТекстВыбираемыеПоля);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляУсловия", ТекстПоляУсловия);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяВременнойТаблицы", ИмяВременнойТаблицы);
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Выполняет запрос в соответствии с переданным описанием запроса
// 
// Параметры:
// 	ОписаниеЗапроса - см. НовоеОписаниеЗапроса.
// 	УстанавливатьПривилегированныйРежим - Булево - если передана Истина, запрос будет выполняться в привилегированном режиме.
// Возвращаемое значение:
// 	ВыборкаИзРезультатаЗапроса - выборка из результатов переданного запроса.
Функция ВыполнитьЗапрос(ОписаниеЗапроса, УстанавливатьПривилегированныйРежим = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = ОписаниеЗапроса.Текст;
	
	ПрефиксПараметров = "Запрос1";
	Для каждого Параметр Из ОписаниеЗапроса.СлужебныеПараметры Цикл
		НовоеИмяПараметра = ПрефиксПараметров + "_" + Параметр.Ключ;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, Параметр.Ключ, НовоеИмяПараметра);
		Запрос.Параметры.Вставить(НовоеИмяПараметра, Параметр.Значение);
	КонецЦикла; 
	
	Если УстанавливатьПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	Выборка = Запрос.Выполнить();
	
	Возврат Выборка;
	
КонецФункции

// Объединить запросы.
//
// Параметры:
//  ЗапросПриемник      - Запрос - запрос приемник.
//  ЗапросТекстИсточник - Запрос, Строка - запрос источник.
//
Процедура ОбъединитьЗапросы(ЗапросПриемник, ЗапросТекстИсточник) Экспорт 
	
	Схема1 = Новый СхемаЗапроса;
	Схема1.УстановитьТекстЗапроса(ЗапросПриемник.Текст);
	
	Схема2 = Новый СхемаЗапроса;
	Если ТипЗнч(ЗапросТекстИсточник) = Тип("Строка") Тогда
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник);
	Иначе
		// Вариант запроса.
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник.Текст);
		Для каждого ЭлементКоллекции Из ЗапросТекстИсточник.Параметры Цикл
			ЗапросПриемник.Параметры.Добавить(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого ЭлементКоллекции2 Из Схема2.ПакетЗапросов Цикл
		
		ИндексЗапроса2 = Схема2.ПакетЗапросов.Индекс(ЭлементКоллекции2);
		ПакетДобавлен = Ложь;
		Для каждого ЭлементКоллекции1 Из Схема1.ПакетЗапросов Цикл
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				Продолжить;
			КонецЕсли;
			
			Представление1 = ЭлементКоллекции1.Представление();
			Представление2 = ЭлементКоллекции1.Представление();
			ТаблицаПомещения1 = "";
			ТаблицаПомещения2 = "";
			
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника1 = ЭлементКоллекции1.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника1 = ЭлементКоллекции1.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения1   = ЭлементКоллекции1.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ТипЗнч(ЭлементКоллекции2) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника2 = ЭлементКоллекции2.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника2 = ЭлементКоллекции2.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения2   = ЭлементКоллекции2.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Представление1)
				И ПсевдонимИсточника1 = ПсевдонимИсточника2
				И ТаблицаПомещения1 = ТаблицаПомещения2 Тогда
				ОбщегоНазначенияБЭДСлужебный.ОбъединитьПакетЗапросов(ЭлементКоллекции1, Схема2.ПакетЗапросов.Получить(ИндексЗапроса2));
				ПакетДобавлен = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ПакетДобавлен Тогда
			// Добавление подзапроса в запрос приемник.
			ОбщегоНазначенияБЭДСлужебный.ДобавитьЗапросВПакет(Схема1, ЭлементКоллекции2);
		КонецЕсли;
		
	КонецЦикла;
	
	ЗапросПриемник.Текст = Схема1.ПолучитьТекстЗапроса();
	
КонецПроцедуры

// Выполняет переданный запрос через СКД с указанными параметрами.
// 
// Параметры:
// 	ТекстЗапроса - Строка - текст запроса, который нужно выполнить.
// 	ВыбранныеПоляКомпоновки - Соответствие - в качестве ключа указывается имя поля, в качестве значения - его псевдоним.
// 	ПараметрыСхемыКомпоновки - Соответствие - в качестве ключа указывается имя параметра, в качестве значения - его значение.
// Возвращаемое значение: 
//  ТаблицаЗначений - результат выполнения запроса.
//
Функция ВыполнитьЗапросЧерезСКД(Знач ТекстЗапроса, Знач ВыбранныеПоляКомпоновки, Знач ПараметрыСхемыКомпоновки) Экспорт
	
	// Подготовим схему компоновки.
	
	КомпоновщикНастроек = Новый КомпоновщикНастроекКомпоновкиДанных;
	СхемаКомпоновкиДанных = Новый СхемаКомпоновкиДанных;
	
	Источник = СхемаКомпоновкиДанных.ИсточникиДанных.Добавить();
	Источник.Имя = "Источник";
	Источник.ТипИсточникаДанных = "Local";
	
	Набор = СхемаКомпоновкиДанных.НаборыДанных.Добавить(Тип("НаборДанныхЗапросСхемыКомпоновкиДанных"));
	Набор.Имя            = Источник.Имя;
	Набор.ИсточникДанных = Источник.Имя;
	Набор.АвтоЗаполнениеДоступныхПолей = Истина;
	Набор.Запрос         = ТекстЗапроса;
	
	КомпоновщикНастроек.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновкиДанных));
	КомпоновщикНастроек.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
	Настройки = КомпоновщикНастроек.Настройки;
	
	// Добавляем параметры.
	Для Каждого ОписаниеПараметраСхемыКомпоновки Из ПараметрыСхемыКомпоновки Цикл
		Настройки.ПараметрыДанных.УстановитьЗначениеПараметра(ОписаниеПараметраСхемыКомпоновки.Ключ,
			ОписаниеПараметраСхемыКомпоновки.Значение);
	КонецЦикла;
	
	// Добавляем выбранные поля.
	Настройки.Выбор.Элементы.Очистить();
	
	// Добавляем группировку.
	ДетальныеЗаписи = Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
	Для Каждого КлючИЗначение Из ВыбранныеПоляКомпоновки Цикл
		ВыбранноеПоле = ДетальныеЗаписи.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Заголовок     = КлючИЗначение.Значение;
		ВыбранноеПоле.Использование = Истина;
		ВыбранноеПоле.Поле          = Новый ПолеКомпоновкиДанных(КлючИЗначение.Ключ);
	КонецЦикла;
	
	// Выполняем схему компоновки.
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	Макет = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, КомпоновщикНастроек.ПолучитьНастройки(),,,
		Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновки.Инициализировать(Макет);
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	ТаблицаДанных = ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	
	// В полученной таблице данных корректные значения имен колонок содержатся в заголовке. Перенесем их в имя.
	Для Каждого Колонка Из ТаблицаДанных.Колонки Цикл
		Колонка.Имя = Колонка.Заголовок;
	КонецЦикла;
	
	Возврат ТаблицаДанных;

КонецФункции

#КонецОбласти

#Область Даты

// Преобразует дату в универсальную дату в миллисекундах.
// 
// Параметры:
// 	Дата - Дата - дата, которую нужно преобразовать.
// Возвращаемое значение:
// 	Число - универсальная дата.
Функция УниверсальнаяДатаВМиллисекундахИзДаты(Знач Дата) Экспорт
	
	УниверсальнаяДата = (Дата - Дата(1970, 1, 1)) * 1000;
	
	Возврат УниверсальнаяДата;
	
КонецФункции

// Преобразует универсальную дату в миллисекундах в значение с типом "Дата".
// 
// Параметры:
// 	УниверсальнаяДата - Число - дата в формате универсальной даты.
// Возвращаемое значение:
//  Дата - дата в обычном формате. 	
Функция ДатаИзУниверсальнойДатыВМиллисекундах(УниверсальнаяДата) Экспорт
	
	Возврат Дата(1970, 1, 1) + УниверсальнаяДата / 1000;
	
КонецФункции

#КонецОбласти

#Область JSON

// Конвертирует переданное значение в строку JSON
// 
// Параметры:
// 	Значение - Структура
// 	         - Соответствие
// 	ПараметрыЗаписи - ПараметрыЗаписиJSON
// Возвращаемое значение:
// 	Строка
Функция JSONСтрока(Значение, ПараметрыЗаписи = Неопределено) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
	ЗаписатьJSON(ЗаписьJSON, Значение);
	
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Конвертирует данные в формате JSON в значение 
// 
// Параметры:
// 	Данные - Строка
// 	       - ДвоичныеДанные
// 	       - Поток
// 	       - ПотокВПамяти
// 	       - ФайловыйПоток
// 	ПрочитатьВСоответствие - Булево - см. синтакс-помощник к методу ПрочитатьJSON
// Возвращаемое значение:
// 	- Структура
// 	- Соответствие
Функция JSONЗначение(Данные, ПрочитатьВСоответствие = Ложь) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	
	Если ТипЗнч(Данные) = Тип("Строка") Тогда
		ЧтениеJSON.УстановитьСтроку(Данные);
	ИначеЕсли ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда 
		Поток = Данные.ОткрытьПотокДляЧтения();
		ЧтениеJSON.ОткрытьПоток(Поток);
	ИначеЕсли ТипЗнч(Данные) = Тип("Поток") Или ТипЗнч(Данные) = Тип("ПотокВПамяти")
		Или ТипЗнч(Данные) = Тип("ФайловыйПоток") Тогда 
		ЧтениеJSON.ОткрытьПоток(Данные);
	КонецЕсли;
	
	Значение = ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие);
	
	ЧтениеJSON.Закрыть();
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Поток.Закрыть();
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

#КонецОбласти

#Область XML

// Возвращает кодировку, полученную из двоичных данных файла, если
// файл содержит объявление XML.
//
// Параметры:
//  ДвоичныеДанные - ДвоичныеДанные- двоичные данные файла.
//
// Возвращаемое значение:
//  Строка - кодировка файла. Если невозможно прочитать 
//                          объявление XML, возвращает пустую строку.
//
Функция КодировкаИзОбъявленияXML(ДвоичныеДанные) Экспорт
	
	БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
	ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьПоток(ПотокВПамяти);
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		КодировкаXML = ЧтениеXML.КодировкаXML;
	Исключение
		КодировкаXML = "";
	КонецПопытки;
	ЧтениеXML.Закрыть();
	ПотокВПамяти.Закрыть();
	
	Возврат КодировкаXML;
	
КонецФункции

// Добавляет в XML пространство имен.
//
// Параметры:
//  ДанныеXML - ДвоичныеДанные - Данные XML.
//  ПространствоИмен - Строка - Пространство имен, которое необходимо добавить.
//  Кодировка - Строка - Кодировка данных XML.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Двоичные данные XML с добавленным пространством имен.
//
Функция ДобавитьПространствоИмен(Знач ДанныеXML, Знач ПространствоИмен, Знач Кодировка = "windows-1251") Экспорт
	
	ПотокЧтения = ДанныеXML.ОткрытьПотокДляЧтения();
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьПоток(ПотокЧтения, , , Кодировка);
	
	ПостроительDOM = Новый ПостроительDOM();
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	ЧтениеXML.Закрыть();
	
	ДокументDOM.ЭлементДокумента.УстановитьСоответствиеПространстваИмен("", ПространствоИмен);
	
	ПотокЗаписи = Новый ПотокВПамяти();
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьПоток(ПотокЗаписи, Кодировка);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	ЗаписьXML.Закрыть();
	
	ДвоичныеДанные = ПотокЗаписи.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат ДвоичныеДанные;
	
КонецФункции

// Удаляет из XML пространство имен.
//
// Параметры:
//  ДанныеXML - ДвоичныеДанные - Данные XML.
//  ПространствоИмен - Строка - Пространство имен, которое необходимо удалить.
//  Кодировка - Строка - Кодировка данных XML.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Двоичные данные XML без удаленного пространства имен.
//
Функция УдалитьПространствоИмен(Знач ДанныеXML, Знач ПространствоИмен, Знач Кодировка = "windows-1251") Экспорт
	
	ПотокЧтения = ДанныеXML.ОткрытьПотокДляЧтения();
	
	Чтение = Новый ЧтениеТекста(ПотокЧтения, Кодировка);
	ТекстXML = Чтение.Прочитать();
	Чтение.Закрыть();
	
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ТекстXML);
	СтрокаФайл = Текст.ПолучитьСтроку(2);
	СтрокаФайл = СтрЗаменить(СтрокаФайл, "xmlns=""" + ПространствоИмен + """", "");
	Текст.ЗаменитьСтроку(2, СтрокаФайл);
	ТекстXML = Текст.ПолучитьТекст();
	
	ПотокЗаписи = Новый ПотокВПамяти();
	
	Запись = Новый ЗаписьТекста(ПотокЗаписи, Кодировка);
	Запись.Записать(ТекстXML);
	Запись.Закрыть();
	
	ДвоичныеДанные = ПотокЗаписи.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат ДвоичныеДанные;
	
КонецФункции

// Формирует XDTO-объект по двоичным данным XML.
//
// Параметры:
//  ДанныеXML - ДвоичныеДанные - Данные XML.
//  ПространствоИмен - Строка - Пространство имен.
//  ИмяТипа - Строка - Имя типа элемента данных XDTO.
//  Кодировка - Строка - Кодировка данных XML.
//
// Возвращаемое значение:
//  ОбъектXDTO - XDTO-объект.
//
Функция ОбъектXDTOИзДанныхXML(Знач ДанныеXML, Знач ПространствоИмен, Знач ИмяТипа, Знач Кодировка = "windows-1251") Экспорт
	
	ПотокЧтения = ДанныеXML.ОткрытьПотокДляЧтения();
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.ОткрытьПоток(ПотокЧтения, , , Кодировка);
	
	ТипЗначения = ФабрикаXDTO.Тип(ПространствоИмен, ИмяТипа);
	
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML, ТипЗначения);
	
	Возврат ОбъектXDTO;
	
КонецФункции

// Возвращает значение атрибута узла. Поиск узла выполняется до первого совпадения по имени.
// 
// Параметры:
//  ЧтениеXML - ЧтениеXML
//  ИмяУзла - Строка
//  ИмяАтрибута - Строка
// 
// Возвращаемое значение:
//  Строка, Неопределено - если атрибут найден, то метод возвращает строку, представляющую значение атрибута.
//  Если атрибут в соответствии с заданными параметрами не найден, то метод возвращает значение Неопределено.
Функция ЗначениеАтрибутаУзла(ЧтениеXML, ИмяУзла, ИмяАтрибута) Экспорт
	
	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.Имя = ИмяУзла Тогда
			Возврат ЧтениеXML.ЗначениеАтрибута(ИмяАтрибута);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область РегламентныеЗадания

// Получает представление расписания переданного регламентного задания
// 
// Параметры:
// 	РегЗадание - РегламентноеЗадание - объект регламентного задания. 
// Возвращаемое значение:
// 	Строка - представление расписания.
Функция ПредставлениеРасписанияРегламентногоЗадания(РегЗадание) Экспорт
	
	Расписание = РегЗадание.Расписание;
	Если Расписание = Неопределено Тогда
		Возврат НСтр("ru = 'Настроить расписание'")
	Иначе
		Возврат Строка(Расписание);
	КонецЕсли;
	
КонецФункции

// Ищет регламентное задание по имени задания в метаданных.
// 
// Параметры:
// 	ИмяЗадания - Строка - имя регламентного задания, как оно задано в метаданных.
// Возвращаемое значение:
// 	РегламентноеЗадание - объект регламентного задания.
// 	Неопределено - если задание не было найдено.
//
Функция РегламентноеЗаданиеПоНаименованию(ИмяЗадания) Экспорт
	
	Отбор = Новый Структура("Метаданные", ИмяЗадания);
	Найденные = РегламентныеЗаданияСервер.НайтиЗадания(Отбор);
	Задание = ?(Найденные.Количество() = 0, Неопределено, Найденные[0]);
	
	Возврат Задание;
	
КонецФункции

// Определяет, задано ли дневное расписание регламентного задания.
// 
// Параметры:
//  Задание - РегламентноеЗадание
// 
// Возвращаемое значение:
//  Булево
Функция ДневноеРасписаниеРегламентногоЗаданияЗадано(Задание) Экспорт
	
	Расписание = Задание.Расписание;
	
	Возврат ЗначениеЗаполнено(Расписание.ВремяЗавершения) Или ЗначениеЗаполнено(Расписание.ВремяКонца)
		Или ЗначениеЗаполнено(Расписание.ВремяНачала) Или ЗначениеЗаполнено(Расписание.ИнтервалЗавершения)
		Или ЗначениеЗаполнено(Расписание.ПаузаПовтора) Или ЗначениеЗаполнено(Расписание.ПериодПовтораВТечениеДня)
		Или ЗначениеЗаполнено(Расписание.ДетальныеРасписанияДня);
	
КонецФункции

#КонецОбласти

#Область Формы

// Сбрасывает размер и положение окна переданной формы.
// 
// Параметры:
// 	Форма - Форма - форма, положение и размер которой нужно сбросить.
Процедура СброситьРазмерыИПоложениеОкна(Форма) Экспорт
	
	ИмяПользователя = ПользователиИнформационнойБазы.ТекущийПользователь().Имя;
	
	УстановитьПривилегированныйРежим(Истина);
	ХранилищеСистемныхНастроек.Удалить(Форма.ИмяФормы, "", ИмяПользователя);
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.КлючСохраненияПоложенияОкна = Строка(Новый УникальныйИдентификатор);
	
КонецПроцедуры

// Перемещает элемент на форме.
//
// Параметры:
//  Элементы -  ВсеЭлементыФормы - содержит коллекцию всех элементов формы клиентского приложения для прямого доступа
//  	вне зависимости от иерархии.
//  Элемент - Строка - имя перемещаемого элемента
//  Родитель - Строка - имя нового элемента-родителя
//  		 - ФормаКлиентскогоПриложения - форма, если нужно переместить элемент в корень.
//  МестоРасположения - Строка - имя элемента, перед которым нужно разместить перемещаемый элемент.
//  	Если не задан, то перемещается в конец коллекции.
//
Процедура ПереместитьЭлемент(Элементы, Элемент, Родитель, МестоРасположения = Неопределено) Экспорт
	
	ЭлементСсылка = Элементы.Найти(Элемент);
	Если ТипЗнч(Родитель) = Тип("Строка") Тогда
		РодительСсылка = Элементы.Найти(Родитель);
	Иначе
		РодительСсылка = Родитель;
	КонецЕсли;
	
	Если МестоРасположения = Неопределено Тогда
		Если ЭлементСсылка <> Неопределено И РодительСсылка <> Неопределено Тогда
			Элементы.Переместить(ЭлементСсылка, РодительСсылка);
		КонецЕсли;
	Иначе
		МестоРасположенияСсылка = Элементы.Найти(МестоРасположения);
		Если ЭлементСсылка <> Неопределено И РодительСсылка <> Неопределено И МестоРасположенияСсылка <> Неопределено Тогда
			Элементы.Переместить(ЭлементСсылка, РодительСсылка, МестоРасположенияСсылка);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область РаботаСФормулами

// Вычисляет результат выполнения формулы.
// 
// Параметры:
// 	Формула - Строка - формула.
// 	ЗначенияОперандов - Соответствие - ключом является имя операнда, значением - его значение.
// 	ВерсияМеханикиРасчета - Строка - версия механики. Возможные значения: "1.0", "2.0".
// Возвращаемое значение:
// 	Строка - результата вычисления.
Функция РезультатВычисленияФормулы(Знач Формула, ЗначенияОперандов, ВерсияМеханикиРасчета = "1.0") Экспорт

	КоллекцияПриведенныхЗначенийОперандов = ОбщегоНазначенияБЭДСлужебный.КоллекцияПриведенныхЗначенийОперандов(ЗначенияОперандов, ВерсияМеханикиРасчета);

	ПараметрыФормулы = Новый Структура;
	ИдентификаторПараметра = 1;
	
	Для Каждого ЗначениеОперанда Из КоллекцияПриведенныхЗначенийОперандов Цикл
		
		ИмяПараметра = "Параметр" + ИдентификаторПараметра;
		ПараметрыФормулы.Вставить(ИмяПараметра, ЗначениеОперанда.Значение);

		Формула = СтрЗаменить(Формула, СтрШаблон("[%1]", ЗначениеОперанда.Ключ), "Параметры." + ИмяПараметра);
		
		ИдентификаторПараметра = ИдентификаторПараметра + 1;
		
	КонецЦикла;
	
	Возврат Строка(ОбщегоНазначения.ВычислитьВБезопасномРежиме(Формула, ПараметрыФормулы));

КонецФункции

// Проверяет корректность указанной формулы.
// 
// Параметры:
// 	Формула - Строка - формула.
// 	ДоступныеПоля - ДоступныеПоляКомпоновкиДанных - доступные поля отбора.
// 	ТекстОшибки - Строка - в этот параметр будет возвращен текст ошибки в случае ее возникновения. Выходной параметр.
// Возвращаемое значение:
// 	Булево - Истина, если формула корректна.
Функция ПроверитьФормулу(Формула, ДоступныеПоля, ТекстОшибки = "") Экспорт
	
	Результат = Истина;
	
	Если НЕ ЗначениеЗаполнено(Формула) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекстРасчета = """Строка"" + " + Формула;
	ЗначениеЗамены = """1""";
	
	Операнды = МассивОперандовФормулы(Формула);
	
	ЕстьНедоступныеПоля = Ложь;
	Для Каждого Операнд Из Операнды Цикл
		ТекстОперанда = СтрШаблон("[%1]", Операнд);
		ТекстРасчета = СтрЗаменить(ТекстРасчета, ТекстОперанда, ЗначениеЗамены);
		
		Если ДоступныеПоля.НайтиПоле(Новый ПолеКомпоновкиДанных(Операнд)) = Неопределено Тогда
			ЕстьНедоступныеПоля = Истина;
			Формула = СтрЗаменить(Формула, ТекстОперанда,
				СтрШаблон(НСтр("ru = '!""Поле не найдено: %1""'"), Операнд));
		КонецЕсли;
	КонецЦикла;
	
	Если ЕстьНедоступныеПоля Тогда
		Результат = Ложь;
		ТекстОшибки = НСтр("ru='Операндами должны быть реквизиты источника доступные для выбора.'");
	КонецЕсли;
	
	Попытка
		ОбщегоНазначения.ВычислитьВБезопасномРежиме(ТекстРасчета);
	Исключение
		Результат = Ложь;
		ТекстОшибки = НСтр("ru='Проверьте формулу. Формулы должны составляться по правилам написания выражений на встроенном языке 1С:Предприятия.'");
	КонецПопытки;
	
	ТекстПроверки = СтрЗаменить(Формула, Символы.ПС, "");
	ТекстПроверки = СтрЗаменить(ТекстПроверки, " ", "");
	ОтсутствиеРазделителей = СтрНайти(ТекстПроверки, "][")
		+ СтрНайти(ТекстПроверки, """[")
		+ СтрНайти(ТекстПроверки, "]""");
	Если ОтсутствиеРазделителей > 0 Тогда
		Результат = Ложь;
		ТекстОшибки = НСтр("ru='Между операндами должен присутствовать оператор или разделитель'");
	КонецЕсли;
	
	Если Не Результат Тогда
		ТекстОшибки = НСтр("ru='В формуле обнаружены ошибки.'") + " " + ТекстОшибки;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Получает из формулы набор операндов
// 
// Параметры:
// 	Формула - Строка - формула
// Возвращаемое значение:
// 	Массив Из Строка - набор операндов формулы.
Функция МассивОперандовФормулы(Знач Формула) Экспорт
	
	Операнды = Новый Массив;
	
	// Формула может содержать операнды с произвольным количеством вложенных квадратных скобок.
	
	// Сначала находим все скобки и запоминаем их позиции.
	ТаблицаСкобок = Новый ТаблицаЗначений;
	ТаблицаСкобок.Колонки.Добавить("Скобка",  Новый ОписаниеТипов("Строка"));
	ТаблицаСкобок.Колонки.Добавить("Позиция", Новый ОписаниеТипов("Число"));
	
	ПозицииОткрывающейСкобки = ОбщегоНазначенияБЭДСлужебный.ПозицииСимволаВСтроке("[", Формула);
	Для Каждого ПозицияСкобки Из ПозицииОткрывающейСкобки Цикл
		НоваяСтрока = ТаблицаСкобок.Добавить();
		НоваяСтрока.Скобка  = "[";
		НоваяСтрока.Позиция = ПозицияСкобки;
	КонецЦикла;
	
	ПозицииЗакрывающейСкобки = ОбщегоНазначенияБЭДСлужебный.ПозицииСимволаВСтроке("]", Формула);
	Для Каждого ПозицияСкобки Из ПозицииЗакрывающейСкобки Цикл
		НоваяСтрока = ТаблицаСкобок.Добавить();
		НоваяСтрока.Скобка  = "]";
		НоваяСтрока.Позиция = ПозицияСкобки;
	КонецЦикла;
	
	// В порядке следования позиций скобок обходим таблицу и запоминаем позиции, в которых количество
	// открывающих скобок становится равно количеству закрывающих. Это концы операндов.
	
	ТаблицаСкобок.Сортировать("Позиция");
	НачалоОперанда = 0;
	КоличествоОткрывающихСкобок = 0;
	КоличествоЗакрывающихСкобок = 0;
	
	Для Каждого СтрокаСкобки Из ТаблицаСкобок Цикл
		Если СтрокаСкобки.Скобка = "[" Тогда			
			Если Не ЗначениеЗаполнено(НачалоОперанда) Тогда
				НачалоОперанда = СтрокаСкобки.Позиция;
			КонецЕсли;
			
			КоличествоОткрывающихСкобок = КоличествоОткрывающихСкобок + 1;
		Иначе
			Если Не ЗначениеЗаполнено(НачалоОперанда) Тогда
				Продолжить; // начинать нужно обязательно с открывающей скобки
			КонецЕсли;
			КоличествоЗакрывающихСкобок = КоличествоЗакрывающихСкобок + 1;
		КонецЕсли;
		
		Если КоличествоОткрывающихСкобок = КоличествоЗакрывающихСкобок Тогда
			КонецОперанда = СтрокаСкобки.Позиция;
			
			Операнд = Сред(Формула, НачалоОперанда + 1, КонецОперанда - НачалоОперанда - 1);
			Если Операнды.Найти(Операнд) = Неопределено Тогда
				Операнды.Добавить(Операнд);
			КонецЕсли;
			
			НачалоОперанда = 0;
			КоличествоОткрывающихСкобок = 0;
			КоличествоЗакрывающихСкобок = 0;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Операнды;
	
КонецФункции

#КонецОбласти

#Область Прочее


// Проверяет, есть ли у текущего пользователя право администрирования.
// 
// Возвращаемое значение:
// 	Булево - Истина, если пользователь имеет право администрирования.
Функция ЕстьПравоАдминистрирования() Экспорт
	
	ПроверятьПраваАдминистрированияСистемы = Истина;
	Если ОбщегоНазначения.РазделениеВключено()
		И ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		ПроверятьПраваАдминистрированияСистемы = Ложь;
	КонецЕсли;
	
	Возврат Пользователи.ЭтоПолноправныйПользователь(, ПроверятьПраваАдминистрированияСистемы, Ложь);
	
КонецФункции

// Определяет, использует ли конфигурация несколько языков.
// 
// Возвращаемое значение:
//  Булево - Истина, если в конфигурации объявлено несколько языков.
//
Функция КонфигурацияИспользуетНесколькоЯзыков() Экспорт

	Возврат Метаданные.Языки.Количество() > 1;

КонецФункции

// Проверяет что в приложении используется версия БСП, в которой доступен механизм серверных оповещений.
// Использовать перед вызовом модуля СерверныеОповещения для поддержки совместимости с более ранними версиями БСП
// 
// Возвращаемое значение:
//  Булево
//
Функция ДоступныСерверныеОповещения() Экспорт
	ВерсияБСП = СтандартныеПодсистемыСервер.ВерсияБиблиотеки();
	Возврат ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБСП, "3.1.7.0") > 0;
КонецФункции

// Добавляет поле с типом NULL в динамический список.
// Такое поле можно будет заполнять сериализуемыми данными в обработчике списка ПриПолученииДанныхНаСервере
// 
// Параметры:
//  ДинамическийСписок - ДинамическийСписок
//  ИмяПоля - Строка
//
Процедура ДобавитьСлужебноеПолеВДинамическийСписок(ДинамическийСписок, ИмяПоля) Экспорт
	СвойстваДинамическогоСписка = ОбщегоНазначения.СтруктураСвойствДинамическогоСписка();
	ЗаполнитьЗначенияСвойств(СвойстваДинамическогоСписка, ДинамическийСписок); 
	Если ПустаяСтрока(СвойстваДинамическогоСписка.ТекстЗапроса) Тогда
		СвойстваДинамическогоСписка.ТекстЗапроса = ТекстЗапросаПоОсновойТаблице(
			ДинамическийСписок.ОсновнаяТаблица);
	КонецЕсли;
	СхемаЗапроса = Новый СхемаЗапроса;
	СхемаЗапроса.УстановитьТекстЗапроса(СвойстваДинамическогоСписка.ТекстЗапроса);
	Пакет = СхемаЗапроса.ПакетЗапросов.Получить(СхемаЗапроса.ПакетЗапросов.Количество() - 1);
	ПолеУжеЕстьВЗапросе = Пакет.Колонки.Найти(ИмяПоля) <> Неопределено;
	Если Не ПолеУжеЕстьВЗапросе Тогда
		Оператор = Пакет.Операторы.Получить(Пакет.Операторы.Количество() - 1);
		СлужебноеПоле = Оператор.ВыбираемыеПоля.Добавить("null");
		Пакет.Колонки.Найти(СлужебноеПоле).Псевдоним = ИмяПоля;
		ОбщегоНазначенияБЭДСлужебный.ОчиститьПсевдонимыВыраженийОтбораКомпоновкиДанных(СхемаЗапроса);
		СвойстваДинамическогоСписка.ТекстЗапроса = СхемаЗапроса.ПолучитьТекстЗапроса();
	КонецЕсли;
	// При изменении свойства ТекстЗапроса платформа сбрасывает значение ОсновнаяТаблица,
	// поэтому важно сохранить порядок изменения свойств динамического списка.
	// Здесь напрашивается использование метода ЗаполнитьЗначенияСвойств,
	// однако этот метод не может гарантировать порядок копирования свойств, поэтому и не используется
	ДинамическийСписок.ТекстЗапроса = СвойстваДинамическогоСписка.ТекстЗапроса;
	ДинамическийСписок.ОсновнаяТаблица = СвойстваДинамическогоСписка.ОсновнаяТаблица;
	ДинамическийСписок.ДинамическоеСчитываниеДанных = СвойстваДинамическогоСписка.ДинамическоеСчитываниеДанных;
	Если Не ПолеУжеЕстьВЗапросе Тогда
		ДинамическийСписок.УстановитьОбязательноеИспользование(ИмяПоля, Истина);
		ОграниченныеПоля = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ИмяПоля);
		ДинамическийСписок.УстановитьОграниченияИспользованияВГруппировке(ОграниченныеПоля);
		ДинамическийСписок.УстановитьОграниченияИспользованияВОтборе(ОграниченныеПоля);
		ДинамическийСписок.УстановитьОграниченияИспользованияВПорядке(ОграниченныеПоля);
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область Организации

// Возвращает организацию по умолчанию.
// 
// Возвращаемое значение:
//  Неопределено - не удалось определить организацию.
//  ОпределяемыеТипы.Организация - организация для автоматической подстановки.
//
Функция ОрганизацияПоУмолчанию() Экспорт
	
	Если Не Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(Тип("Строка")) Тогда
		ПолноеИмя = Метаданные.НайтиПоТипу(Метаданные.ОпределяемыеТипы.Организация.Тип.Типы()[0]).ПолноеИмя();
		ИмяСправочникаОрганизации = "Справочники." + СтрРазделить(ПолноеИмя, ".")[1];
		МодульОрганизации = ОбщегоНазначения.ОбщийМодуль(ИмяСправочникаОрганизации);
		ОрганизацияПоУмолчанию = МодульОрганизации.ОрганизацияПоУмолчанию();
	Иначе
		ОрганизацияПоУмолчанию = Неопределено;
	КонецЕсли;
	
	Возврат ОрганизацияПоУмолчанию;
	
КонецФункции

// Получает сокращенное наименование организации.
//
// Параметры:
//  Организация - ОпределяемыеТипы.Организация - ссылка на организацию.
//
// Возвращаемое значение:
//  Строка - сокращенное наименование организации.
//
Функция СокращенноеНаименованиеОрганизации(Организация) Экспорт
	
	РеквизитНаименованиеОрганизации = ЭлектронноеВзаимодействие.ИмяНаличиеОбъектаРеквизитаВПрикладномРешении(
		"СокращенноеНаименованиеОрганизации");
	Если НЕ ЗначениеЗаполнено(РеквизитНаименованиеОрганизации) Тогда
		РеквизитНаименованиеОрганизации = "Наименование";
	КонецЕсли;
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, РеквизитНаименованиеОрганизации);
	
КонецФункции

// Возвращает признак использования нескольких организаций.
//
// Возвращаемое значение:
//  Булево - Истина, если используется несколько организаций, иначе Ложь.
//
Функция ИспользуетсяНесколькоОрганизаций() Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийБЭД");
	
КонецФункции

#КонецОбласти

#Область РаботаСОбъектами

Функция ИмяПрикладногоСправочника(ИмяСправочника) Экспорт
	
	Возврат ОбщегоНазначенияБЭДПовтИсп.ИмяПрикладногоСправочника(ИмяСправочника);
	
КонецФункции

// Получает значение функциональной опции.
//
// Параметры:
//  НаименованиеФО - Строка - имя функциональной опции.
//
// Возвращаемое значение:
//  Булево - признак включенной ФО.
//
Функция ЗначениеФункциональнойОпции(НаименованиеФО) Экспорт
	
	СоответствиеФО = Новый Соответствие;
	
	ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьСоответствиеФункциональныхОпций(СоответствиеФО);
	
	// Электронные документы
	СоответствиеФО.Вставить("ИспользоватьОбменЭД",                    "ИспользоватьОбменЭД");
	СоответствиеФО.Вставить("ИспользоватьОбменЭДМеждуОрганизациями",  "ИспользоватьОбменЭДМеждуОрганизациями");
	СоответствиеФО.Вставить("ИспользоватьОбменСБанками",              "ИспользоватьОбменСБанками");
	СоответствиеФО.Вставить("ИспользоватьЭлектронныеПодписиЭД",       "ИспользоватьЭлектронныеПодписиЭД");
	СоответствиеФО.Вставить("ИспользоватьИнтеграциюСЯндексКассой",    "ИспользоватьИнтеграциюСЯндексКассой");
	СоответствиеФО.Вставить("ИспользоватьВнутренниеДокументыЭДО",     "ИспользоватьВнутренниеДокументыЭДО");
	СоответствиеФО.Вставить("ИспользоватьПрямойОбменЭлектроннымиДокументами",
		"ИспользоватьПрямойОбменЭлектроннымиДокументами");
	СоответствиеФО.Вставить("ИспользоватьВнутренниеДокументыЭДО",
		"ИспользоватьВнутренниеДокументыЭДО");
	
	ИмяФОПрикладногоРешения = СоответствиеФО.Получить(НаименованиеФО);
	Если ИмяФОПрикладногоРешения = Неопределено Тогда // не задано соответствие
		Результат = Ложь;
	Иначе
		Результат = ПолучитьФункциональнуюОпцию(ИмяФОПрикладногоРешения)
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает переданные реквизиты объекта или ссылки.
//
// Параметры:
//  Объект    - Объект, ЛюбаяСсылка - объект ссылочного типа или любая ссылка.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
// 
// Возвращаемое значение:
//  Структура - структура, в которой ключами являются имена реквизитов, а значениями - их значения.
//
Функция ЗначенияРеквизитовОбъектаИлиСсылки(Объект, Знач Реквизиты) Экспорт
	
	Если ОбщегоНазначения.ЗначениеСсылочногоТипа(Объект) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект, Реквизиты);
	Иначе
		// Передан объект - поэтому нужно составить структуру из реквизитов и прочитать в нее значения из объекта напрямую.
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
			Если ПустаяСтрока(Реквизиты) Тогда
				Возврат Новый Структура;
			КонецЕсли;
			Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		КонецЕсли;
		
		Результат = Новый Структура;
		Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
			Результат = Реквизиты;
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
			Для Каждого Реквизит Из Реквизиты Цикл
				Результат.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
			КонецЦикла;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(Результат, Объект);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Получает ссылку для объекта ИБ, в том числе нового.
//
// Параметры:
//  Объект	 - Объект - объект ссылочного типа.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка - ссылка на переданный объект.
//
Функция ПолучитьСсылкуОбъектаБезопасно(Объект) Экспорт

	Ссылка = Объект.Ссылка;
	Если Ссылка.Пустая() Тогда
		Ссылка = Объект.ПолучитьСсылкуНового();
		Если Ссылка.Пустая() Тогда
			Ссылка = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка).ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ссылка;

КонецФункции

// Возвращает ссылку по идентификатору и описанию типа.
//
// Параметры:
//  ИдентификаторСтрокой - Строка        - уникальный идентификатор ссылки строкой.
//  ОписаниеТипаСсылки   - ОписаниеТипов - описание типа ссылки.
//
// Возвращаемое значение:
//  Произвольный - найденная ссылка. Если не найдена, то Неопределено.
//
Функция НайтиСсылкуПоИдентификатору(Знач ИдентификаторСтрокой, Знач ОписаниеТипаСсылки) Экспорт
	
	Если Не СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ИдентификаторСтрокой) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Идентификатор = Новый УникальныйИдентификатор(ИдентификаторСтрокой);
	НаборТипов = ОписаниеТипаСсылки.Типы();
	
	Для Каждого ТипСсылки Из НаборТипов Цикл
		
		МетаданныеСсылки = Метаданные.НайтиПоТипу(ТипСсылки);
		Если МетаданныеСсылки = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеСсылки.ПолноеИмя());
		Ссылка = Менеджер.ПолучитьСсылку(Идентификатор);
		Если ОбщегоНазначения.СсылкаСуществует(Ссылка) Тогда
			Возврат Ссылка;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Поиск ссылки на объект информационной базы по типу, идентификатору и дополнительным реквизитам.
//
// Параметры:
//  ТипОбъекта - Строка	 - идентификатор типа объекта, который необходимо найти. Поддерживаемые типы:
//    - Контрагенты
//    - Организации
//    - Банки
//    - БанковскиеСчетаОрганизаций
//    - БанковскиеСчетаКонтрагентов
//    - Валюты
//    - ЕдиницыИзмерения
//    - ВидыКонтактнойИнформации
//    - Номенклатура
//    - Партнеры
//    - ДоговорыКонтрагентов
//  Идентификатор			 - Строка	 - идентификатор объекта заданного типа. Поддерживаемые идентификаторы в разрезе типов:
//    - Контрагенты: отсутствует
//    - Организации: отсутствует
//    - Банки: отсутствует
//    - БанковскиеСчетаОрганизаций: номер счета
//    - БанковскиеСчетаКонтрагентов: номер счета
//    - Валюты: код валюты
//    - ЕдиницыИзмерения: код единицы измерения
//    - ВидыКонтактнойИнформации: "EmailКонтрагента", "ТелефонКонтрагента", "ФаксКонтрагента", "EmailОрганизации", "ТелефонОрганизации", "ФаксОрганизации".
//    - Номенклатура: отсутствует
//    - Партнеры: отсутствуют
//    - ДоговорыКонтрагентов: отсутствует
//  ДополнительныеРеквизиты	 - Структура - набор дополнительных полей объекта для поиска. Поддерживаемые ключи в разрезе типов:
//    - Контрагенты: ИНН, КПП, Наименование
//    - Организации: ИНН, КПП, Наименование
//    - Банки: Код (БИК)
//    - БанковскиеСчетаОрганизаций: Владелец (организация)
//    - БанковскиеСчетаКонтрагентов: Владелец (контрагент)
//    - Валюты: отсутствуют
//    - ЕдиницыИзмерения: наименование единицы
//    - ВидыКонтактнойИнформации: отсутствуют
//    - Номенклатура: Идентификатор (идентификатор номенклатуры поставщика), Артикул
//    - Партнеры: Контрагент
//    - ДоговорыКонтрагентов: НомерДоговора, ДатаДоговора, Организация, Владелец (контрагент)
// Возвращаемое значение:
//  Ссылка - ссылка на найденный объект.
//
Функция НайтиСсылку(ТипОбъекта, Идентификатор = "", ДополнительныеРеквизиты = Неопределено) Экспорт
	
	Возврат ОбщегоНазначенияБЭДПовтИсп.НайтиСсылку(ТипОбъекта, Идентификатор, ДополнительныеРеквизиты);
	
КонецФункции

// Получает объект по ссылке для дальнейшего изменения. 
// Устанавливает управляемую и пессимистическую блокировку.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, объект которой нужно получить.
//
// Возвращаемое значение:
//  Объект,Неопределено - объект по ссылке. Неопределено, если объект отсутствует.
//
Функция ОбъектПоСсылкеДляИзменения(Знач Ссылка) Экспорт
	
	УстановитьУправляемуюБлокировкуПоСсылке(Ссылка);
	Объект = Ссылка.ПолучитьОбъект();
	
	Возврат Объект;
	
КонецФункции

// Определяет, находится ли объект в режиме группового перепроведения.
// 
// Параметры:
// 	Источник - Объект - объект ссылочного типа.
// Возвращаемое значение:
// 	Булево - Истина, если объект находится в режиме группового перепроведения.
Функция ОбъектВРежимеГрупповогоПерепроведения(Источник) Экспорт
	
	ГрупповоеПерепроведение = Неопределено;
	Если Источник.ДополнительныеСвойства.Свойство("ГрупповоеПерепроведение", ГрупповоеПерепроведение) Тогда
		Возврат ГрупповоеПерепроведение;
	КонецЕсли;
	
	Возврат Ложь;

КонецФункции

// Возвращает признак того, что объект является документом, поддерживающим проведение.
//
// Параметры:
//  Объект - Произвольный - объект, который нужно проверить.
//
// Возвращаемое значение:
//  Булево - Истина, если объект является документом с проведением. Иначе Ложь.
//
Функция ЭтоПроводимыйДокумент(Объект) Экспорт
	
	Попытка
		МетаданныеОбъекта = Объект.Метаданные();
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Результат = Ложь;
	
	Если Метаданные.Документы.Содержит(МетаданныеОбъекта) Тогда
		Если МетаданныеОбъекта.Проведение = Метаданные.СвойстваОбъектов.Проведение.Разрешить Тогда
			Результат = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Выбирает из массива документов те, которые могут быть проведены.
//
// Параметры:
//  МассивДокументов - Массив Из ДокументСсылка - массив ссылок на документы.
//
// Возвращаемое значение:
//  Массив Из ДокументСсылка - массив документов, которые можно проводить.
//
Функция МассивПроводимыхДокументов(МассивДокументов) Экспорт
	
	МассивПроводныхДокументов = Новый Массив;
	МассивТиповНеПроводныхДокументов = Новый Массив;
	Для каждого Элемент Из МассивДокументов Цикл
		ИмяДокумента = Элемент.Метаданные().ПолноеИмя();
		Если Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда
			
			Если Элемент.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Запретить Тогда
				Если МассивТиповНеПроводныхДокументов.Найти(ТипЗнч(Элемент)) = Неопределено Тогда
					МассивТиповНеПроводныхДокументов.Добавить(ТипЗнч(Элемент));
				КонецЕсли;
			КонецЕсли;
			
			МассивПроводныхДокументов.Добавить(Элемент)
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТипНеПроводногоДокумента Из МассивТиповНеПроводныхДокументов Цикл
		ОбщегоНазначенияКлиентСервер.УдалитьВсеВхожденияТипаИзМассива(МассивПроводныхДокументов, ТипНеПроводногоДокумента);
	КонецЦикла;
	
	Возврат МассивПроводныхДокументов;
	
КонецФункции

// Получает данные о юридическом (физическом) лице по ссылке.
//
// Возвращаемое значение:
//  Структура - см. ЭлектронноеВзаимодействие.СтруктураДанныхЮрФизЛица
//
Функция ДанныеЮрФизЛица(ЮрФизЛицо) Экспорт
	
	Сведения = ЭлектронноеВзаимодействие.СтруктураДанныхЮрФизЛица();
	
	Если НЕ ЗначениеЗаполнено(ЮрФизЛицо) Тогда
		Возврат Сведения;
	КонецЕсли;
	
	ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьДанныеЮрФизЛица(ЮрФизЛицо, Сведения);
	
	Возврат Сведения;
	
КонецФункции

#КонецОбласти

#Область РаботаСМетаданными

// Возвращает имена таблиц типа, указанного в определяемом типе.
// 
// Параметры:
// 	ИмяОпределяемогоТипа - Строка - имя определяемого типа.
// Возвращаемое значение:
// 	Массив из Строка - полные имена таблиц типа.
Функция ИменаТаблицОпределяемогоТипа(ИмяОпределяемогоТипа) Экспорт
	
	ИменаТаблиц = Новый Массив;
	Для Каждого Тип Из Метаданные.ОпределяемыеТипы[ИмяОпределяемогоТипа].Тип.Типы() Цикл
		Если ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			ИменаТаблиц.Добавить(ОбщегоНазначения.ИмяТаблицыПоСсылке(Новый(Тип)));
		КонецЕсли;
	КонецЦикла;

	Возврат ИменаТаблиц;
	
КонецФункции

// Безопасно ищет предопределенный элемент объекта по имени.
// 
// Параметры:
// 	ПолноеИмяМетаданного - Строка - см. Метаданные.ПолноеИмя().
// 	ИмяЭлемента - Строка - имя предопределенного элемента.
// Возвращаемое значение:
// 	ЛюбаяСсылка - ссылка на найденный предопределенный элемент. Если элемент не найден, возвращается пустая ссылка.
Функция ПредопределенныйЭлемент(ПолноеИмяМетаданного, ИмяЭлемента) Экспорт
	
	Результат = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяМетаданного).ПустаяСсылка();
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрШаблон(
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	ОбъектПоиска.Ссылка
	|ИЗ
	|	%1 КАК ОбъектПоиска
	|ГДЕ
	|	ОбъектПоиска.ИмяПредопределенныхДанных = &ИмяПредопределенныхДанных", ПолноеИмяМетаданного);
	Запрос.УстановитьПараметр("ИмяПредопределенныхДанных", ИмяЭлемента);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Результат = Выборка.Ссылка;	
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Определяет, может ли иметь справочник группы.
// 
// Параметры:
// 	МетаданныеСправочника - ОбъектМетаданных: Справочник - объект метаданных
//  
// Возвращаемое значение:
// 	Булево - Истина, если справочник имеет иерархию групп.
Функция СправочникИспользуетГруппы(МетаданныеСправочника) Экспорт

	Возврат МетаданныеСправочника.Иерархический
		И МетаданныеСправочника.ВидИерархии
		= Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;
	
КонецФункции

#КонецОбласти

#Область РаботаСОшибками

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			         - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                      Состав структур см. в ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки().
//  ТекстОшибки				 - Строка - текст фиксируемой ошибки.
//  ПараметрыОбработкиОшибок - Структура - используется для указания указания параметров действий по клику на ошибке,
//                                         формируется функцией ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки.
//  ИндексВставки			 - Число - индекс позиции вставки в массиве ошибок.
//
Процедура ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки = Неопределено, ИндексВставки = Неопределено) Экспорт

	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Массив;
	КонецЕсли;
	
	ДанныеОшибки = ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки();
	
	Если ПараметрыОбработкиОшибки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ДанныеОшибки, ПараметрыОбработкиОшибки);
	КонецЕсли;
	
	// Выводим указанный текст ошибки, только если он не был переопределен в параметрах обработки ошибки.
	Если Не ЗначениеЗаполнено(ДанныеОшибки.ТекстОшибки) Тогда
		ДанныеОшибки.Вставить("ТекстОшибки", ТекстОшибки);
	КонецЕсли;
	
	Если ИндексВставки = Неопределено Тогда
		Ошибки.Добавить(ДанныеОшибки);
	Иначе
		Ошибки.Вставить(ИндексВставки, ДанныеОшибки);
	КонецЕсли;

КонецПроцедуры

Функция СформироватьТекстИсключения(Знач ТипИсключения, Знач Параметр) Экспорт
	
	ЧастиТекста = Новый Массив;
	Если ТипИсключения = "НедопустимыеПараметрыМетода" Тогда
		
		ЧастиТекста.Добавить(НСтр("ru = 'Недопустимые параметры метода'"));
		ЧастиТекста.Добавить(Параметр);
		
	Иначе
		
		ЧастиТекста.Добавить(НСтр("ru = 'Неизвестная ошибка'"));
		Если ЗначениеЗаполнено(Параметр) Тогда
			ЧастиТекста.Добавить(Параметр);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтрСоединить(ЧастиТекста, Символы.ПС);
	
КонецФункции

// Преобразует массив ошибок в строку.
//
// Параметры:
//  Ошибки - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                    Состав структур см. в ОбщегоНазначенияБЭДКлиентСервер.НовыеПараметрыОшибки().
// 
// Возвращаемое значение:
//  Строка - единая строка сообщения об ошибке.
//
Функция СоединитьОшибки(Ошибки) Экспорт

	МассивОшибок = Новый Массив;
	
	Если ЗначениеЗаполнено(Ошибки) Тогда
		Для Каждого ОписаниеОшибки Из Ошибки Цикл
			МассивОшибок.Добавить(ОписаниеОшибки.ТекстОшибки);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтрСоединить(МассивОшибок, Символы.ПС);

КонецФункции 

#КонецОбласти

#Область АвтоматизированноеТестирование

// Выводит область ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Вывести.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Вывести.
//  Открыта				 - Булево - см. ТабличныйДокумент.Вывести.
//
Процедура ВывестиОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ОбщегоНазначенияБЭДСлужебный.ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Вывести(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Присоединяет область ячеек к табличному документу, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Присоединить.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Присоединить.
//  Открыта				 - Булево - см. ТабличныйДокумент.Присоединить.
//
Процедура ПрисоединитьОбластьКТабличномуДокументу(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ОбщегоНазначенияБЭДСлужебный.ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Присоединить(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Производит вставку области ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ИсходнаяОбласть		 - ТабличныйДокумент - табличный документ для вставки.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  ОбластьПриемник		 - ОбластьЯчеекТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  Сдвиг			     - ТипСмещенияТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  ЗаполнятьПараметры	 - Булево - см. ТабличныйДокумент.ВставитьОбласть.
//
Процедура ВставитьОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ИсходнаяОбласть, Знач ПрефиксДляИмен,
	Знач ИндексПрефикса = "", Знач ОбластьПриемник = Неопределено, Сдвиг = Неопределено, ЗаполнятьПараметры = Истина) Экспорт

	ОбщегоНазначенияБЭДСлужебный.ПрисвоитьИменаЯчейкамТабличногоДокумента(ИсходнаяОбласть, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.ВставитьОбласть(ИсходнаяОбласть.Область(), ОбластьПриемник, Сдвиг, ЗаполнятьПараметры);

КонецПроцедуры

#КонецОбласти

#Область КартинкиСУчетомСовместимостиВерсий

Функция КартинкаКнопкиОткрытия() Экспорт
	
	ВерсияРежимаСовместимости = СтандартныеПодсистемыСервер.ВерсияРежимаСовместимости();
	
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияРежимаСовместимости, "8.3.17.0") >= 0 Тогда
		Возврат БиблиотекаКартинок["ПолеВводаОткрыть"];
	КонецЕсли;
	
	Возврат БиблиотекаКартинок["Лупа"];
	
КонецФункции

Функция КартинкаКнопкиОчистки() Экспорт
	
	ВерсияРежимаСовместимости = СтандартныеПодсистемыСервер.ВерсияРежимаСовместимости();
	
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияРежимаСовместимости, "8.3.17.0") >= 0 Тогда
		Возврат БиблиотекаКартинок["ПолеВводаОчистить"];
	КонецЕсли;
	
	Возврат БиблиотекаКартинок["Очистить"];
	
КонецФункции

#КонецОбласти

//-- Локализация

#КонецОбласти

//++ Локализация

#Область СлужебныеПроцедурыИФункции

// Формирует текст запроса по основной таблице динамического списка.
// 
// Параметры:
//  ОсновнаяТаблица - Строка
// 
// Возвращаемое значение:
//  Строка
//
Функция ТекстЗапросаПоОсновойТаблице(ОсновнаяТаблица)
	ШаблонЗапроса = "ВЫБРАТЬ * ИЗ &ОсновнаяТаблица";
	Возврат СтрЗаменить(ШаблонЗапроса, "&ОсновнаяТаблица", ОсновнаяТаблица);
КонецФункции

#КонецОбласти

//-- Локализация