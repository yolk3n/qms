
#Область СлужебныйПрограммныйИнтерфейс

#Область ПрисоединенныеФайлы

// Возвращает двоичные данные присоединенных файлов.
// 
// Параметры:
// 	ПрисоединенныеФайлы - Массив из ОпределяемыйТип.ПрисоединенныйФайл
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// Возвращаемое значение:
// 	Соответствие из КлючИЗначение:
// 	  * Ключ - ОпределяемыйТип.ПрисоединенныйФайл
// 	  * Значение - ДвоичныеДанные
Функция ДвоичныеДанныеФайлов(ПрисоединенныеФайлы, КонтекстДиагностики = Неопределено) Экспорт
	// Используется служебный ПИ, у БСП запрошен аналог РаботаСФайлами.ДвоичныеДанныеФайла для
	// массива присоединенных файлов.
	
	Результат = Новый Соответствие;
	
	Если Не ЗначениеЗаполнено(ПрисоединенныеФайлы) Тогда
		Возврат Результат;
	КонецЕсли;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПрисоединенныеФайлы.Ссылка КАК Ссылка,
		|	ПрисоединенныеФайлы.Наименование КАК Наименование,
		|	ПрисоединенныеФайлы.Том КАК Том,
		|	ПрисоединенныеФайлы.ПутьКФайлу КАК ПутьКФайлу,
		|	ПрисоединенныеФайлы.ВладелецФайла КАК ВладелецФайла,
		|	ПрисоединенныеФайлы.Расширение КАК Расширение,
		|	"""" КАК НомерВерсии,
		|	ПрисоединенныеФайлы.ТипХраненияФайла КАК ТипХраненияФайла,
		|	ЕСТЬNULL(ДвоичныеДанныеФайлов.ДвоичныеДанныеФайла, НЕОПРЕДЕЛЕНО) КАК ДвоичныеДанныеФайла
		|ИЗ
		|	&ИмяТаблицыПрисоединенныхФайлов КАК ПрисоединенныеФайлы
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ДвоичныеДанныеФайлов КАК ДвоичныеДанныеФайлов
		|		ПО ПрисоединенныеФайлы.Ссылка = ДвоичныеДанныеФайлов.Файл
		|ГДЕ
		|	ПрисоединенныеФайлы.Ссылка В (&ПрисоединенныеФайлы)";
	
	ИмяТаблицыПрисоединенныхФайлов = ОбщегоНазначения.ИмяТаблицыПоСсылке(ПрисоединенныеФайлы[0]);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицыПрисоединенныхФайлов", ИмяТаблицыПрисоединенныхФайлов);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ПрисоединенныеФайлы", ПрисоединенныеФайлы);
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	Пока Выборка.Следующий() Цикл
		
		Если Выборка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ДвоичныеДанные = ДанныеФайлаИзХранилищаЗначений(Выборка, КонтекстДиагностики);
		Иначе
			ДвоичныеДанные = ДанныеФайлаВТомеНаДиске(Выборка, КонтекстДиагностики);
		КонецЕсли;
		
		Если ДвоичныеДанные <> Неопределено Тогда
			Результат.Вставить(Выборка.Ссылка, ДвоичныеДанные);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ФайловаяСистема

// Получение строки в формате Base64 по двоичным данным.
//
// Параметры:
//  Данные - ДвоичныеДанные - Данные, которые необходимо преобразовать в формат Base64.
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в формате Base64.
//
Функция Base64СтрокаИзДвоичныхДанных(Знач Данные) Экспорт
	
	Результат = "";
	
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Результат = ПолучитьBase64СтрокуИзДвоичныхДанных(Данные);
		Результат = СтрЗаменить(Результат, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ВК, "");
		Результат = СтрЗаменить(Результат, " ", "");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает временный рабочий каталог.
// Каталог создается в каталоге временных файлов системы или ином предопределенном каталоге.
//
// Возвращаемое значение:
//  Строка - временный каталог.
//
Функция ВременныйКаталог() Экспорт
	
	ИмяКаталога = ПолучитьИмяВременногоФайла() + ПолучитьРазделительПути();
	СоздатьКаталог(ИмяКаталога);
	Возврат ИмяКаталога;
	
КонецФункции

// Возвращает имя временного файла.
//
// Параметры:
//  Расширение - Строка - расширение файла
// 
// Возвращаемое значение:
//  Строка
Функция ТекущееИмяВременногоФайла(Расширение = "") Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Расширение);
	
	Возврат ИмяВременногоФайла;
	
КонецФункции

// Удаляет временные файлы или каталог.
//
// Параметры:
//  Путь - Строка - полный путь к файлу или каталогу
//  Маска - Строка - маска для выбора удаляемых файлов,
//        - Неопределено - удаляются все файлы и каталог <Путь>.
//
Процедура УдалитьВременныеФайлы(Путь, Маска = Неопределено) Экспорт
	
	Попытка
		УдалитьФайлы(Путь, Маска);
	Исключение
		ВидОперации = НСтр("ru = 'Удаление временного файла.'");
		ПодробныйТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ОбработкаНеисправностейБЭД.ОбработатьОшибку(ВидОперации, ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().ЭлектронноеВзаимодействие, ПодробныйТекстОшибки);
	КонецПопытки;
	
КонецПроцедуры

// Производит попытку создать файл по переданному пути. Если путь не передан, получает имя временного 
// файла самостоятельно.
// 
// Параметры:
// 	ИмяФайла - Строка
// Возвращаемое значение:
// 	Строка - имя созданного файла
Функция СоздатьТестовыйФайл(ИмяФайла = "") Экспорт
	
	Если ИмяФайла = "" Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла("tmp");
	КонецЕсли;
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла);
	ЗаписьТекста.ЗаписатьСтроку(ИмяФайла);
	ЗаписьТекста.Закрыть();
		
	Возврат ИмяФайла;
	
КонецФункции

// Формирует zip архив. Если параметр ИмяФайла заполнен записывает архив по указанному пути.
// 
// Параметры:
// 	МассивФайлов - Массив из Строка - полные имена файлов (или маски), которые необходимо поместить в архив.
// 	ИмяФайла - Строка - имя файла для записи сформированного архива, если не задан, функция возвращает двоичные данные
// 	ПараметрыФормирования - см. НовыеПараметрыФормированияАрхива
// Возвращаемое значение:
// 	- Строка - имя файла сформированного архива
// 	- ДвоичныеДанные - сформированный архив в виде двоичных данных
// 	- Неопределено - архив не удалось сформировать
Функция СформироватьАрхивФайлов(МассивФайлов, ИмяФайла = Неопределено, ПараметрыФормирования = Неопределено) Экспорт
	
	Если ПараметрыФормирования = Неопределено Тогда
		ПараметрыФормирования = НовыеПараметрыФормированияАрхива();
	КонецЕсли;
	ЗаписьВФайл = ИмяФайла <> Неопределено;
	Попытка
		Если ЗаписьВФайл Тогда
			ЗаписьАрхива = Новый ЗаписьZIPФайла(ИмяФайла);
		Иначе
			ЗаписьАрхива = Новый ЗаписьZIPФайла();
		КонецЕсли;
		
		Для Каждого ИмяДобавляемогоФайла Из МассивФайлов Цикл
			ЗаписьАрхива.Добавить(ИмяДобавляемогоФайла, ПараметрыФормирования.РежимСохраненияПутей,
				ПараметрыФормирования.РежимОбработкиПодкаталогов);
		КонецЦикла;
		Если ЗаписьВФайл Тогда
			ЗаписьАрхива.Записать();
			Возврат ИмяФайла;
		Иначе
			Возврат ЗаписьАрхива.ПолучитьДвоичныеДанные();
		КонецЕсли;
	Исключение
		ТекстСообщения = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) + Символы.ПС
			+ НСтр("ru = 'Проверьте поддержку русского языка в региональных настройках ОС для non-Unicode programs
			|и наличие доступа к каталогу временных файлов.'");
		ЭлектронноеВзаимодействие.ОбработатьОшибку(НСтр("ru = 'запись файла архива на диск'"),
																					ТекстОшибки,
																					ТекстСообщения);
		
		Возврат ?(ЗаписьВФайл, "", Неопределено);
		
	КонецПопытки;
	
КонецФункции

// Возвращает параметры формирования архива, см. СформироватьАрхивФайлов.
// 
// Возвращаемое значение:
// 	Структура:
// * РежимОбработкиПодкаталогов - РежимСохраненияПутейZIP
// * РежимСохраненияПутей - РежимОбработкиПодкаталоговZIP
Функция НовыеПараметрыФормированияАрхива() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("РежимСохраненияПутей", РежимСохраненияПутейZIP.НеСохранятьПути);
	Параметры.Вставить("РежимОбработкиПодкаталогов", РежимОбработкиПодкаталоговZIP.НеОбрабатывать);
	
	Возврат Параметры;
	
КонецФункции

// Возвращает уникальный идентификатор для использования в качестве части имени файла.
// 
// Возвращаемое значение:
// 	Строка
Функция НовыйUUID() Экспорт
	
	Возврат НРег(СтрЗаменить(Строка(Новый("УникальныйИдентификатор")), "-", ""));
	
КонецФункции

// Записывает текст в файл.
// 
// Параметры:
// 	Текст - Строка
// 	ИмяФайла - Строка
// 	Кодировка - Строка, КодировкаТекста -
Процедура ЗаписатьТекстВФайл(Текст, ИмяФайла, Кодировка = Неопределено) Экспорт
	
	Если Кодировка = Неопределено Тогда
		ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла);
	Иначе
		ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, Кодировка);
	КонецЕсли;
	ЗаписьТекста.Записать(Текст);
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

// Записывает двоичные данные в файл и возвращает результат.
// 
// Параметры:
// 	ДвоичныеДанные - ДвоичныеДанные
// 	ИмяФайла - Строка
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// Возвращаемое значение:
// 	Булево - двоичные данные записаны в файл
Функция ЗаписатьДвоичныеДанные(ДвоичныеДанные, ИмяФайла, КонтекстДиагностики) Экспорт
	
	Если Не ДлинаФайлаДопустима(ИмяФайла, КонтекстДиагностики) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДвоичныеДанные.Записать(ИмяФайла);
	
	Возврат Истина;
	
КонецФункции

// Возвращает пустую структуру описания файла.
// 
// Возвращаемое значение:
//  См. РаботаСФайламиБЭДКлиентСервер.НовоеОписаниеФайла
//
Функция НовоеОписаниеФайла() Экспорт
	
	Возврат РаботаСФайламиБЭДКлиентСервер.НовоеОписаниеФайла();
		
КонецФункции

// Возвращает данные файла.
//
// Параметры:
// 	Файл - Файл, Строка - Файл или полное имя файла.
//
// Возвращаемое значение:
// 	Структура - Данные файла:
// 	 * ИмяФайла - Строка - Имя файла.
//   * ИмяБезРасширения - Строка - Имя файла без расширения.
//   * Расширение - Строка - Расширение файла.
//   * Размер - Число - Размер файла в байтах.
//
Функция ДанныеФайла(Знач Файл) Экспорт
	
	Если ТипЗнч(Файл) = Тип("Строка") Тогда
		Файл = Новый Файл(Файл);
	КонецЕсли;
	
	ДанныеФайла = Новый Структура;
	ДанныеФайла.Вставить("ИмяФайла", Файл.Имя);
	ДанныеФайла.Вставить("ИмяБезРасширения", Файл.ИмяБезРасширения);
	ДанныеФайла.Вставить("Расширение", Сред(Файл.Расширение, 2));
	ДанныеФайла.Вставить("Размер", Файл.Размер());
	
	Возврат ДанныеФайла;
	
КонецФункции

#КонецОбласти

#Область Архивы

// Определяет возможно ли без ошибки извлечь файлы из архива.
// Проверяется максимальная длина полного имени файла в 255 символов.
// 
// Параметры:
//  АрхивЧтение - ЧтениеZIPФайла - открытый zip архив.
//  КаталогРаспаковки - Строка - папка, в которую будут извлечены данные.
//
// Возвращаемое значение:
//  Булево - если возможно то Истина, иначе Ложь.
//
Функция ВозможноИзвлечьФайлы(АрхивЧтение, КаталогРаспаковки) Экспорт
	
	ДлинаПутиПапки = СтрДлина(КаталогРаспаковки);
	
	Для Каждого Элемент Из АрхивЧтение.Элементы Цикл
		ИмяФайла = Элемент.ПолноеИмя;
		ДлинаИмениФайла = СтрДлина(ИмяФайла);
		ПолнаяДлина = ДлинаПутиПапки + ДлинаИмениФайла + 1;
		// Для некоторых файловых систем ограничение длины имени измеряется не в символах, а в байтах.
		// При этом:
		// 1. Кодирование символа может занимать от 1 до 4х байт в зависимости от кодировки.
		// 2. Излишне усложнять алгоритм, вычисляя точное количество байт в имени файла, в данном случае нецелесообразно.
		// 3. Для подавляющего большинства случаев в среднем 2х байт на 1 символ будет достаточно.
		// Поэтому максимальная длина в символах делится на условные 2 байта на символ.
		Если ПолнаяДлина > МаксимальнаяДлинаИмениФайла()/2 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Извлекает файлы из архива.
// 
// Параметры:
// 	Архив - ДвоичныеДанные
// 	КаталогРаспаковки - Строка
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// 	                    - Неопределено - контекст диагностики не используется, ошибка будет выведена в сообщении.
// 	ВидОперации - Строка - операция, в рамках которой происходит распаковка
// 	ПараметрыРаспаковки - см. НовыеПараметрыРаспаковкиАрхива
// 	ДополнительныеСвойстваОшибки - Произвольный - дополнительные свойства, которые будут присвоены ошибке, возникшей
// 	                                              при распаковке.
// Возвращаемое значение:
// 	- Массив из Файл - распакованные файлы
// 	- Неопределено - если архив распаковать не удалось
Функция РаспаковатьАрхив(Архив, КаталогРаспаковки, КонтекстДиагностики, ВидОперации = "",
	ПараметрыРаспаковки = Неопределено, ДополнительныеСвойстваОшибки = Неопределено) Экспорт
	
	ЕстьОшибка = Ложь;
	ДополнительныеПараметрыОшибки = Новый Структура;
	ДополнительныеПараметрыОшибки.Вставить("ДополнительныеДанные", ДополнительныеСвойстваОшибки);
		
	Если ПараметрыРаспаковки = Неопределено Тогда
		ПараметрыРаспаковки = НовыеПараметрыРаспаковкиАрхива();
	КонецЕсли;
	Если ВидОперации = "" Тогда
		ВидОперации = НСтр("ru = 'Распаковка zip-архива'");
	КонецЕсли;
	
	Поток = Новый ПотокВПамяти;
	Архив.Записать(Поток);
	ЧтениеZip = Новый ЧтениеZipФайла(Поток);
	
	Если ЕстьОдинаковыеИменаФайловСНедопустимымиСимволамиВАрхиве(ЧтениеZip) Тогда
		ЕстьОшибка = Истина;
		ТекстОшибки = НСтр("ru = 'Архив содержит файлы с недопустимыми символами. Распаковка невозможна.'");
		
		ВидОшибки = ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка();
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
			ВидОшибки, ТекстОшибки, ТекстОшибки, ДополнительныеПараметрыОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().ОбменСКонтрагентами);
	КонецЕсли;
	
	Если Не ЕстьОшибка Тогда
		Попытка
			ЧтениеZip.ИзвлечьВсе(КаталогРаспаковки, ПараметрыРаспаковки.ВосстанавливатьКаталоги);
		Исключение
			ЕстьОшибка = Истина;
			ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			ТекстСообщения = НСтр("ru = 'Невозможно распаковать zip-архив.'");
			
			ВидОшибки = ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка();
			Если ЧтениеZip <> Неопределено Тогда
				Если Не ВозможноИзвлечьФайлы(ЧтениеZip, КаталогРаспаковки) Тогда
					Если ТипЗнч(ДополнительныеСвойстваОшибки) = Тип("Структура")
						И ДополнительныеСвойстваОшибки.Свойство("ТекстСообщения") Тогда
						ТекстСообщения = ТекстСообщения + Символы.ПС + НСтр("ru = 'Имя файла превысило максимально допустимую длину.'");
						ТекстСообщения = ТекстСообщения + Символы.ПС + ДополнительныеСвойстваОшибки.ТекстСообщения;
					Иначе 
						ТекстСообщения = ОбработкаНеисправностейБЭД.ПолучитьСообщениеОбОшибкеДругойСистемы("006");
					КонецЕсли;
					ВидОшибки = РаботаСФайламиБЭДКлиентСервер.ВидОшибкиРаботаСФайлами();
				КонецЕсли;
			КонецЕсли;
		
			Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации, ВидОшибки, ТекстОшибки, ТекстСообщения,
				ДополнительныеПараметрыОшибки);
			ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
				ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		КонецПопытки;
	КонецЕсли;
	
	Если ЧтениеZip <> Неопределено Тогда
		ЧтениеZip.Закрыть();
	КонецЕсли;
	Если Поток <> Неопределено Тогда
		Поток.Закрыть();
	КонецЕсли;
	
	Если ЕстьОшибка Тогда
		Возврат Неопределено;
	Иначе
		Возврат НайтиФайлы(КаталогРаспаковки, ПолучитьМаскуВсеФайлы(), Истина);
	КонецЕсли;
	
КонецФункции

// Возвращает параметры распаковки архива, см. РаспаковатьАрхив.
// 
// Возвращаемое значение:
// 	Структура:
// * ВосстанавливатьКаталоги - РежимВосстановленияПутейФайловZIP
Функция НовыеПараметрыРаспаковкиАрхива() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВосстанавливатьКаталоги", РежимВосстановленияПутейФайловZIP.Восстанавливать);
	
	Возврат Параметры;
	
КонецФункции

#КонецОбласти

#Область XDTO

// Сохраняет объект XDTO в файл.
//
// Параметры:
//  XDTO - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  ИмяФайла - Строка - путь к файлу, в который сохраняются данные;
//  УказаниеТипа - НазначениеТипаXML - вариант назначения типа элемента данных XDTO.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//
Процедура СохранитьXDTO(XDTO, ИмяФайла, УказаниеТипа = Истина, ТипКодировки = "windows-1251") Экспорт
	
	НоваяЗаписьXML = Новый ЗаписьXML;
	НоваяЗаписьXML.ОткрытьФайл(ИмяФайла, ТипКодировки);
	НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(НоваяЗаписьXML, XDTO, , , , ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));
	НоваяЗаписьXML.Закрыть();
	
КонецПроцедуры

// Возвращает результат чтения XML.
// 
// Параметры:
// 	Данные - Поток - поток для чтения.
// 	       - Строка - имя файла.
// 	ТипЗначения - ТипЗначенияXDTO
// Возвращаемое значение:
// 	ОбъектXDTO
Функция ПрочитатьXDTO(Данные, ТипЗначения = Неопределено) Экспорт
	
	ОбъектXML = Новый ЧтениеXML;
	Если ТипЗнч(Данные) = Тип("Поток") Тогда
		ОбъектXML.ОткрытьПоток(Данные);
	Иначе
		ОбъектXML.ОткрытьФайл(Данные);
	КонецЕсли;
	РезультатЧтения = ФабрикаXDTO.ПрочитатьXML(ОбъектXML, ТипЗначения);
	ОбъектXML.Закрыть();
	
	Возврат РезультатЧтения;
	
КонецФункции

// Возвращает значение свойства XDTO.
// 
// Параметры:
// 	ОбъектXDTO - ОбъектXDTO
// 	ИмяСвойства - Строка
// 	ЗначениеПоУмолчанию - Произвольный - значение, которое будет возвращено, в случае отсутствия значения
// 	Тип - Строка - тип, к которому будет приведено возвращаемое значение
// 	ЭтоСписок - Булево
// 	НеопределеноПоУмолчанию - Булево - не приводить к значению по умолчанию типа, указанного в параметре Тип.
// 	                          В случае отсутствия значения, будет возвращено Неопределено.
// Возвращаемое значение:
// 	Произвольный
Функция ЗначениеСвойстваXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеПоУмолчанию = Неопределено, Тип = Неопределено,
	ЭтоСписок = Ложь, НеопределеноПоУмолчанию = Ложь) Экспорт
	
	Значение = РаботаСФайламиБЭДСлужебный.ЗначениеСвойстваXDTO(ОбъектXDTO, ИмяСвойства);
	
	Если Тип <> Неопределено Тогда
		
		Если Значение <> Неопределено Тогда
			Если Тип = "Число" Тогда
				Значение = Число(Значение);
			ИначеЕсли Тип = "Дата" Тогда
				Значение = ДатаИзСтроки(Значение);
			ИначеЕсли Тип = "Время" Тогда
				Значение = ВремяИзСтроки(Значение);
			ИначеЕсли Тип = "XMLДата" Тогда
				Значение = XMLЗначение(Тип("Дата"),Значение);
			ИначеЕсли Тип = "Булево" Тогда
				Значение = Булево(Значение);
			КонецЕсли;
			
		ИначеЕсли НеопределеноПоУмолчанию Тогда
			Значение = Неопределено;
		ИначеЕсли Тип = "Число" Тогда
			Значение = 0;
		ИначеЕсли Тип = "Дата" Тогда
			Значение = '00010101';
		ИначеЕсли Тип = "XMLДата" Тогда
			Значение = '00010101';
		ИначеЕсли Тип = "Булево" Тогда
			Значение = Ложь;
		ИначеЕсли Тип = "Строка" Тогда
			Значение = "";
		КонецЕсли;
		
	ИначеЕсли ЭтоСписок И ТипЗнч(Значение) <> Тип("СписокXDTO") И Значение <> Неопределено Тогда
		
		// При чтении xml файла фабрикой XDTO без указания типа, если в СпискеXDTO только 1 строка,
		// то список конвертируется в ОбъектXDTO. Вернем его в массиве, чтобы
		// всегда обходить в цикле, вне зависимости от количества строк.
		
		Коллекция = Новый Массив;
		Коллекция.Добавить(Значение);
		
		Значение = Коллекция;
		
	КонецЕсли;
	
	Если Значение = Неопределено И ЗначениеПоУмолчанию <> Неопределено Тогда
		Значение = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Заполняет свойство объекта XDTO.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект заполнения
//  ИмяСвойства - Строка - свойство объекта
//  Значение - Произвольный - устанавливаемое значение
//  Обязательное - Булево - свойство обязательно для заполнения
//  Ошибки - Массив из Строка - коллекция ошибок
//  УстанавливатьПустыеЗначения - Булево - если Истина, то пустое значение будет записано в ОбъектXDTO
Процедура ЗаполнитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, Значение, Обязательное = Ложь, Ошибки = Неопределено,
	УстанавливатьПустыеЗначения = Ложь) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ЗначениеXDTO") ИЛИ ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки);
	Иначе
		Если Обязательное ИЛИ ЗначениеЗаполнено(Значение) ИЛИ УстанавливатьПустыеЗначения Тогда
			УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Сбрасывает свойство объекта XDTO.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект заполнения
//  ИмяСвойства - Строка - свойство объекта
//  Ошибки - Массив из Строка - коллекция ошибок
Процедура СброситьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, Ошибки) Экспорт
	
	Попытка
		ОбъектXDTO.Сбросить(ИмяСвойства);
	Исключение
		ШаблонСообщения = НСтр("ru = 'Выполнение операции: Очистка XDTO.
			|Ошибка сброса значения свойства ""%1"".'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяСвойства);
		
		ОбщегоНазначенияБЭД.ДобавитьОшибку(Ошибки, ТекстСообщения);
		ОбщегоНазначенияБЭД.ЗаписатьВЖурналРегистрации(ТекстСообщения + Символы.ПС
			+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		
	КонецПопытки
	
КонецПроцедуры


// Заполняет свойства XDTO на основании дерева данных.
// 
// Параметры:
// 	ОбъектXDTO - ОбъектXDTO
// 	ЗначенияСвойств - Соответствие из КлючИЗначение:
// 	  * Ключ - Строка - имя свойства XDTO
// 	  * Значение - Строка - путь к значению в дереве
// 	ДеревоДанных - ДеревоЗначений
// 	Ошибки - Массив из Строка - коллекция ошибок
// 	ПараметрыЗаполнения - см. НовыеПараметрыЗаполненияXDTO
Процедура ЗаполнитьСвойстваXDTOИзДерева(ОбъектXDTO, ЗначенияСвойств, ДеревоДанных, Ошибки,
	ПараметрыЗаполнения = Неопределено) Экспорт
	
	Если ПараметрыЗаполнения = Неопределено Тогда
		ПараметрыЗаполнения = НовыеПараметрыЗаполненияXDTO();
	ИначеЕсли ЗначениеЗаполнено(ПараметрыЗаполнения.ОбязательныеСвойства)
		И ЗначениеЗаполнено(ПараметрыЗаполнения.НеобязательныеСвойства) Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка заполнения свойств параметра ПараметрыЗаполнения метода
		|ЗаполнитьСвойстваXDTOИзДерева: должно быть заполнено только одно из свойств:
		| ОбязательныеСвойства, НеобязательныеСвойства'");
	КонецЕсли;
	
	СпискиСвойств = Новый Структура;
	ИменаСвойствСоЗначениямиДата = СтрЗаменить(ПараметрыЗаполнения.СвойстваСоЗначениямиДата, " ", "");
	ИменаСвойствСоЗначениямиДата = СтрРазделить(ИменаСвойствСоЗначениямиДата, ",");
	ПропускаемыеНезаполненныеСвойства = СтрЗаменить(ПараметрыЗаполнения.ПропускаемыеНезаполненныеСвойства, " ", "");
	ПропускаемыеНезаполненныеСвойства = СтрРазделить(ПропускаемыеНезаполненныеСвойства, ",");
	
	ОбязательныеСвойства = Новый Массив;
	НеобязательныеСвойства = Новый Массив;
	Если ЗначениеЗаполнено(ПараметрыЗаполнения.ОбязательныеСвойства) Тогда
		ОбязательныеСвойства = СтрЗаменить(ПараметрыЗаполнения.ОбязательныеСвойства, " ", "");
		ОбязательныеСвойства = СтрРазделить(ПараметрыЗаполнения.ОбязательныеСвойства, ",");
	ИначеЕсли ЗначениеЗаполнено(ПараметрыЗаполнения.НеобязательныеСвойства) Тогда
		НеобязательныеСвойства = СтрЗаменить(ПараметрыЗаполнения.НеобязательныеСвойства, " ", "");
		НеобязательныеСвойства = СтрРазделить(ПараметрыЗаполнения.НеобязательныеСвойства, ",");
	КонецЕсли;
	
	СпискиСвойств.Вставить("ИменаСвойствСоЗначениямиДата", ИменаСвойствСоЗначениямиДата);
	СпискиСвойств.Вставить("ПропускаемыеНезаполненныеСвойства", ПропускаемыеНезаполненныеСвойства);
	СпискиСвойств.Вставить("ОбязательныеСвойства", ОбязательныеСвойства);
	СпискиСвойств.Вставить("НеобязательныеСвойства", НеобязательныеСвойства);
	
	Для Каждого КлючИЗначение Из ЗначенияСвойств Цикл
		ЗаполнитьСвойствоXDTOИзДерева(ОбъектXDTO, КлючИЗначение.Ключ, ДеревоДанных, КлючИЗначение.Значение, Ошибки,
			СпискиСвойств);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает параметры заполнения XDTO. См. ЗаполнитьСвойстваXDTOИзДерева.
// 
// Возвращаемое значение:
// 	Структура:
// * ОбязательныеСвойства - Строка - имена свойств через запятую, которые являются обязательными для заполнения.
//                          Строка должна быть пустой, если заполнены НеобязательныеСвойства.
// * НеобязательныеСвойства - Строка - имена свойств через запятую, которые не являются обязательными для заполнения.
//                            Строка должна быть пустой, если заполнены ОбязательныеСвойства.
// * СвойстваСоЗначениямиДата - Строка - имена свойств, к значениям которых будет применено форматирование
// * ПропускаемыеНезаполненныеСвойства - Строка - имена свойств, которые будут заполнены, только если заполнены их значения
Функция НовыеПараметрыЗаполненияXDTO() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбязательныеСвойства", "");
	Параметры.Вставить("НеобязательныеСвойства", "");
	Параметры.Вставить("СвойстваСоЗначениямиДата", "");
	Параметры.Вставить("ПропускаемыеНезаполненныеСвойства", "");
	
	Возврат Параметры;
	
КонецФункции

// Преобразует ОбъектXDTO в двоичные данные в формате XML.
//
// Параметры:
//  ОбъектXDTO - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  УказаниеТипа - Булево - вариант назначения типа элемента данных XDTO, если истина, то явное.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//  ЛокальноеИмя - Строка - локальное имя записываемого элемента данных.
// Возвращаемое значение:
// 	ДвоичныеДанные
Функция XDTOВДвоичныеДанные(ОбъектXDTO, УказаниеТипа = Истина, ТипКодировки = "windows-1251", ЛокальноеИмя = "") Экспорт
	
	Поток = Новый ПотокВПамяти();
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьПоток(Поток, ТипКодировки);
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	НазначениеТипа = ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное);
	Если ПустаяСтрока(ЛокальноеИмя) Тогда
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO,,,, НазначениеТипа);
	Иначе
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO, ЛокальноеИмя,,, НазначениеТипа);
	КонецЕсли;
	ЗаписьXML.Закрыть();
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

// Получение объекта типа CML.
//
// Параметры:
//  Тип - Строка, ТипЗначенияXDTO, ТипОбъектаXDTO  - тип данных.
//  ВерсияСхемы - Строка - версия схемы.
// 
// Возвращаемое значение:
//  - ОбъектXDTO
//  - ЗначениеXDTO
//
Функция ПолучитьОбъектТипаCML(Тип, ВерсияСхемы = "4.01") Экспорт
	
	Если ТипЗнч(Тип) = Тип("Строка") Тогда
		ТипОбъекта = ПолучитьТипОбъектаCML(Тип, ВерсияСхемы);
	Иначе
		ТипОбъекта = Тип;
	КонецЕсли;
	
	Если ТипОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НовыйОбъект = ФабрикаXDTO.Создать(ТипОбъекта);
	
	Возврат НовыйОбъект;
	
КонецФункции

// Функция получает тип значения CML.
//
// Параметры:
//  Тип - Тип - исходный тип.
//  ВерсияСхемы - Строка - версия схемы CML.
//
// Возвращаемое значение:
//  ТипЗначения - тип значения CML.
//
Функция ПолучитьТипЗначенияCML(Тип, ВерсияСхемы = "4.02") Экспорт
	
	Попытка
		Если ВерсияСхемы <> "4.02" Тогда
			ТипЗначения = ФабрикаXDTO.Тип(ВерсияСхемы, Тип);
		Иначе
			ТипЗначения = ФабрикаXDTO.Тип("http://v8.1c.ru/edi/edi_stnd", Тип);
		КонецЕсли
	Исключение
		
		ТипЗначения = Неопределено;
	КонецПопытки;
	
	Возврат ТипЗначения;
	
КонецФункции

// Разделяет тип XDTO на составляющие.
//
// Параметры:
//  Строка		 - Строка - строка для разделения.
//  Разделитель	 - Строка - разделитель.
// 
// Возвращаемое значение:
//  Массив - результат разделения.
//
Функция ЭлементыПутиТипаXDTO(Знач Строка, Разделитель) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	НачПозицияПервогоЭлемента = СтрНайти(Строка, "{");
	КонПозицияПервогоЭлемента = СтрНайти(Строка, "}");
	Если НачПозицияПервогоЭлемента > 0 И КонПозицияПервогоЭлемента > 0 Тогда
		ПервыйЭлемент = Сред(Строка, НачПозицияПервогоЭлемента, КонПозицияПервогоЭлемента);
		Результат.Добавить(СокрЛП(ПервыйЭлемент));
		Строка = СокрЛП(Сред(Строка,КонПозицияПервогоЭлемента + 2));
	КонецЕсли;
	
	Пока Истина Цикл
		Позиция = СтрНайти(Строка, Разделитель);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СокрЛП(Лев(Строка,Позиция - 1)));
		Строка = СокрЛП(Сред(Строка,Позиция + 1));
	КонецЦикла;
	
	Результат.Добавить(СокрЛП(Строка));
	
	Возврат Результат;
	
КонецФункции 

#КонецОбласти

#Область Прочее

// Заменяет символы, отсутствующие в кодировке текста.
// 
// Параметры:
// 	ИсходнаяСтрока - Строка - в которой требуется замена
// 	Кодировка - Строка
// 	НаЧтоМенять - Строка
// Возвращаемое значение:
// 	Строка
Функция ЗаменитьСимволыОтсутствующиеВКодировкеТекста(ИсходнаяСтрока, Кодировка = "windows-1251", НаЧтоМенять = "") Экспорт
	
	Поток = Новый ПотокВПамяти;
	
	ЗаписьТекста = Новый ЗаписьТекста(Поток, Кодировка);
	ЗаписьТекста.ЗаписатьСтроку(ИсходнаяСтрока);
	ЗаписьТекста.Закрыть();
	
	Поток.Перейти(0, ПозицияВПотоке.Начало);
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	СтрокаТекста = ЧтениеТекста.ПрочитатьСтроку();
	
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	Если ЗначениеЗаполнено(СтрокаТекста) Тогда
		Возврат СтрЗаменить(СтрокаТекста, "?", НаЧтоМенять);
	Иначе
		Возврат ИсходнаяСтрока;
	КонецЕсли;
	
КонецФункции

// Выполняет преобазование имени файла в латиницу, если это требуется 
//
// Параметры:
//  ИмяФайла - Строка
//  ОтключитьТранслитерацию - Булево - Истина, если не переводить в латиницу.
//  
//  Возвращаемое значение:
//   Строка - Имя файла после преобразования.
//
Функция ПреобразоватьИмяФайлаСУчетомТранслитерации(ИмяФайла, ОтключитьТранслитерацию) Экспорт
	
	Результат = ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайла, "_");

	Если Не ОтключитьТранслитерацию Тогда
		Результат = СтроковыеФункции.СтрокаЛатиницей(Результат);
		Результат = СтрЗаменить(Результат, " ", "_");
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ФорматироватьДату(ДатаВремя)
	
	Если ТипЗнч(ДатаВремя) = Тип("Дата") Тогда
		Значение = Формат(ДатаВремя, "ДФ=dd.MM.yyyy");
	Иначе
		Значение = Лев(ДатаВремя, 10);
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Процедура ЗаполнитьСвойствоXDTOИзДерева(ОбъектXDTO, Свойство, ДеревоДанных, ПутьВДереве, Ошибки, СпискиСвойств)
	
	ЗначениеСвойства = ДеревоЭлектронногоДокументаБЭД.ЗначениеРеквизитаВДереве(ДеревоДанных, ПутьВДереве);

	Если ЗначениеЗаполнено(СпискиСвойств.ОбязательныеСвойства) Тогда
		СвойствоОбязательно = СпискиСвойств.ОбязательныеСвойства.Найти(Свойство) <> Неопределено;
	ИначеЕсли ЗначениеЗаполнено(СпискиСвойств.НеобязательныеСвойства) Тогда
		СвойствоОбязательно = СпискиСвойств.НеобязательныеСвойства.Найти(Свойство) = Неопределено;
	Иначе
		СвойствоОбязательно = Истина;
	КонецЕсли;
	
	Если СпискиСвойств.ИменаСвойствСоЗначениямиДата.Найти(Свойство) <> Неопределено Тогда
		ЗначениеСвойства = ФорматироватьДату(ЗначениеСвойства);
	КонецЕсли;
	Если СпискиСвойств.ПропускаемыеНезаполненныеСвойства.Найти(Свойство) = Неопределено Тогда
		ЗаполнитьСвойствоXDTO(ОбъектXDTO, Свойство, ЗначениеСвойства, СвойствоОбязательно, Ошибки);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки)
	
	Попытка
		ОбъектXDTO.Установить(ИмяСвойства, Значение);
	Исключение
		ШаблонСообщения = НСтр("ru = 'Выполнение операции: Заполнение XDTO.
			|Ошибка установки значения свойства ""%1"".'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяСвойства);
		ОбщегоНазначенияБЭД.ДобавитьОшибку(Ошибки, ТекстСообщения);
		
		ОбщегоНазначенияБЭД.ЗаписатьВЖурналРегистрации(ТекстСообщения + Символы.ПС
			+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
	КонецПопытки
	
КонецПроцедуры

// Преобразует строковое представление времени в форматах HH.mm.ss в дату.
//
// Параметры:
//  ВремяСтрокой - Строка - представление времени.
//  Разделитель - Строка - разделитель часов, минут, секунд.
// Возвращаемое значение:
//  Дата - преобразованное значение.
//
Функция ВремяИзСтроки(Знач ВремяСтрокой, Знач Разделитель = ".")
	
	ЧастьДаты = "00010101";
	ЧастьВремени = СтрЗаменить(СокрЛП(ВремяСтрокой), Разделитель, "");
	
	Возврат Дата(ЧастьДаты + ЧастьВремени);
	
КонецФункции

// Преобразует строковое представление даты в форматах DD.MM.YYYY, YYYY-MM-DD в дату.
//
// Параметры:
//  Строка	 - Строка - представление даты.
// Возвращаемое значение:
//  Дата - преобразованное значение.
//
Функция ДатаИзСтроки(Строка) Экспорт
	
	ЧастьДаты    = "";
	ЧастьВремени = "000000";
	Если Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Сред(Строка, 3, 1)) Тогда
		ЧастьДаты = Сред(Строка, 7, 4) + Сред(Строка, 4, 2) + Сред(Строка, 1, 2);
		// заполним дополнительно время для формата "dd.MM.yyyy HH.mm.ss".
		Если СтрДлина(Строка) = 19 Тогда
			ЧастьВремени = СтрЗаменить(Сред(Строка, 12), ".", "");
		КонецЕсли;
	Иначе
		ЧастьДаты = Сред(Строка, 1, 4) + Сред(Строка, 6, 2) + Сред(Строка, 9, 2);
		// заполним дополнительно время для формата 20 символов.
		Если СтрДлина(Строка) = 20 Тогда
			ЧастьВремени = СтрЗаменить(Сред(Строка, 12), ":", "");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Дата(ЧастьДаты + ЧастьВремени);
	
КонецФункции

Функция ДанныеФайлаИзХранилищаЗначений(СвойстваФайла, КонтекстДиагностики = Неопределено)
	
	Если СвойстваФайла.ДвоичныеДанныеФайла <> Неопределено Тогда
		Возврат СвойстваФайла.ДвоичныеДанныеФайла.Получить();
	ИначеЕсли КонтекстДиагностики <> Неопределено Тогда
		КраткоеПредставлениеОшибки = НСтр("ru = 'Отсутствуют данные файла в информационной базе.'");
		МассивСтрок = Новый Массив;
		МассивСтрок.Добавить(НСтр("ru = 'Двоичные данные файла отсутствуют в регистре ДвоичныеДанныеФайлов.'"));
		МассивСтрок.Добавить(СтрШаблон(НСтр("ru = 'Файл: %1'"), СвойстваФайла.Ссылка));
		МассивСтрок.Добавить(СтрШаблон(НСтр("ru = 'Владелец: %1'"), СвойстваФайла.ВладелецФайла));
		ПодробноеПредставлениеОшибки = СтрСоединить(МассивСтрок, Символы.ПС);
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(НСтр("ru = 'Получение данных файла'"),
			ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка(),
			ПодробноеПредставлениеОшибки, КраткоеПредставлениеОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ДанныеФайлаВТомеНаДиске(СвойстваФайла, КонтекстДиагностики = Неопределено)
	
	ПолноеИмя = РаботаСФайламиВТомахСлужебный.ПолноеИмяФайлаВТоме(СвойстваФайла);
	Попытка
		Возврат Новый ДвоичныеДанные(ПолноеИмя);
	Исключение
		Если КонтекстДиагностики <> Неопределено Тогда
			КраткоеПредставлениеОшибки = НСтр("ru = 'Невозможно получить данные присоединенного файла. Файл не найден.'");
			МассивСтрок = Новый Массив;
			МассивСтрок.Добавить(НСтр("ru = 'Файл не найден по указанному пути:.'"));
			МассивСтрок.Добавить(СтрШаблон(НСтр("ru = 'Путь: %1'"), ПолноеИмя));
			МассивСтрок.Добавить(СтрШаблон(НСтр("ru = 'Владелец: %1'"), СвойстваФайла.ВладелецФайла));
			ПодробноеПредставлениеОшибки = СтрСоединить(МассивСтрок, Символы.ПС);
			Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(НСтр("ru = 'Получение данных файла'"),
				ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка(),
				ПодробноеПредставлениеОшибки, КраткоеПредставлениеОшибки);
			ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
				ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		КонецЕсли;
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

Функция МаксимальнаяДлинаИмениФайла()
	
	Возврат 255;
	
КонецФункции

Функция ДлинаФайлаДопустима(ПолноеИмяФайла, КонтекстДиагностики, ВидОперации = "")
	
	Если СтрДлина(ПолноеИмяФайла) > МаксимальнаяДлинаИмениФайла() Тогда
		Если Не ЗначениеЗаполнено(ВидОперации) Тогда
			ВидОперации = НСтр("ru = 'Запись файла'");
		КонецЕсли;
		ТекстОшибки = ОбработкаНеисправностейБЭД.ПолучитьСообщениеОбОшибкеДругойСистемы("007");
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
			РаботаСФайламиБЭДКлиентСервер.ВидОшибкиРаботаСФайлами(),
			ТекстОшибки, ТекстОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		Возврат Ложь;
	Иначе 
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьТипОбъектаCML(Тип, ВерсияСхемы)
	
	МассивПути = ЭлементыПутиТипаXDTO(Тип, ".");
	
	ПервыйЭлемент = МассивПути[0];
	Если Лев(ПервыйЭлемент,1) = "{" И Прав(ПервыйЭлемент,1) = "}" Тогда
		ИмяПакета = Сред(ПервыйЭлемент, 2, СтрДлина(ПервыйЭлемент) - 2);
		Коллекция = ФабрикаXDTO.Пакеты.Получить(ИмяПакета).КорневыеСвойства;
	ИначеЕсли ВерсияСхемы <> "4.02" Тогда
		ТипОбъекта = ФабрикаXDTO.Тип(ВерсияСхемы, ПервыйЭлемент);
		Коллекция = ТипОбъекта.Свойства;
	Иначе
		ТипОбъекта = ФабрикаXDTO.Тип("http://v8.1c.ru/edi/edi_stnd", ПервыйЭлемент);
		Коллекция = ТипОбъекта.Свойства;
	КонецЕсли;
	
	МассивПути.Удалить(0);
	Пока МассивПути.Количество() > 0 Цикл
		
		Если Коллекция = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Свойство = Коллекция.Получить(МассивПути[0]);
		Если Свойство = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТипОбъекта = Свойство.Тип;
		МассивПути.Удалить(0);
		Попытка
			Коллекция = ТипОбъекта.Свойства;
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Проверяет в zip-архиве имена файлов (без расширения) на наличие в них недопустимых символов.
// Такие имена при распаковке обрезаются и может получиться два файла с одинаковыми именами, в результате
// один перезапишет другого.
//
// Параметры:
//  АрхивФайлов - ЧтениеZipФайла - Инициализированный объект чтения zip архива.
// 
// Возвращаемое значение - Булево - Истина, если в архиве есть файлы с недопустимыми символами в именах,
//                                  которые после обрезки становятся одинаковыми.
//
Функция ЕстьОдинаковыеИменаФайловСНедопустимымиСимволамиВАрхиве(АрхивФайлов)
	
	ФлагОшибки = Ложь;
	
	ИменаОсновныхФайлов = Новый ТаблицаЗначений;
	ИменаОсновныхФайлов.Колонки.Добавить("ИмяФайла");
	ИменаОсновныхФайлов.Колонки.Добавить("СчетчикИмен");
	ИменаОсновныхФайлов.Колонки.Добавить("ФлагНедопустимыхСимволов");
	
	Для Каждого ФайлАрхива Из АрхивФайлов.Элементы Цикл
		
		НекорректныеСимволы = ОбщегоНазначенияКлиентСервер.НайтиНедопустимыеСимволыВИмениФайла(
			ФайлАрхива.ИсходноеИмяБезРасширения);
		
		СтрокаТаблицы                          = ИменаОсновныхФайлов.Добавить();
		СтрокаТаблицы.ИмяФайла                 = ФайлАрхива.Имя;
		СтрокаТаблицы.СчетчикИмен              = 1;
		СтрокаТаблицы.ФлагНедопустимыхСимволов = НекорректныеСимволы.Количество();
		
	КонецЦикла;
	
	Если ИменаОсновныхФайлов.Количество() Тогда
		
		ИменаОсновныхФайлов.Свернуть("ИмяФайла", "СчетчикИмен, ФлагНедопустимыхСимволов");
		
		Для Каждого Строка Из ИменаОсновныхФайлов Цикл
			Если Строка.СчетчикИмен > 1 И Строка.ФлагНедопустимыхСимволов Тогда
				ФлагОшибки = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ФлагОшибки;
	
КонецФункции

#КонецОбласти
